{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"design/cute/copy/","text":"CUTE \u4e0b\u9762\u5185\u5bb9\u7b80\u8981\u8bf4\u660e cute::copy \u7684\u62bd\u8c61\u7ed3\u6784\u3001\u6a21\u5757\u7ec4\u6210\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u534f\u540c\u5de5\u4f5c\u3002 Cute Copy \u62bd\u8c61\u6982\u8ff0 Cute \u7684 copy \u62bd\u8c61\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u6267\u884c\u5404\u79cd\u7c7b\u578b\u7684\u5185\u5b58\u62f7\u8d1d\u64cd\u4f5c\uff0c\u4ece\u7b80\u5355\u7684\u5bc4\u5b58\u5668\u5230\u5bc4\u5b58\u5668\u62f7\u8d1d\u5230\u590d\u6742\u7684\u5f20\u91cf\u64cd\u4f5c\u548c\u786c\u4ef6\u52a0\u901f\u7684\u5f02\u6b65\u62f7\u8d1d\u3002 \u4e3b\u8981\u6a21\u5757\u548c API 1. CopyAtom \u6a21\u5757 CopyAtom \u662f copy \u64cd\u4f5c\u7684\u57fa\u672c\u6784\u5efa\u5355\u5143\uff0c\u5b83\u5c01\u88c5\u4e86\u5e95\u5c42\u786c\u4ef6\u6307\u4ee4\u7684\u7279\u6027\u3002 API \u7279\u70b9\uff1a Copy_Atom<CopyOperation, CopyInternalType> : \u5b9a\u4e49\u4e00\u4e2a copy \u539f\u5b50\u64cd\u4f5c call() : \u6267\u884c\u5b9e\u9645\u7684 copy \u64cd\u4f5c with() : \u4e3a copy \u64cd\u4f5c\u6dfb\u52a0\u989d\u5916\u53c2\u6570 Copy_Traits: \u5b9a\u4e49 copy \u64cd\u4f5c\u7684\u7279\u5f81\uff0c\u5305\u62ec\u7ebf\u7a0b\u5e03\u5c40\u548c\u6570\u636e\u5e03\u5c40\u3002 Copy_Traits : \u5b9a\u4e49 copy \u64cd\u4f5c\u7684\u7279\u5f81 copy_unpack() : \u89e3\u5305\u5e76\u6267\u884c copy \u64cd\u4f5c CopyOperation \u5b9a\u4e49\u4e86\u5e95\u5c42\u786c\u4ef6 copy \u64cd\u4f5c\u548c\u57fa\u672c\u7684 copy \u7b56\u7565\u3002 CopyOperation // \u6700\u57fa\u672c\u7684 copy \u64cd\u4f5c template <class S, class D = S> struct UniversalCopy { CUTE_HOST_DEVICE static constexpr void copy(S const& src, D& dst) { dst = src; } }; Copy_Traits /** * concept Copy_Traits * { * using ThrID = // Logical thread id (tid) -> tidx * * using SrcLayout = // (Logical src thread id (tid), Logical src value id (vid)) -> bit * using DstLayout = // (Logical dst thread id (tid), Logical dst value id (vid)) -> bit * using RefLayout = // (Logical ref thread id (tid), Logical ref value id (vid)) -> bit * }; * * The abstract bit ordering of the Copy_Traits (the codomain of SrcLayout, DstLayout, and RefLayout) * is arbitrary and only used to construct maps * (ref-tid,ref-vid) -> (src-tid,src-vid) * (ref-tid,ref-vid) -> (dst-tid,dst-vid) * in TiledCopy. The Layout_TV in TiledCopy is in accordance with the RefLayout of a Traits, then mapped to * the Src or Dst (tid,vid) representation on demand. * */ template <class CopyOperation, class... CopyOpArgs> struct Copy_Traits { static_assert(dependent_false<CopyOperation>, \"Copy_Traits not implemented for this CopyOperation.\"); }; template <class S, class D> struct Copy_Traits<UniversalCopy<S,D>> { // Logical thread id to thread idx (one-thread) using ThrID = Layout<_1>; // Map from (src-thr,src-val) to bit using SrcLayout = Layout<Shape<_1,Int<sizeof_bits<S>::value>>>; // Map from (dst-thr,dst-val) to bit using DstLayout = Layout<Shape<_1,Int<sizeof_bits<D>::value>>>; // Reference map from (thr,val) to bit using RefLayout = SrcLayout; }; Copy_Atom template <class... Args, class CopyInternalType> struct Copy_Atom<Copy_Traits<Args...>, CopyInternalType> : Copy_Traits<Args...> {}; \u8bbe\u8ba1\u6a21\u5f0f \u4e0a\u8ff0\u8fd9\u662f\u4e00\u4e2a\u6a21\u677f\u504f\u7279\u5316\uff08template partial specialization\uff09\u7684\u5199\u6cd5\uff0c\u8ba9\u6211\u8be6\u7ec6\u89e3>\u4e00\u4e0b\uff1a \u8fd9\u79cd\u5199\u6cd5\u662fC++\u6a21\u677f\u7f16\u7a0b\u4e2d\u5e38\u89c1\u7684\u6a21\u5f0f\uff0c\u7528\u4e8e\u5904\u7406\u4e0d\u540c\u7c7b\u578b\u7684\u6a21\u677f\u53c2\u6570\u3002\u8ba9\u6211\u4eec\u770b\u770b\u8fd9\u91cc\u6d89\u53ca>\u4e24\u4e2a\u58f0\u660e\uff1a // \u4e3b\u6a21\u677f\u58f0\u660e\uff08\u901a\u7528\u6a21\u677f\uff09 template <class... Args> struct Copy_Atom; // \u504f\u7279\u5316\u7248\u672c1\uff1a\u5904\u7406CopyOperation, CopyInternalType\u53c2\u6570 template <class CopyOperation, class CopyInternalType> struct Copy_Atom<CopyOperation, CopyInternalType> : Copy_Atom<Copy_Traits<CopyOperation>, CopyInternalType> {}; // \u504f\u7279\u5316\u7248\u672c2\uff1a\u5904\u7406Copy_Traits<Args...>, CopyInternalType\u53c2\u6570 template <class... Args, class CopyInternalType> struct Copy_Atom<Copy_Traits<Args...>, CopyInternalType> : Copy_Traits<Args...> { // \u5b9e\u9645\u7684\u5b9e\u73b0... }; \u5f53\u7528\u6237\u8fd9\u6837\u4f7f\u7528\u65f6\uff1a Copy_Atom<SomeCopyOperation, float> my_copy_atom; \u7f16\u8bd1\u5668\u4f1a\u5339\u914d\u5230\u7b2c\u4e00\u4e2a\u504f\u7279\u5316\u7248\u672c\uff0c\u5b83\u4f1a\u7ee7\u627f\u81ea\uff1a Copy_Atom<Copy_Traits<SomeCopyOperation>, float> \u7136\u540e\u8fd9\u4e2a\u53c8\u4f1a\u5339\u914d\u5230\u7b2c\u4e8c\u4e2a\u504f\u7279\u5316\u7248\u672c\uff0c\u6700\u7ec8\u7ee7\u627f\u81ea\uff1a Copy_Traits<SomeCopyOperation> \u4f5c\u7528\u548c\u4f18\u52bf \u7c7b\u578b\u8f6c\u6362\u5c42 \uff1a\u8fd9\u79cd\u8bbe\u8ba1\u5c06\u5177\u4f53\u7684CopyOperation\u7c7b\u578b\u8f6c\u6362\u4e3aCopy_Traits\u7c7b\u578b\uff0c>\u73b0\u4e86\u7c7b\u578b\u9002\u914d\u3002 \u7edf\u4e00\u63a5\u53e3 \uff1a\u65e0\u8bba\u7528\u6237\u4f20\u5165\u7684\u662f\u539f\u59cb\u7684CopyOperation\u8fd8\u662f\u5df2\u7ecf\u7279\u5316\u7684> py_Traits\uff0c\u6700\u7ec8\u90fd\u4f1a\u5f52\u4e00\u5230\u57fa\u4e8eCopy_Traits\u7684\u5b9e\u73b0\u3002 \u6269\u5c55\u6027 \uff1a\u5141\u8bb8\u7528\u6237\u76f4\u63a5\u4f7f\u7528\u786c\u4ef6\u64cd\u4f5c\u7c7b\u578b\uff08\u5982SM80_CP_ASYNC_CACHEALWAYS\uff09>\u8005\u5df2\u7ecf\u5b9a\u4e49\u597d\u7684Copy_Traits\u3002 \u4f8b\u5982\uff1a // \u7528\u6237\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u786c\u4ef6\u64cd\u4f5c\u7c7b\u578b Copy_Atom<SM80_CP_ASYNC_CACHEALWAYS<uint8_t, uint8_t>, uint8_t> > om1; // \u6216\u8005\u4f7f\u7528\u5df2\u7ecf\u5b9a\u4e49\u7684Traits Copy_Atom<Copy_Traits<SM80_CP_ASYNC_CACHEALWAYS<uint8_t, uint8_t>>, > nt8_t> atom2; \u4e24\u79cd\u7528\u6cd5\u90fd\u4f1a\u88ab\u6b63\u786e\u5904\u7406\u5e76\u6700\u7ec8\u7ee7\u627f\u76f8\u5e94\u7684Copy_Traits\u5b9e\u73b0\u3002 \u8fd9\u662fC++\u6a21\u677f\u5143\u7f16\u7a0b\u4e2d\u5e38\u89c1\u7684\u8bbe\u8ba1\u6a21\u5f0f\uff0c\u7528\u4e8e\u6784\u5efa\u7075\u6d3b\u4e14\u7c7b\u578b\u5b89\u5168\u7684\u6a21\u677f\u5e93\u3002 2. TiledCopy \u6a21\u5757 TiledCopy \u5c06 CopyAtom \u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757\uff0c\u652f\u6301\u591a\u7ebf\u7a0b\u534f\u4f5c\u3002 API \u7279\u70b9\uff1a make_tiled_copy() : \u521b\u5efa\u4e00\u4e2a\u5206\u5757\u7684 copy \u64cd\u4f5c get_slice() : \u8fd4\u56de ThrCopy \u6210\u5458\uff1a AtomLayoutRef \u7528\u4e8e TiledCopy template <class Copy_Atom, class LayoutCopy_TV, // (tid,vid) -> coord [Need not be 2D...] class ShapeTiler_MN> // coord space struct TiledCopy : Copy_Atom { // Layout information from the CopyAtom using AtomThrID = typename Copy_Atom::ThrID; // thrid -> thr_idx using AtomLayoutSrc = typename Copy_Atom::ValLayoutSrc; // (thr,val) -> offset using AtomLayoutDst = typename Copy_Atom::ValLayoutDst; // (thr,val) -> offset using AtomLayoutRef = typename Copy_Atom::ValLayoutRef; // (thr,val) -> offset using AtomNumThr = decltype(size<0>(AtomLayoutRef{})); using AtomNumVal = decltype(size<1>(AtomLayoutRef{})); // Layout information for the TiledCopy using Tiler_MN = ShapeTiler_MN; using TiledLayout_TV = LayoutCopy_TV; using TiledNumThr = decltype(size<0>(TiledLayout_TV{})); using TiledNumVal = decltype(size<1>(TiledLayout_TV{})); ... } get_slice template <class ThrIdx, __CUTE_REQUIRES(is_integral<ThrIdx>::value)> CUTE_HOST_DEVICE static auto get_slice(ThrIdx const& thr_idx) { return ThrCopy<TiledCopy, ThrIdx>(thr_idx); } 3. ThrCopy \u6a21\u5757 ThrCopy \u8868\u793a\u5355\u4e2a\u7ebf\u7a0b\u89c6\u89d2\u4e0b\u7684 copy \u64cd\u4f5c\u3002 API \u7279\u70b9\uff1a partition_S() : \u5206\u5272\u6e90\u5f20\u91cf\u4ee5\u83b7\u53d6\u7ebf\u7a0b\u7ea7\u522b\u7684 layout partition_D() : \u5206\u5272\u76ee\u6807\u5f20\u91cf\u4ee5\u83b7\u53d6\u7ebf\u7a0b\u7ea7\u522b\u7684 layout retile_S/D() : \u91cd\u65b0\u7ec4\u7ec7\u5f20\u91cf\u7ed3\u6784 template <class TiledCopy, class ThrIdx> struct ThrCopy { ThrIdx thr_idx_; CUTE_HOST_DEVICE ThrCopy(ThrIdx const& thr_idx) : thr_idx_(thr_idx) {} template <class STensor> CUTE_HOST_DEVICE auto partition_S(STensor&& stensor) const { //static_assert(sizeof(typename remove_cvref_t<STensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling SrcTensor.\"); auto thr_tensor = make_tensor(static_cast<STensor&&>(stensor).data(), TiledCopy::tidfrg_S(stensor.layout())); return thr_tensor(thr_idx_, _, repeat<rank_v<STensor>>(_)); } template <class DTensor> CUTE_HOST_DEVICE auto partition_D(DTensor&& dtensor) const { //static_assert(sizeof(typename remove_cvref_t<DTensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling DstTensor.\"); auto thr_tensor = make_tensor(static_cast<DTensor&&>(dtensor).data(), TiledCopy::tidfrg_D(dtensor.layout())); return thr_tensor(thr_idx_, _, repeat<rank_v<DTensor>>(_)); } template <class STensor> CUTE_HOST_DEVICE static auto retile_S(STensor&& stensor) { // static_assert(sizeof(typename remove_cvref_t<STensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling SrcTensor.\"); return make_tensor(static_cast<STensor&&>(stensor).data(), TiledCopy::retile(stensor.layout())); } template <class DTensor> CUTE_HOST_DEVICE static auto retile_D(DTensor&& dtensor) { // static_assert(sizeof(typename remove_cvref_t<DTensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling DstTensor.\"); return make_tensor(static_cast<DTensor&&>(dtensor).data(), TiledCopy::retile(dtensor.layout())); } }; \u8f85\u52a9\u51fd\u6570 1. \u521b\u5efa\u51fd\u6570 make_tiled_copy() : \u521b\u5efa\u5206\u5757 copy make_tiled_copy_A/B/C() : \u4e3a\u77e9\u9635\u4e58\u6cd5\u521b\u5efa\u7279\u5b9a\u7684 copy make_cotiled_copy() : \u57fa\u4e8e\u504f\u79fb\u6620\u5c04\u521b\u5efa copy 2. \u6267\u884c\u51fd\u6570 copy() : \u4e3b\u8981\u7684 copy \u63a5\u53e3 copy_if() : \u5e26\u6761\u4ef6\u8c13\u8bcd\u7684 copy copy_aligned() : \u5bf9\u9f50\u5047\u8bbe\u7684 copy \u6a21\u5757\u534f\u540c\u5de5\u4f5c\u65b9\u5f0f // ... existing code ... template <class... CopyArgs, class SrcEngine, class SrcLayout, class DstEngine, class DstLayout> CUTE_HOST_DEVICE void copy(Copy_Atom<CopyArgs...> const& copy_atom, Tensor<SrcEngine, SrcLayout> const& src, // (V,Rest...) Tensor<DstEngine, DstLayout> & dst) // (V,Rest...) { static_assert(SrcLayout::rank == DstLayout::rank, \"CopyAtom rank-mismatch.\"); if constexpr (SrcLayout::rank == 1) { // Dispatch the copy copy_atom.call(src, dst); } else { // Loop over all but the first mode constexpr int R = SrcLayout::rank; Tensor src_v = group_modes<1,R>(src); Tensor dst_v = group_modes<1,R>(dst); if constexpr (is_static<decltype(shape(src_v))>::value && is_static<decltype(shape(dst_v))>::value) { CUTE_STATIC_ASSERT_V(size<1>(src_v) == size<1>(dst_v)); // AutoFilter on the Rest-mode auto dst_null = nullspace(layout<1>(dst_v)); Tensor dst_n = zipped_divide(dst_v, make_tile(shape<0>(dst_v), dst_null)); // ((V, NLL), (_1, Rest)) Tensor src_n = zipped_divide(src_v, make_tile(shape<0>(src_v), dst_null)); // ((V, NLL), (_1, Rest)) CUTE_STATIC_ASSERT_V(size<1>(src_n) == size<1>(dst_n)); CUTE_STATIC_ASSERT_V((cosize<0,1>(dst_n.layout()) == Int<1>{}), \"Nullspace definition error\"); CUTE_STATIC_ASSERT_V((cosize<0,1>(src_n.layout()) == Int<1>{}), \"Error: Ambiguous scatter detected in copy\"); CUTE_STATIC_ASSERT_V((size<1,0>(dst_n) == Int<1>{})); CUTE_STATIC_ASSERT_V((size<1,0>(src_n) == Int<1>{})); Tensor dst_c = dst_n(make_coord(_,Int<0>{}),make_coord(Int<0>{},_)); // (V, Rest) Tensor src_c = src_n(make_coord(_,Int<0>{}),make_coord(Int<0>{},_)); // (V, Rest) CUTE_STATIC_ASSERT_V( size<1>(src_c) == size<1>(dst_c)); CUTE_STATIC_ASSERT_V(shape<0>(dst_c) == shape<0>(dst)); CUTE_STATIC_ASSERT_V(shape<0>(src_c) == shape<0>(src)); CUTE_UNROLL for (int i = 0; i < size<1>(dst_c); ++i) { copy_atom.call(src_c(_,i), dst_c(_,i)); } } else { CUTE_UNROLL for (int i = 0; i < size<1>(dst_v); ++i) { copy_atom.call(src_v(_,i), dst_v(_,i)); } } } } // ... existing code ... // ... existing code ... template <class SEngine, class SLayout, class DEngine, class DLayout> CUTE_HOST_DEVICE void call(Tensor<SEngine,SLayout> const& src, Tensor<DEngine,DLayout> & dst) const { static_assert(SLayout::rank == 1, \"Expected rank-1 src tensor\"); static_assert(DLayout::rank == 1, \"Expected rank-1 dst tensor\"); if constexpr (is_constant<NumValSrc, decltype(size(src))>::value || is_constant<NumValDst, decltype(size(dst))>::value) { // Dispatch to unpack to execute instruction return copy_unpack(static_cast<Traits const&>(*this), src, dst); } else if constexpr (is_tuple<decltype(shape(src))>::value && is_tuple<decltype(shape(dst))>::value) { // If the size of the src/dst doesn't match the instruction, // recurse this rank-1 layout by peeling off the mode // ((A,B,C,...)) -> (A,B,C,...) return copy(*this, tensor<0>(src), tensor<0>(dst)); } else { static_assert(dependent_false<SEngine>, \"CopyAtom: Src/Dst partitioning does not match the instruction requirement.\"); } } // ... existing code ... \u5de5\u4f5c\u6d41\u7a0b CopyAtom \u5c42 : \u5b9a\u4e49\u57fa\u672c\u7684 copy \u64cd\u4f5c\u5355\u5143\uff0c\u5305\u62ec\u7ebf\u7a0b\u5e03\u5c40\u548c\u6570\u636e\u5e03\u5c40 TiledCopy \u5c42 : \u5c06 CopyAtom \u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757\uff0c\u652f\u6301\u591a\u7ebf\u7a0b\u534f\u4f5c ThrCopy \u5c42 : \u4e3a\u6bcf\u4e2a\u7ebf\u7a0b\u63d0\u4f9b\u7279\u5b9a\u7684 copy \u89c6\u56fe \u6267\u884c\u5c42 : \u901a\u8fc7 copy() \u6216 copy_if() \u51fd\u6570\u5b9e\u9645\u6267\u884c copy \u64cd\u4f5c \u8fd9\u4e9b\u6a21\u5757\u901a\u8fc7\u6a21\u677f\u7279\u5316\u548c\u9012\u5f52\u8c03\u7528\u534f\u540c\u5de5\u4f5c\uff0c\u5f62\u6210\u4e86\u4e00\u4e2a\u7075\u6d3b\u4e14\u9ad8\u6548\u7684 copy \u62bd\u8c61\uff0c\u53ef\u4ee5\u9002\u5e94\u4ece\u7b80\u5355\u5bc4\u5b58\u5668\u64cd\u4f5c\u5230\u590d\u6742\u5f20\u91cf\u64cd\u4f5c\u7684\u5404\u79cd\u573a\u666f\u3002 \u6574\u4e2a\u7cfb\u7edf\u901a\u8fc7 traits \u6a21\u5f0f\u5b9e\u73b0\uff0c\u5141\u8bb8\u4e3a\u4e0d\u540c\u7684\u786c\u4ef6\u67b6\u6784\u548c copy \u64cd\u4f5c\u7c7b\u578b\u63d0\u4f9b\u4e13\u95e8\u7684\u5b9e\u73b0\uff0c\u540c\u65f6\u4fdd\u6301\u7edf\u4e00\u7684\u63a5\u53e3\u3002\u8fd9\u79cd\u8bbe\u8ba1\u4f7f\u5f97\u7528\u6237\u53ef\u4ee5\u7528\u76f8\u540c\u7684 API \u5728\u4e0d\u540c\u7684\u786c\u4ef6\u4e0a\u6267\u884c copy \u64cd\u4f5c\uff0c\u800c\u5e95\u5c42\u5b9e\u73b0\u4f1a\u6839\u636e\u5177\u4f53\u7684\u786c\u4ef6\u548c\u6570\u636e\u7c7b\u578b\u81ea\u52a8\u9009\u62e9\u6700\u4f18\u7684\u6267\u884c\u8def\u5f84\u3002","title":"copy"},{"location":"design/cute/copy/#cute","text":"\u4e0b\u9762\u5185\u5bb9\u7b80\u8981\u8bf4\u660e cute::copy \u7684\u62bd\u8c61\u7ed3\u6784\u3001\u6a21\u5757\u7ec4\u6210\u4ee5\u53ca\u5b83\u4eec\u5982\u4f55\u534f\u540c\u5de5\u4f5c\u3002","title":"CUTE"},{"location":"design/cute/copy/#cute-copy","text":"Cute \u7684 copy \u62bd\u8c61\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u63a5\u53e3\u6765\u6267\u884c\u5404\u79cd\u7c7b\u578b\u7684\u5185\u5b58\u62f7\u8d1d\u64cd\u4f5c\uff0c\u4ece\u7b80\u5355\u7684\u5bc4\u5b58\u5668\u5230\u5bc4\u5b58\u5668\u62f7\u8d1d\u5230\u590d\u6742\u7684\u5f20\u91cf\u64cd\u4f5c\u548c\u786c\u4ef6\u52a0\u901f\u7684\u5f02\u6b65\u62f7\u8d1d\u3002","title":"Cute Copy \u62bd\u8c61\u6982\u8ff0"},{"location":"design/cute/copy/#api","text":"","title":"\u4e3b\u8981\u6a21\u5757\u548c API"},{"location":"design/cute/copy/#1-copyatom","text":"CopyAtom \u662f copy \u64cd\u4f5c\u7684\u57fa\u672c\u6784\u5efa\u5355\u5143\uff0c\u5b83\u5c01\u88c5\u4e86\u5e95\u5c42\u786c\u4ef6\u6307\u4ee4\u7684\u7279\u6027\u3002 API \u7279\u70b9\uff1a Copy_Atom<CopyOperation, CopyInternalType> : \u5b9a\u4e49\u4e00\u4e2a copy \u539f\u5b50\u64cd\u4f5c call() : \u6267\u884c\u5b9e\u9645\u7684 copy \u64cd\u4f5c with() : \u4e3a copy \u64cd\u4f5c\u6dfb\u52a0\u989d\u5916\u53c2\u6570 Copy_Traits: \u5b9a\u4e49 copy \u64cd\u4f5c\u7684\u7279\u5f81\uff0c\u5305\u62ec\u7ebf\u7a0b\u5e03\u5c40\u548c\u6570\u636e\u5e03\u5c40\u3002 Copy_Traits : \u5b9a\u4e49 copy \u64cd\u4f5c\u7684\u7279\u5f81 copy_unpack() : \u89e3\u5305\u5e76\u6267\u884c copy \u64cd\u4f5c CopyOperation \u5b9a\u4e49\u4e86\u5e95\u5c42\u786c\u4ef6 copy \u64cd\u4f5c\u548c\u57fa\u672c\u7684 copy \u7b56\u7565\u3002 CopyOperation // \u6700\u57fa\u672c\u7684 copy \u64cd\u4f5c template <class S, class D = S> struct UniversalCopy { CUTE_HOST_DEVICE static constexpr void copy(S const& src, D& dst) { dst = src; } }; Copy_Traits /** * concept Copy_Traits * { * using ThrID = // Logical thread id (tid) -> tidx * * using SrcLayout = // (Logical src thread id (tid), Logical src value id (vid)) -> bit * using DstLayout = // (Logical dst thread id (tid), Logical dst value id (vid)) -> bit * using RefLayout = // (Logical ref thread id (tid), Logical ref value id (vid)) -> bit * }; * * The abstract bit ordering of the Copy_Traits (the codomain of SrcLayout, DstLayout, and RefLayout) * is arbitrary and only used to construct maps * (ref-tid,ref-vid) -> (src-tid,src-vid) * (ref-tid,ref-vid) -> (dst-tid,dst-vid) * in TiledCopy. The Layout_TV in TiledCopy is in accordance with the RefLayout of a Traits, then mapped to * the Src or Dst (tid,vid) representation on demand. * */ template <class CopyOperation, class... CopyOpArgs> struct Copy_Traits { static_assert(dependent_false<CopyOperation>, \"Copy_Traits not implemented for this CopyOperation.\"); }; template <class S, class D> struct Copy_Traits<UniversalCopy<S,D>> { // Logical thread id to thread idx (one-thread) using ThrID = Layout<_1>; // Map from (src-thr,src-val) to bit using SrcLayout = Layout<Shape<_1,Int<sizeof_bits<S>::value>>>; // Map from (dst-thr,dst-val) to bit using DstLayout = Layout<Shape<_1,Int<sizeof_bits<D>::value>>>; // Reference map from (thr,val) to bit using RefLayout = SrcLayout; }; Copy_Atom template <class... Args, class CopyInternalType> struct Copy_Atom<Copy_Traits<Args...>, CopyInternalType> : Copy_Traits<Args...> {}; \u8bbe\u8ba1\u6a21\u5f0f \u4e0a\u8ff0\u8fd9\u662f\u4e00\u4e2a\u6a21\u677f\u504f\u7279\u5316\uff08template partial specialization\uff09\u7684\u5199\u6cd5\uff0c\u8ba9\u6211\u8be6\u7ec6\u89e3>\u4e00\u4e0b\uff1a \u8fd9\u79cd\u5199\u6cd5\u662fC++\u6a21\u677f\u7f16\u7a0b\u4e2d\u5e38\u89c1\u7684\u6a21\u5f0f\uff0c\u7528\u4e8e\u5904\u7406\u4e0d\u540c\u7c7b\u578b\u7684\u6a21\u677f\u53c2\u6570\u3002\u8ba9\u6211\u4eec\u770b\u770b\u8fd9\u91cc\u6d89\u53ca>\u4e24\u4e2a\u58f0\u660e\uff1a // \u4e3b\u6a21\u677f\u58f0\u660e\uff08\u901a\u7528\u6a21\u677f\uff09 template <class... Args> struct Copy_Atom; // \u504f\u7279\u5316\u7248\u672c1\uff1a\u5904\u7406CopyOperation, CopyInternalType\u53c2\u6570 template <class CopyOperation, class CopyInternalType> struct Copy_Atom<CopyOperation, CopyInternalType> : Copy_Atom<Copy_Traits<CopyOperation>, CopyInternalType> {}; // \u504f\u7279\u5316\u7248\u672c2\uff1a\u5904\u7406Copy_Traits<Args...>, CopyInternalType\u53c2\u6570 template <class... Args, class CopyInternalType> struct Copy_Atom<Copy_Traits<Args...>, CopyInternalType> : Copy_Traits<Args...> { // \u5b9e\u9645\u7684\u5b9e\u73b0... }; \u5f53\u7528\u6237\u8fd9\u6837\u4f7f\u7528\u65f6\uff1a Copy_Atom<SomeCopyOperation, float> my_copy_atom; \u7f16\u8bd1\u5668\u4f1a\u5339\u914d\u5230\u7b2c\u4e00\u4e2a\u504f\u7279\u5316\u7248\u672c\uff0c\u5b83\u4f1a\u7ee7\u627f\u81ea\uff1a Copy_Atom<Copy_Traits<SomeCopyOperation>, float> \u7136\u540e\u8fd9\u4e2a\u53c8\u4f1a\u5339\u914d\u5230\u7b2c\u4e8c\u4e2a\u504f\u7279\u5316\u7248\u672c\uff0c\u6700\u7ec8\u7ee7\u627f\u81ea\uff1a Copy_Traits<SomeCopyOperation> \u4f5c\u7528\u548c\u4f18\u52bf \u7c7b\u578b\u8f6c\u6362\u5c42 \uff1a\u8fd9\u79cd\u8bbe\u8ba1\u5c06\u5177\u4f53\u7684CopyOperation\u7c7b\u578b\u8f6c\u6362\u4e3aCopy_Traits\u7c7b\u578b\uff0c>\u73b0\u4e86\u7c7b\u578b\u9002\u914d\u3002 \u7edf\u4e00\u63a5\u53e3 \uff1a\u65e0\u8bba\u7528\u6237\u4f20\u5165\u7684\u662f\u539f\u59cb\u7684CopyOperation\u8fd8\u662f\u5df2\u7ecf\u7279\u5316\u7684> py_Traits\uff0c\u6700\u7ec8\u90fd\u4f1a\u5f52\u4e00\u5230\u57fa\u4e8eCopy_Traits\u7684\u5b9e\u73b0\u3002 \u6269\u5c55\u6027 \uff1a\u5141\u8bb8\u7528\u6237\u76f4\u63a5\u4f7f\u7528\u786c\u4ef6\u64cd\u4f5c\u7c7b\u578b\uff08\u5982SM80_CP_ASYNC_CACHEALWAYS\uff09>\u8005\u5df2\u7ecf\u5b9a\u4e49\u597d\u7684Copy_Traits\u3002 \u4f8b\u5982\uff1a // \u7528\u6237\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u786c\u4ef6\u64cd\u4f5c\u7c7b\u578b Copy_Atom<SM80_CP_ASYNC_CACHEALWAYS<uint8_t, uint8_t>, uint8_t> > om1; // \u6216\u8005\u4f7f\u7528\u5df2\u7ecf\u5b9a\u4e49\u7684Traits Copy_Atom<Copy_Traits<SM80_CP_ASYNC_CACHEALWAYS<uint8_t, uint8_t>>, > nt8_t> atom2; \u4e24\u79cd\u7528\u6cd5\u90fd\u4f1a\u88ab\u6b63\u786e\u5904\u7406\u5e76\u6700\u7ec8\u7ee7\u627f\u76f8\u5e94\u7684Copy_Traits\u5b9e\u73b0\u3002 \u8fd9\u662fC++\u6a21\u677f\u5143\u7f16\u7a0b\u4e2d\u5e38\u89c1\u7684\u8bbe\u8ba1\u6a21\u5f0f\uff0c\u7528\u4e8e\u6784\u5efa\u7075\u6d3b\u4e14\u7c7b\u578b\u5b89\u5168\u7684\u6a21\u677f\u5e93\u3002","title":"1. CopyAtom \u6a21\u5757"},{"location":"design/cute/copy/#2-tiledcopy","text":"TiledCopy \u5c06 CopyAtom \u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757\uff0c\u652f\u6301\u591a\u7ebf\u7a0b\u534f\u4f5c\u3002 API \u7279\u70b9\uff1a make_tiled_copy() : \u521b\u5efa\u4e00\u4e2a\u5206\u5757\u7684 copy \u64cd\u4f5c get_slice() : \u8fd4\u56de ThrCopy \u6210\u5458\uff1a AtomLayoutRef \u7528\u4e8e TiledCopy template <class Copy_Atom, class LayoutCopy_TV, // (tid,vid) -> coord [Need not be 2D...] class ShapeTiler_MN> // coord space struct TiledCopy : Copy_Atom { // Layout information from the CopyAtom using AtomThrID = typename Copy_Atom::ThrID; // thrid -> thr_idx using AtomLayoutSrc = typename Copy_Atom::ValLayoutSrc; // (thr,val) -> offset using AtomLayoutDst = typename Copy_Atom::ValLayoutDst; // (thr,val) -> offset using AtomLayoutRef = typename Copy_Atom::ValLayoutRef; // (thr,val) -> offset using AtomNumThr = decltype(size<0>(AtomLayoutRef{})); using AtomNumVal = decltype(size<1>(AtomLayoutRef{})); // Layout information for the TiledCopy using Tiler_MN = ShapeTiler_MN; using TiledLayout_TV = LayoutCopy_TV; using TiledNumThr = decltype(size<0>(TiledLayout_TV{})); using TiledNumVal = decltype(size<1>(TiledLayout_TV{})); ... } get_slice template <class ThrIdx, __CUTE_REQUIRES(is_integral<ThrIdx>::value)> CUTE_HOST_DEVICE static auto get_slice(ThrIdx const& thr_idx) { return ThrCopy<TiledCopy, ThrIdx>(thr_idx); }","title":"2. TiledCopy \u6a21\u5757"},{"location":"design/cute/copy/#3-thrcopy","text":"ThrCopy \u8868\u793a\u5355\u4e2a\u7ebf\u7a0b\u89c6\u89d2\u4e0b\u7684 copy \u64cd\u4f5c\u3002 API \u7279\u70b9\uff1a partition_S() : \u5206\u5272\u6e90\u5f20\u91cf\u4ee5\u83b7\u53d6\u7ebf\u7a0b\u7ea7\u522b\u7684 layout partition_D() : \u5206\u5272\u76ee\u6807\u5f20\u91cf\u4ee5\u83b7\u53d6\u7ebf\u7a0b\u7ea7\u522b\u7684 layout retile_S/D() : \u91cd\u65b0\u7ec4\u7ec7\u5f20\u91cf\u7ed3\u6784 template <class TiledCopy, class ThrIdx> struct ThrCopy { ThrIdx thr_idx_; CUTE_HOST_DEVICE ThrCopy(ThrIdx const& thr_idx) : thr_idx_(thr_idx) {} template <class STensor> CUTE_HOST_DEVICE auto partition_S(STensor&& stensor) const { //static_assert(sizeof(typename remove_cvref_t<STensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling SrcTensor.\"); auto thr_tensor = make_tensor(static_cast<STensor&&>(stensor).data(), TiledCopy::tidfrg_S(stensor.layout())); return thr_tensor(thr_idx_, _, repeat<rank_v<STensor>>(_)); } template <class DTensor> CUTE_HOST_DEVICE auto partition_D(DTensor&& dtensor) const { //static_assert(sizeof(typename remove_cvref_t<DTensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling DstTensor.\"); auto thr_tensor = make_tensor(static_cast<DTensor&&>(dtensor).data(), TiledCopy::tidfrg_D(dtensor.layout())); return thr_tensor(thr_idx_, _, repeat<rank_v<DTensor>>(_)); } template <class STensor> CUTE_HOST_DEVICE static auto retile_S(STensor&& stensor) { // static_assert(sizeof(typename remove_cvref_t<STensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling SrcTensor.\"); return make_tensor(static_cast<STensor&&>(stensor).data(), TiledCopy::retile(stensor.layout())); } template <class DTensor> CUTE_HOST_DEVICE static auto retile_D(DTensor&& dtensor) { // static_assert(sizeof(typename remove_cvref_t<DTensor>::value_type) == sizeof(typename TiledCopy::ValType), // \"Expected ValType for tiling DstTensor.\"); return make_tensor(static_cast<DTensor&&>(dtensor).data(), TiledCopy::retile(dtensor.layout())); } };","title":"3. ThrCopy \u6a21\u5757"},{"location":"design/cute/copy/#_1","text":"","title":"\u8f85\u52a9\u51fd\u6570"},{"location":"design/cute/copy/#1","text":"make_tiled_copy() : \u521b\u5efa\u5206\u5757 copy make_tiled_copy_A/B/C() : \u4e3a\u77e9\u9635\u4e58\u6cd5\u521b\u5efa\u7279\u5b9a\u7684 copy make_cotiled_copy() : \u57fa\u4e8e\u504f\u79fb\u6620\u5c04\u521b\u5efa copy","title":"1. \u521b\u5efa\u51fd\u6570"},{"location":"design/cute/copy/#2","text":"copy() : \u4e3b\u8981\u7684 copy \u63a5\u53e3 copy_if() : \u5e26\u6761\u4ef6\u8c13\u8bcd\u7684 copy copy_aligned() : \u5bf9\u9f50\u5047\u8bbe\u7684 copy","title":"2. \u6267\u884c\u51fd\u6570"},{"location":"design/cute/copy/#_2","text":"// ... existing code ... template <class... CopyArgs, class SrcEngine, class SrcLayout, class DstEngine, class DstLayout> CUTE_HOST_DEVICE void copy(Copy_Atom<CopyArgs...> const& copy_atom, Tensor<SrcEngine, SrcLayout> const& src, // (V,Rest...) Tensor<DstEngine, DstLayout> & dst) // (V,Rest...) { static_assert(SrcLayout::rank == DstLayout::rank, \"CopyAtom rank-mismatch.\"); if constexpr (SrcLayout::rank == 1) { // Dispatch the copy copy_atom.call(src, dst); } else { // Loop over all but the first mode constexpr int R = SrcLayout::rank; Tensor src_v = group_modes<1,R>(src); Tensor dst_v = group_modes<1,R>(dst); if constexpr (is_static<decltype(shape(src_v))>::value && is_static<decltype(shape(dst_v))>::value) { CUTE_STATIC_ASSERT_V(size<1>(src_v) == size<1>(dst_v)); // AutoFilter on the Rest-mode auto dst_null = nullspace(layout<1>(dst_v)); Tensor dst_n = zipped_divide(dst_v, make_tile(shape<0>(dst_v), dst_null)); // ((V, NLL), (_1, Rest)) Tensor src_n = zipped_divide(src_v, make_tile(shape<0>(src_v), dst_null)); // ((V, NLL), (_1, Rest)) CUTE_STATIC_ASSERT_V(size<1>(src_n) == size<1>(dst_n)); CUTE_STATIC_ASSERT_V((cosize<0,1>(dst_n.layout()) == Int<1>{}), \"Nullspace definition error\"); CUTE_STATIC_ASSERT_V((cosize<0,1>(src_n.layout()) == Int<1>{}), \"Error: Ambiguous scatter detected in copy\"); CUTE_STATIC_ASSERT_V((size<1,0>(dst_n) == Int<1>{})); CUTE_STATIC_ASSERT_V((size<1,0>(src_n) == Int<1>{})); Tensor dst_c = dst_n(make_coord(_,Int<0>{}),make_coord(Int<0>{},_)); // (V, Rest) Tensor src_c = src_n(make_coord(_,Int<0>{}),make_coord(Int<0>{},_)); // (V, Rest) CUTE_STATIC_ASSERT_V( size<1>(src_c) == size<1>(dst_c)); CUTE_STATIC_ASSERT_V(shape<0>(dst_c) == shape<0>(dst)); CUTE_STATIC_ASSERT_V(shape<0>(src_c) == shape<0>(src)); CUTE_UNROLL for (int i = 0; i < size<1>(dst_c); ++i) { copy_atom.call(src_c(_,i), dst_c(_,i)); } } else { CUTE_UNROLL for (int i = 0; i < size<1>(dst_v); ++i) { copy_atom.call(src_v(_,i), dst_v(_,i)); } } } } // ... existing code ... // ... existing code ... template <class SEngine, class SLayout, class DEngine, class DLayout> CUTE_HOST_DEVICE void call(Tensor<SEngine,SLayout> const& src, Tensor<DEngine,DLayout> & dst) const { static_assert(SLayout::rank == 1, \"Expected rank-1 src tensor\"); static_assert(DLayout::rank == 1, \"Expected rank-1 dst tensor\"); if constexpr (is_constant<NumValSrc, decltype(size(src))>::value || is_constant<NumValDst, decltype(size(dst))>::value) { // Dispatch to unpack to execute instruction return copy_unpack(static_cast<Traits const&>(*this), src, dst); } else if constexpr (is_tuple<decltype(shape(src))>::value && is_tuple<decltype(shape(dst))>::value) { // If the size of the src/dst doesn't match the instruction, // recurse this rank-1 layout by peeling off the mode // ((A,B,C,...)) -> (A,B,C,...) return copy(*this, tensor<0>(src), tensor<0>(dst)); } else { static_assert(dependent_false<SEngine>, \"CopyAtom: Src/Dst partitioning does not match the instruction requirement.\"); } } // ... existing code ...","title":"\u6a21\u5757\u534f\u540c\u5de5\u4f5c\u65b9\u5f0f"},{"location":"design/cute/copy/#_3","text":"CopyAtom \u5c42 : \u5b9a\u4e49\u57fa\u672c\u7684 copy \u64cd\u4f5c\u5355\u5143\uff0c\u5305\u62ec\u7ebf\u7a0b\u5e03\u5c40\u548c\u6570\u636e\u5e03\u5c40 TiledCopy \u5c42 : \u5c06 CopyAtom \u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757\uff0c\u652f\u6301\u591a\u7ebf\u7a0b\u534f\u4f5c ThrCopy \u5c42 : \u4e3a\u6bcf\u4e2a\u7ebf\u7a0b\u63d0\u4f9b\u7279\u5b9a\u7684 copy \u89c6\u56fe \u6267\u884c\u5c42 : \u901a\u8fc7 copy() \u6216 copy_if() \u51fd\u6570\u5b9e\u9645\u6267\u884c copy \u64cd\u4f5c \u8fd9\u4e9b\u6a21\u5757\u901a\u8fc7\u6a21\u677f\u7279\u5316\u548c\u9012\u5f52\u8c03\u7528\u534f\u540c\u5de5\u4f5c\uff0c\u5f62\u6210\u4e86\u4e00\u4e2a\u7075\u6d3b\u4e14\u9ad8\u6548\u7684 copy \u62bd\u8c61\uff0c\u53ef\u4ee5\u9002\u5e94\u4ece\u7b80\u5355\u5bc4\u5b58\u5668\u64cd\u4f5c\u5230\u590d\u6742\u5f20\u91cf\u64cd\u4f5c\u7684\u5404\u79cd\u573a\u666f\u3002 \u6574\u4e2a\u7cfb\u7edf\u901a\u8fc7 traits \u6a21\u5f0f\u5b9e\u73b0\uff0c\u5141\u8bb8\u4e3a\u4e0d\u540c\u7684\u786c\u4ef6\u67b6\u6784\u548c copy \u64cd\u4f5c\u7c7b\u578b\u63d0\u4f9b\u4e13\u95e8\u7684\u5b9e\u73b0\uff0c\u540c\u65f6\u4fdd\u6301\u7edf\u4e00\u7684\u63a5\u53e3\u3002\u8fd9\u79cd\u8bbe\u8ba1\u4f7f\u5f97\u7528\u6237\u53ef\u4ee5\u7528\u76f8\u540c\u7684 API \u5728\u4e0d\u540c\u7684\u786c\u4ef6\u4e0a\u6267\u884c copy \u64cd\u4f5c\uff0c\u800c\u5e95\u5c42\u5b9e\u73b0\u4f1a\u6839\u636e\u5177\u4f53\u7684\u786c\u4ef6\u548c\u6570\u636e\u7c7b\u578b\u81ea\u52a8\u9009\u62e9\u6700\u4f18\u7684\u6267\u884c\u8def\u5f84\u3002","title":"\u5de5\u4f5c\u6d41\u7a0b"},{"location":"design/cute/draft_RefLayout/","text":"\u8ba9\u6211\u89e3\u91ca\u4e00\u4e0b RefLayout \u5728 CUTLASS \u4e2d\u7684\u4f5c\u7528\u3002 RefLayout \u7684\u4f5c\u7528 RefLayout \uff08Reference Layout\uff09\u662f Copy_Traits \u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u6982\u5ff5\uff0c\u7528\u4e8e\u5b9a\u4e49\u590d\u5236\u64cd\u4f5c\u4e2d\u7684\u53c2\u8003\u5e03\u5c40\u3002\u4ece\u4ee3\u7801\u6ce8\u91ca\u4e2d\u53ef\u4ee5\u770b\u51fa\uff1a * concept Copy_Traits * { * using ThrID = // Logical thread id (tid) -> tidx * * using SrcLayout = // (Logical src thread id (tid), Logical src value id (vid)) -> bit * using DstLayout = // (Logical dst thread id (tid), Logical dst value id (vid)) -> bit * using RefLayout = // (Logical ref thread id (tid), Logical ref value id (vid)) -> bit * }; * * The abstract bit ordering of the Copy_Traits (the codomain of SrcLayout, DstLayout, and RefLayout) * is arbitrary and only used to construct maps * (ref-tid,ref-vid) -> (src-tid,src-vid) * (ref-tid,ref-vid) -> (dst-tid,dst-vid) * in TiledCopy. The Layout_TV in TiledCopy is in accordance with the RefLayout of a Traits, then mapped to * the Src or Dst (tid,vid) representation on demand. \u8be6\u7ec6\u89e3\u91ca \u53c2\u8003\u5e03\u5c40\u7684\u4f5c\u7528 \uff1a RefLayout \u662f\u4e00\u4e2a\u53c2\u8003\u5750\u6807\u7cfb\uff0c\u7528\u4e8e\u5728 TiledCopy \u4e2d\u6784\u5efa\u4ece\u53c2\u8003\u5e03\u5c40\u5230\u6e90\u5e03\u5c40\u548c\u76ee\u6807\u5e03\u5c40\u7684\u6620\u5c04\u5173\u7cfb \u5b83\u5b9a\u4e49\u4e86\u7ebf\u7a0b\u548c\u6570\u636e\u503c\u4e4b\u95f4\u7684\u903b\u8f91\u5173\u7cfb\uff0c\u4f5c\u4e3a\u6784\u5efa\u5176\u4ed6\u6620\u5c04\u7684\u57fa\u51c6 \u6620\u5c04\u5173\u7cfb \uff1a TiledCopy \u4f7f\u7528 RefLayout \u6784\u5efa\u4e24\u4e2a\u91cd\u8981\u6620\u5c04\uff1a \u4ece\u53c2\u8003\u5e03\u5c40\u5230\u6e90\u5e03\u5c40\u7684\u6620\u5c04\uff1a (ref-tid,ref-vid) -> (src-tid,src-vid) \u4ece\u53c2\u8003\u5e03\u5c40\u5230\u76ee\u6807\u5e03\u5c40\u7684\u6620\u5c04\uff1a (ref-tid,ref-vid) -> (dst-tid,dst-vid) \u4e3a\u4ec0\u4e48\u9009\u62e9 SrcLayout \u6216 DstLayout \u4f5c\u4e3a RefLayout \uff1a \u8fd9\u4e2a\u9009\u62e9\u662f\u4efb\u610f\u7684\uff0c\u4f46\u5728\u4e0d\u540c\u67b6\u6784\u4e2d\u53ef\u80fd\u57fa\u4e8e\u4f18\u5316\u8003\u8651\u800c\u4e0d\u540c \u5728\u5927\u591a\u6570\u67b6\u6784\uff08\u5982 SM80\uff09\u4e2d\uff0c\u9009\u62e9 SrcLayout \u4f5c\u4e3a\u53c2\u8003\u5e03\u5c40\uff0c\u53ef\u80fd\u662f\u56e0\u4e3a\u6e90\u6570\u636e\u901a\u5e38\u662f\u590d\u5236\u64cd\u4f5c\u7684\u8d77\u70b9 \u5728\u67d0\u4e9b\u67b6\u6784\uff08\u5982 SM100\uff09\u4e2d\uff0c\u9009\u62e9 DstLayout \u4f5c\u4e3a\u53c2\u8003\u5e03\u5c40\uff0c\u53ef\u80fd\u662f\u56e0\u4e3a\u76ee\u6807\u5e03\u5c40\u7684\u8bbf\u95ee\u6a21\u5f0f\u66f4\u9002\u5408\u8be5\u67b6\u6784\u7684\u4f18\u5316 \u5b9e\u9645\u5e94\u7528 \uff1a \u5728\u6784\u9020 TiledCopy \u65f6\uff0c\u7cfb\u7edf\u4f1a\u6839\u636e RefLayout \u6784\u5efa\u76f8\u5e94\u7684\u6620\u5c04\u5173\u7cfb \u8fd9\u4e9b\u6620\u5c04\u5173\u7cfb\u7528\u4e8e\u5728\u5b9e\u9645\u590d\u5236\u64cd\u4f5c\u4e2d\u6b63\u786e\u5730\u5c06\u6570\u636e\u4ece\u6e90\u4f4d\u7f6e\u6620\u5c04\u5230\u76ee\u6807\u4f4d\u7f6e \u603b\u7ed3 RefLayout \u662f\u4e00\u4e2a\u62bd\u8c61\u6982\u5ff5\uff0c\u7528\u4e8e\u7edf\u4e00\u7ba1\u7406\u590d\u5236\u64cd\u4f5c\u4e2d\u7ebf\u7a0b\u548c\u6570\u636e\u503c\u4e4b\u95f4\u7684\u6620\u5c04\u5173\u7cfb\u3002\u5b83\u4f5c\u4e3a\u53c2\u8003\u5750\u6807\u7cfb\uff0c\u5e2e\u52a9\u6784\u5efa\u4ece\u903b\u8f91\u5e03\u5c40\u5230\u5b9e\u9645\u6e90\u548c\u76ee\u6807\u5e03\u5c40\u7684\u8f6c\u6362\u3002\u9009\u62e9\u6e90\u5e03\u5c40\u8fd8\u662f\u76ee\u6807\u5e03\u5c40\u4f5c\u4e3a\u53c2\u8003\u5e03\u5c40\u4e3b\u8981\u53d6\u51b3\u4e8e\u67b6\u6784\u7279\u6027\u548c\u4f18\u5316\u9700\u6c42\uff0c\u4f46\u5bf9\u6700\u7ec8\u529f\u80fd\u6ca1\u6709\u5f71\u54cd\uff0c\u53ea\u662f\u5b9e\u73b0\u65b9\u5f0f\u7684\u4e0d\u540c\u3002","title":"draft RefLayout"},{"location":"design/cute/draft_RefLayout/#reflayout","text":"RefLayout \uff08Reference Layout\uff09\u662f Copy_Traits \u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u6982\u5ff5\uff0c\u7528\u4e8e\u5b9a\u4e49\u590d\u5236\u64cd\u4f5c\u4e2d\u7684\u53c2\u8003\u5e03\u5c40\u3002\u4ece\u4ee3\u7801\u6ce8\u91ca\u4e2d\u53ef\u4ee5\u770b\u51fa\uff1a * concept Copy_Traits * { * using ThrID = // Logical thread id (tid) -> tidx * * using SrcLayout = // (Logical src thread id (tid), Logical src value id (vid)) -> bit * using DstLayout = // (Logical dst thread id (tid), Logical dst value id (vid)) -> bit * using RefLayout = // (Logical ref thread id (tid), Logical ref value id (vid)) -> bit * }; * * The abstract bit ordering of the Copy_Traits (the codomain of SrcLayout, DstLayout, and RefLayout) * is arbitrary and only used to construct maps * (ref-tid,ref-vid) -> (src-tid,src-vid) * (ref-tid,ref-vid) -> (dst-tid,dst-vid) * in TiledCopy. The Layout_TV in TiledCopy is in accordance with the RefLayout of a Traits, then mapped to * the Src or Dst (tid,vid) representation on demand.","title":"RefLayout \u7684\u4f5c\u7528"},{"location":"design/cute/draft_RefLayout/#_1","text":"\u53c2\u8003\u5e03\u5c40\u7684\u4f5c\u7528 \uff1a RefLayout \u662f\u4e00\u4e2a\u53c2\u8003\u5750\u6807\u7cfb\uff0c\u7528\u4e8e\u5728 TiledCopy \u4e2d\u6784\u5efa\u4ece\u53c2\u8003\u5e03\u5c40\u5230\u6e90\u5e03\u5c40\u548c\u76ee\u6807\u5e03\u5c40\u7684\u6620\u5c04\u5173\u7cfb \u5b83\u5b9a\u4e49\u4e86\u7ebf\u7a0b\u548c\u6570\u636e\u503c\u4e4b\u95f4\u7684\u903b\u8f91\u5173\u7cfb\uff0c\u4f5c\u4e3a\u6784\u5efa\u5176\u4ed6\u6620\u5c04\u7684\u57fa\u51c6 \u6620\u5c04\u5173\u7cfb \uff1a TiledCopy \u4f7f\u7528 RefLayout \u6784\u5efa\u4e24\u4e2a\u91cd\u8981\u6620\u5c04\uff1a \u4ece\u53c2\u8003\u5e03\u5c40\u5230\u6e90\u5e03\u5c40\u7684\u6620\u5c04\uff1a (ref-tid,ref-vid) -> (src-tid,src-vid) \u4ece\u53c2\u8003\u5e03\u5c40\u5230\u76ee\u6807\u5e03\u5c40\u7684\u6620\u5c04\uff1a (ref-tid,ref-vid) -> (dst-tid,dst-vid) \u4e3a\u4ec0\u4e48\u9009\u62e9 SrcLayout \u6216 DstLayout \u4f5c\u4e3a RefLayout \uff1a \u8fd9\u4e2a\u9009\u62e9\u662f\u4efb\u610f\u7684\uff0c\u4f46\u5728\u4e0d\u540c\u67b6\u6784\u4e2d\u53ef\u80fd\u57fa\u4e8e\u4f18\u5316\u8003\u8651\u800c\u4e0d\u540c \u5728\u5927\u591a\u6570\u67b6\u6784\uff08\u5982 SM80\uff09\u4e2d\uff0c\u9009\u62e9 SrcLayout \u4f5c\u4e3a\u53c2\u8003\u5e03\u5c40\uff0c\u53ef\u80fd\u662f\u56e0\u4e3a\u6e90\u6570\u636e\u901a\u5e38\u662f\u590d\u5236\u64cd\u4f5c\u7684\u8d77\u70b9 \u5728\u67d0\u4e9b\u67b6\u6784\uff08\u5982 SM100\uff09\u4e2d\uff0c\u9009\u62e9 DstLayout \u4f5c\u4e3a\u53c2\u8003\u5e03\u5c40\uff0c\u53ef\u80fd\u662f\u56e0\u4e3a\u76ee\u6807\u5e03\u5c40\u7684\u8bbf\u95ee\u6a21\u5f0f\u66f4\u9002\u5408\u8be5\u67b6\u6784\u7684\u4f18\u5316 \u5b9e\u9645\u5e94\u7528 \uff1a \u5728\u6784\u9020 TiledCopy \u65f6\uff0c\u7cfb\u7edf\u4f1a\u6839\u636e RefLayout \u6784\u5efa\u76f8\u5e94\u7684\u6620\u5c04\u5173\u7cfb \u8fd9\u4e9b\u6620\u5c04\u5173\u7cfb\u7528\u4e8e\u5728\u5b9e\u9645\u590d\u5236\u64cd\u4f5c\u4e2d\u6b63\u786e\u5730\u5c06\u6570\u636e\u4ece\u6e90\u4f4d\u7f6e\u6620\u5c04\u5230\u76ee\u6807\u4f4d\u7f6e","title":"\u8be6\u7ec6\u89e3\u91ca"},{"location":"design/cute/draft_RefLayout/#_2","text":"RefLayout \u662f\u4e00\u4e2a\u62bd\u8c61\u6982\u5ff5\uff0c\u7528\u4e8e\u7edf\u4e00\u7ba1\u7406\u590d\u5236\u64cd\u4f5c\u4e2d\u7ebf\u7a0b\u548c\u6570\u636e\u503c\u4e4b\u95f4\u7684\u6620\u5c04\u5173\u7cfb\u3002\u5b83\u4f5c\u4e3a\u53c2\u8003\u5750\u6807\u7cfb\uff0c\u5e2e\u52a9\u6784\u5efa\u4ece\u903b\u8f91\u5e03\u5c40\u5230\u5b9e\u9645\u6e90\u548c\u76ee\u6807\u5e03\u5c40\u7684\u8f6c\u6362\u3002\u9009\u62e9\u6e90\u5e03\u5c40\u8fd8\u662f\u76ee\u6807\u5e03\u5c40\u4f5c\u4e3a\u53c2\u8003\u5e03\u5c40\u4e3b\u8981\u53d6\u51b3\u4e8e\u67b6\u6784\u7279\u6027\u548c\u4f18\u5316\u9700\u6c42\uff0c\u4f46\u5bf9\u6700\u7ec8\u529f\u80fd\u6ca1\u6709\u5f71\u54cd\uff0c\u53ea\u662f\u5b9e\u73b0\u65b9\u5f0f\u7684\u4e0d\u540c\u3002","title":"\u603b\u7ed3"},{"location":"design/cute/draft_tiledCopy/","text":"\u6211\u5c06\u4e3a\u60a8\u6574\u7406 copy_atom.hpp \u6e90\u7801\u4e2d\u7684\u6240\u6709\u7c7b\u3001\u63a5\u53e3\u548c\u6210\u5458\u53d8\u91cf\uff0c\u5e76\u89e3\u91ca\u5176\u5b9e\u73b0\u3001\u4f5c\u7528\u3001\u4f7f\u7528\u573a\u666f\u548c\u4f7f\u7528\u65b9\u6cd5\u3002 \u4e3b\u8981\u7c7b\u548c\u7ed3\u6784\u4f53 1. Copy_Atom \u8fd9\u662f\u8868\u793a\u5355\u4e2a\u590d\u5236\u64cd\u4f5c\u7684\u57fa\u672c\u539f\u5b50\u7c7b\u3002 \u6a21\u677f\u53c2\u6570\uff1a - CopyOperation : \u590d\u5236\u64cd\u4f5c\u7c7b\u578b - CopyInternalType : \u590d\u5236\u7684\u6570\u636e\u7c7b\u578b \u6838\u5fc3\u6210\u5458\uff1a - ThrID : \u7ebf\u7a0bID\u5e03\u5c40 - BitLayoutSrc/Dst/Ref : \u6e90\u3001\u76ee\u6807\u548c\u53c2\u8003\u7684\u4f4d\u5e03\u5c40 - ValLayoutSrc/Dst/Ref : \u6e90\u3001\u76ee\u6807\u548c\u53c2\u8003\u7684\u503c\u5e03\u5c40 - ValType : \u503c\u7c7b\u578b \u4f5c\u7528\uff1a - \u8868\u793a\u5355\u4e2a\u590d\u5236\u6307\u4ee4\u7684\u5c01\u88c5 - \u5b9a\u4e49\u590d\u5236\u64cd\u4f5c\u7684\u7ebf\u7a0b\u5e03\u5c40\u548c\u6570\u636e\u5e03\u5c40 \u4f7f\u7528\u573a\u666f\uff1a - \u5f53\u9700\u8981\u6267\u884c\u5355\u4e2a\u590d\u5236\u64cd\u4f5c\u65f6 - \u4f5c\u4e3a\u6784\u5efa\u66f4\u590d\u6742\u590d\u5236\u64cd\u4f5c\u7684\u57fa\u7840 \u4f7f\u7528\u65b9\u6cd5\uff1a Copy_Atom<SM75_U32x4_LDSM_N, float> copy_atom; 2. TiledCopy \u8fd9\u662f\u4e00\u4e2a\u590d\u5236\u64cd\u4f5c\u7684\u5e73\u94fa\u5c01\u88c5\uff0c\u7531\u591a\u4e2a Copy_Atom \u7ec4\u6210\u3002 \u6a21\u677f\u53c2\u6570\uff1a - Copy_Atom : \u57fa\u7840\u590d\u5236\u539f\u5b50 - LayoutCopy_TV : (\u7ebf\u7a0bID, \u503cID) \u5230\u5750\u6807\u7684\u6620\u5c04\u5e03\u5c40 - ShapeTiler_MN : \u5750\u6807\u7a7a\u95f4\u5f62\u72b6 \u6838\u5fc3\u6210\u5458\uff1a - AtomThrID : \u539f\u5b50\u7ebf\u7a0bID\u5e03\u5c40 - AtomLayoutSrc/Dst/Ref : \u539f\u5b50\u6e90\u3001\u76ee\u6807\u548c\u53c2\u8003\u5e03\u5c40 - Tiler_MN : \u5e73\u94fa\u5f62\u72b6 - TiledLayout_TV : \u5e73\u94fa\u7684(\u7ebf\u7a0bID, \u503cID)\u5e03\u5c40 \u4f5c\u7528\uff1a - \u5c06\u590d\u5236\u64cd\u4f5c\u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757 - \u7ba1\u7406\u591a\u4e2a\u7ebf\u7a0b\u5982\u4f55\u534f\u540c\u5b8c\u6210\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u573a\u666f\uff1a - \u5f53\u9700\u8981\u590d\u5236\u8f83\u5927\u7684\u6570\u636e\u5757\u65f6 - \u5728GEMM\u7b49\u64cd\u4f5c\u4e2d\u7ba1\u7406\u6570\u636e\u79fb\u52a8 \u4f7f\u7528\u65b9\u6cd5\uff1a TiledCopy copy = make_tiled_copy(Copy_Atom<SM75_U32x4_LDSM_N, float>{}, Layout<Shape<_32,_8>,Stride<_8,_1>>{}, Layout<Shape<_1,_1>>{}); 3. ThrCopy \u8868\u793a\u7279\u5b9a\u7ebf\u7a0b\u7684\u590d\u5236\u64cd\u4f5c\u89c6\u56fe\u3002 \u6a21\u677f\u53c2\u6570\uff1a - TiledCopy : \u5e73\u94fa\u590d\u5236\u64cd\u4f5c - ThrIdx : \u7ebf\u7a0b\u7d22\u5f15\u7c7b\u578b \u6838\u5fc3\u6210\u5458\uff1a - thr_idx_ : \u7ebf\u7a0b\u7d22\u5f15 \u4f5c\u7528\uff1a - \u4e3a\u7279\u5b9a\u7ebf\u7a0b\u63d0\u4f9b\u590d\u5236\u64cd\u4f5c\u7684\u89c6\u56fe - \u5206\u5272\u6574\u4f53\u590d\u5236\u64cd\u4f5c\u4e3a\u7ebf\u7a0b\u7ea7\u522b\u7684\u64cd\u4f5c \u4f7f\u7528\u573a\u666f\uff1a - \u5728\u6bcf\u4e2a\u7ebf\u7a0b\u4e2d\u83b7\u53d6\u5176\u8d1f\u8d23\u7684\u6570\u636e\u90e8\u5206 - \u5b9e\u73b0\u7ebf\u7a0b\u95f4\u7684\u6570\u636e\u5206\u533a \u4f7f\u7528\u65b9\u6cd5\uff1a auto thr_copy = tiled_copy.get_slice(threadIdx.x); Tensor sA = thr_copy.partition_S(gA); // \u5206\u5272\u6e90\u5f20\u91cf Tensor sB = thr_copy.partition_D(gB); // \u5206\u5272\u76ee\u6807\u5f20\u91cf \u4e3b\u8981\u51fd\u6570\u63a5\u53e3 1. make_tiled_copy_impl \u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u7684\u5b9e\u73b0\u51fd\u6570\u3002 \u53c2\u6570\uff1a - copy_atom : \u590d\u5236\u539f\u5b50 - layout : \u5e03\u5c40\u4fe1\u606f - tiler : \u5e73\u94fa\u5668 \u4f5c\u7528\uff1a - \u6839\u636e\u7ed9\u5b9a\u53c2\u6570\u521b\u5efa TiledCopy \u5b9e\u4f8b 2. make_tiled_copy \u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u7684\u4e3b\u8981\u63a5\u53e3\u3002 \u53c2\u6570\uff1a - copy_atom : \u590d\u5236\u539f\u5b50 - thr_layout : \u7ebf\u7a0b\u5e03\u5c40 - val_layout : \u503c\u5e03\u5c40 \u4f5c\u7528\uff1a - \u6839\u636e\u7ebf\u7a0b\u548c\u503c\u5e03\u5c40\u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u65b9\u6cd5\uff1a auto tiled_copy = make_tiled_copy( Copy_Atom<UniversalCopy<T>, T>{}, Layout<Shape<_32,_8>,Stride<_8,_1>>{}, // \u7ebf\u7a0b\u5e03\u5c40 Layout<Shape<_1,_1>>{} // \u503c\u5e03\u5c40 ); 3. make_tiled_copy_A/B/C \u4e3a\u77e9\u9635\u4e58\u6cd5\u64cd\u4f5c\u521b\u5efa\u7279\u5b9a\u7684\u590d\u5236\u64cd\u4f5c\u3002 \u4f5c\u7528\uff1a - \u521b\u5efa\u4e0e\u77e9\u9635\u4e58\u6cd5A/B/C\u77e9\u9635\u9002\u914d\u7684\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u65b9\u6cd5\uff1a auto copyA = make_tiled_copy_A(Copy_Atom<UniversalCopy<TA>, TA>{}, tiled_mma); auto copyB = make_tiled_copy_B(Copy_Atom<UniversalCopy<TB>, TB>{}, tiled_mma); auto copyC = make_tiled_copy_C(Copy_Atom<UniversalCopy<TC>, TC>{}, tiled_mma); 4. make_tiled_copy_S/D \u521b\u5efa\u4e0e\u6e90\u6216\u76ee\u6807\u5e03\u5c40\u5339\u914d\u7684\u590d\u5236\u64cd\u4f5c\u3002 \u4f5c\u7528\uff1a - \u521b\u5efa\u4e0e\u73b0\u6709\u590d\u5236\u64cd\u4f5c\u7684\u6e90\u6216\u76ee\u6807\u5e03\u5c40\u5339\u914d\u7684\u65b0\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u65b9\u6cd5\uff1a auto copyS = make_tiled_copy_S(Copy_Atom<CopyOp, T>{}, existing_tiled_copy); auto copyD = make_tiled_copy_D(Copy_Atom<CopyOp, T>{}, existing_tiled_copy); 5. make_cotiled_copy \u4ece\u7ebf\u7a0b\u548c\u503c\u7684\u504f\u79fb\u6620\u5c04\u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u3002 \u4f5c\u7528\uff1a - \u5f53\u7ebf\u7a0b\u548c\u503c\u4e0d\u5173\u5fc3\u5177\u4f53\u5750\u6807\uff0c\u800c\u66f4\u5173\u5fc3\u5411\u91cf\u5bbd\u5ea6\u548c\u504f\u79fb\u65f6\u4f7f\u7528 \u6838\u5fc3\u5b9e\u73b0\u673a\u5236 \u5e03\u5c40\u8f6c\u6362\u7cfb\u7edf CUTE \u4f7f\u7528\u5e03\u5c40(layout)\u7cfb\u7edf\u6765\u7ba1\u7406\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff1a ThrID : \u7ebf\u7a0bID\u5230\u7ebf\u7a0b\u7d22\u5f15\u7684\u6620\u5c04 SrcLayout/DstLayout : \u6e90/\u76ee\u6807\u7684(\u7ebf\u7a0b, \u503c)\u5230\u6bd4\u7279\u7684\u6620\u5c04 RefLayout : \u53c2\u8003\u7684(\u7ebf\u7a0b, \u503c)\u5230\u6bd4\u7279\u7684\u6620\u5c04 \u8fd9\u4e9b\u5e03\u5c40\u901a\u8fc7 right_inverse \u548c compose \u7b49\u64cd\u4f5c\u8fdb\u884c\u8f6c\u6362\uff0c\u6784\u5efa\u4ece\u53c2\u8003\u5e03\u5c40\u5230\u6e90\u5e03\u5c40\u548c\u76ee\u6807\u5e03\u5c40\u7684\u6620\u5c04\u3002 \u5206\u533a\u673a\u5236 \u901a\u8fc7 partition_S \u548c partition_D \u65b9\u6cd5\uff0c\u5c06\u6574\u4f53\u5f20\u91cf\u5206\u533a\u4e3a\u7ebf\u7a0b\u7ea7\u522b\u7684\u5b50\u5f20\u91cf\uff1a auto thr_copy = tiled_copy.get_slice(threadIdx.x); Tensor sA = thr_copy.partition_S(gA); // \u6e90\u5f20\u91cf\u5206\u533a Tensor sB = thr_copy.partition_D(gB); // \u76ee\u6807\u5f20\u91cf\u5206\u533a \u6267\u884c\u673a\u5236 \u901a\u8fc7 copy \u51fd\u6570\u6267\u884c\u5b9e\u9645\u7684\u590d\u5236\u64cd\u4f5c\uff1a copy(tiled_copy, sA, sB); // \u4f7f\u7528\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u590d\u5236\u6570\u636e \u4f7f\u7528\u793a\u4f8b // 1. \u521b\u5efa\u590d\u5236\u539f\u5b50 using CopyAtom = Copy_Atom<SM75_U32x4_LDSM_N, float>; // 2. \u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c auto tiled_copy = make_tiled_copy( CopyAtom{}, Layout<Shape<_32,_8>,Stride<_8,_1>>{}, // 32x8\u7ebf\u7a0b\u5e03\u5c40 Layout<Shape<_1,_1>>{} // 1x1\u503c\u5e03\u5c40 ); // 3. \u83b7\u53d6\u7ebf\u7a0b\u89c6\u56fe auto thr_copy = tiled_copy.get_slice(threadIdx.x); // 4. \u5206\u533a\u5f20\u91cf Tensor sA = thr_copy.partition_S(gA); // \u5206\u533a\u6e90\u5f20\u91cf Tensor sB = thr_copy.partition_D(gB); // \u5206\u533a\u76ee\u6807\u5f20\u91cf // 5. \u6267\u884c\u590d\u5236 copy(tiled_copy, sA, sB); \u603b\u7ed3 CUTE \u7684\u590d\u5236\u7cfb\u7edf\u901a\u8fc7 Copy_Atom\u3001TiledCopy \u548c ThrCopy \u4e09\u4e2a\u5c42\u6b21\u63d0\u4f9b\u4e86\u7075\u6d3b\u800c\u5f3a\u5927\u7684\u590d\u5236\u64cd\u4f5c\u62bd\u8c61\uff1a Copy_Atom : \u8868\u793a\u5355\u4e2a\u590d\u5236\u6307\u4ee4 TiledCopy : \u5c06\u590d\u5236\u64cd\u4f5c\u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757 ThrCopy : \u4e3a\u6bcf\u4e2a\u7ebf\u7a0b\u63d0\u4f9b\u5176\u89c6\u56fe \u8fd9\u79cd\u8bbe\u8ba1\u4f7f\u5f97 CUDA \u5185\u6838\u53ef\u4ee5\u9ad8\u6548\u5730\u7ba1\u7406\u590d\u6742\u7684\u6570\u636e\u79fb\u52a8\u6a21\u5f0f\uff0c\u7279\u522b\u9002\u7528\u4e8e GEMM \u7b49\u9700\u8981\u5927\u91cf\u6570\u636e\u642c\u8fd0\u7684\u8ba1\u7b97\u64cd\u4f5c\u3002","title":"draft"},{"location":"design/cute/draft_tiledCopy/#_1","text":"","title":"\u4e3b\u8981\u7c7b\u548c\u7ed3\u6784\u4f53"},{"location":"design/cute/draft_tiledCopy/#1-copy_atom","text":"\u8fd9\u662f\u8868\u793a\u5355\u4e2a\u590d\u5236\u64cd\u4f5c\u7684\u57fa\u672c\u539f\u5b50\u7c7b\u3002 \u6a21\u677f\u53c2\u6570\uff1a - CopyOperation : \u590d\u5236\u64cd\u4f5c\u7c7b\u578b - CopyInternalType : \u590d\u5236\u7684\u6570\u636e\u7c7b\u578b \u6838\u5fc3\u6210\u5458\uff1a - ThrID : \u7ebf\u7a0bID\u5e03\u5c40 - BitLayoutSrc/Dst/Ref : \u6e90\u3001\u76ee\u6807\u548c\u53c2\u8003\u7684\u4f4d\u5e03\u5c40 - ValLayoutSrc/Dst/Ref : \u6e90\u3001\u76ee\u6807\u548c\u53c2\u8003\u7684\u503c\u5e03\u5c40 - ValType : \u503c\u7c7b\u578b \u4f5c\u7528\uff1a - \u8868\u793a\u5355\u4e2a\u590d\u5236\u6307\u4ee4\u7684\u5c01\u88c5 - \u5b9a\u4e49\u590d\u5236\u64cd\u4f5c\u7684\u7ebf\u7a0b\u5e03\u5c40\u548c\u6570\u636e\u5e03\u5c40 \u4f7f\u7528\u573a\u666f\uff1a - \u5f53\u9700\u8981\u6267\u884c\u5355\u4e2a\u590d\u5236\u64cd\u4f5c\u65f6 - \u4f5c\u4e3a\u6784\u5efa\u66f4\u590d\u6742\u590d\u5236\u64cd\u4f5c\u7684\u57fa\u7840 \u4f7f\u7528\u65b9\u6cd5\uff1a Copy_Atom<SM75_U32x4_LDSM_N, float> copy_atom;","title":"1. Copy_Atom"},{"location":"design/cute/draft_tiledCopy/#2-tiledcopy","text":"\u8fd9\u662f\u4e00\u4e2a\u590d\u5236\u64cd\u4f5c\u7684\u5e73\u94fa\u5c01\u88c5\uff0c\u7531\u591a\u4e2a Copy_Atom \u7ec4\u6210\u3002 \u6a21\u677f\u53c2\u6570\uff1a - Copy_Atom : \u57fa\u7840\u590d\u5236\u539f\u5b50 - LayoutCopy_TV : (\u7ebf\u7a0bID, \u503cID) \u5230\u5750\u6807\u7684\u6620\u5c04\u5e03\u5c40 - ShapeTiler_MN : \u5750\u6807\u7a7a\u95f4\u5f62\u72b6 \u6838\u5fc3\u6210\u5458\uff1a - AtomThrID : \u539f\u5b50\u7ebf\u7a0bID\u5e03\u5c40 - AtomLayoutSrc/Dst/Ref : \u539f\u5b50\u6e90\u3001\u76ee\u6807\u548c\u53c2\u8003\u5e03\u5c40 - Tiler_MN : \u5e73\u94fa\u5f62\u72b6 - TiledLayout_TV : \u5e73\u94fa\u7684(\u7ebf\u7a0bID, \u503cID)\u5e03\u5c40 \u4f5c\u7528\uff1a - \u5c06\u590d\u5236\u64cd\u4f5c\u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757 - \u7ba1\u7406\u591a\u4e2a\u7ebf\u7a0b\u5982\u4f55\u534f\u540c\u5b8c\u6210\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u573a\u666f\uff1a - \u5f53\u9700\u8981\u590d\u5236\u8f83\u5927\u7684\u6570\u636e\u5757\u65f6 - \u5728GEMM\u7b49\u64cd\u4f5c\u4e2d\u7ba1\u7406\u6570\u636e\u79fb\u52a8 \u4f7f\u7528\u65b9\u6cd5\uff1a TiledCopy copy = make_tiled_copy(Copy_Atom<SM75_U32x4_LDSM_N, float>{}, Layout<Shape<_32,_8>,Stride<_8,_1>>{}, Layout<Shape<_1,_1>>{});","title":"2. TiledCopy"},{"location":"design/cute/draft_tiledCopy/#3-thrcopy","text":"\u8868\u793a\u7279\u5b9a\u7ebf\u7a0b\u7684\u590d\u5236\u64cd\u4f5c\u89c6\u56fe\u3002 \u6a21\u677f\u53c2\u6570\uff1a - TiledCopy : \u5e73\u94fa\u590d\u5236\u64cd\u4f5c - ThrIdx : \u7ebf\u7a0b\u7d22\u5f15\u7c7b\u578b \u6838\u5fc3\u6210\u5458\uff1a - thr_idx_ : \u7ebf\u7a0b\u7d22\u5f15 \u4f5c\u7528\uff1a - \u4e3a\u7279\u5b9a\u7ebf\u7a0b\u63d0\u4f9b\u590d\u5236\u64cd\u4f5c\u7684\u89c6\u56fe - \u5206\u5272\u6574\u4f53\u590d\u5236\u64cd\u4f5c\u4e3a\u7ebf\u7a0b\u7ea7\u522b\u7684\u64cd\u4f5c \u4f7f\u7528\u573a\u666f\uff1a - \u5728\u6bcf\u4e2a\u7ebf\u7a0b\u4e2d\u83b7\u53d6\u5176\u8d1f\u8d23\u7684\u6570\u636e\u90e8\u5206 - \u5b9e\u73b0\u7ebf\u7a0b\u95f4\u7684\u6570\u636e\u5206\u533a \u4f7f\u7528\u65b9\u6cd5\uff1a auto thr_copy = tiled_copy.get_slice(threadIdx.x); Tensor sA = thr_copy.partition_S(gA); // \u5206\u5272\u6e90\u5f20\u91cf Tensor sB = thr_copy.partition_D(gB); // \u5206\u5272\u76ee\u6807\u5f20\u91cf","title":"3. ThrCopy"},{"location":"design/cute/draft_tiledCopy/#_2","text":"","title":"\u4e3b\u8981\u51fd\u6570\u63a5\u53e3"},{"location":"design/cute/draft_tiledCopy/#1-make_tiled_copy_impl","text":"\u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u7684\u5b9e\u73b0\u51fd\u6570\u3002 \u53c2\u6570\uff1a - copy_atom : \u590d\u5236\u539f\u5b50 - layout : \u5e03\u5c40\u4fe1\u606f - tiler : \u5e73\u94fa\u5668 \u4f5c\u7528\uff1a - \u6839\u636e\u7ed9\u5b9a\u53c2\u6570\u521b\u5efa TiledCopy \u5b9e\u4f8b","title":"1. make_tiled_copy_impl"},{"location":"design/cute/draft_tiledCopy/#2-make_tiled_copy","text":"\u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u7684\u4e3b\u8981\u63a5\u53e3\u3002 \u53c2\u6570\uff1a - copy_atom : \u590d\u5236\u539f\u5b50 - thr_layout : \u7ebf\u7a0b\u5e03\u5c40 - val_layout : \u503c\u5e03\u5c40 \u4f5c\u7528\uff1a - \u6839\u636e\u7ebf\u7a0b\u548c\u503c\u5e03\u5c40\u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u65b9\u6cd5\uff1a auto tiled_copy = make_tiled_copy( Copy_Atom<UniversalCopy<T>, T>{}, Layout<Shape<_32,_8>,Stride<_8,_1>>{}, // \u7ebf\u7a0b\u5e03\u5c40 Layout<Shape<_1,_1>>{} // \u503c\u5e03\u5c40 );","title":"2. make_tiled_copy"},{"location":"design/cute/draft_tiledCopy/#3-make_tiled_copy_abc","text":"\u4e3a\u77e9\u9635\u4e58\u6cd5\u64cd\u4f5c\u521b\u5efa\u7279\u5b9a\u7684\u590d\u5236\u64cd\u4f5c\u3002 \u4f5c\u7528\uff1a - \u521b\u5efa\u4e0e\u77e9\u9635\u4e58\u6cd5A/B/C\u77e9\u9635\u9002\u914d\u7684\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u65b9\u6cd5\uff1a auto copyA = make_tiled_copy_A(Copy_Atom<UniversalCopy<TA>, TA>{}, tiled_mma); auto copyB = make_tiled_copy_B(Copy_Atom<UniversalCopy<TB>, TB>{}, tiled_mma); auto copyC = make_tiled_copy_C(Copy_Atom<UniversalCopy<TC>, TC>{}, tiled_mma);","title":"3. make_tiled_copy_A/B/C"},{"location":"design/cute/draft_tiledCopy/#4-make_tiled_copy_sd","text":"\u521b\u5efa\u4e0e\u6e90\u6216\u76ee\u6807\u5e03\u5c40\u5339\u914d\u7684\u590d\u5236\u64cd\u4f5c\u3002 \u4f5c\u7528\uff1a - \u521b\u5efa\u4e0e\u73b0\u6709\u590d\u5236\u64cd\u4f5c\u7684\u6e90\u6216\u76ee\u6807\u5e03\u5c40\u5339\u914d\u7684\u65b0\u590d\u5236\u64cd\u4f5c \u4f7f\u7528\u65b9\u6cd5\uff1a auto copyS = make_tiled_copy_S(Copy_Atom<CopyOp, T>{}, existing_tiled_copy); auto copyD = make_tiled_copy_D(Copy_Atom<CopyOp, T>{}, existing_tiled_copy);","title":"4. make_tiled_copy_S/D"},{"location":"design/cute/draft_tiledCopy/#5-make_cotiled_copy","text":"\u4ece\u7ebf\u7a0b\u548c\u503c\u7684\u504f\u79fb\u6620\u5c04\u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u3002 \u4f5c\u7528\uff1a - \u5f53\u7ebf\u7a0b\u548c\u503c\u4e0d\u5173\u5fc3\u5177\u4f53\u5750\u6807\uff0c\u800c\u66f4\u5173\u5fc3\u5411\u91cf\u5bbd\u5ea6\u548c\u504f\u79fb\u65f6\u4f7f\u7528","title":"5. make_cotiled_copy"},{"location":"design/cute/draft_tiledCopy/#_3","text":"","title":"\u6838\u5fc3\u5b9e\u73b0\u673a\u5236"},{"location":"design/cute/draft_tiledCopy/#_4","text":"CUTE \u4f7f\u7528\u5e03\u5c40(layout)\u7cfb\u7edf\u6765\u7ba1\u7406\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff1a ThrID : \u7ebf\u7a0bID\u5230\u7ebf\u7a0b\u7d22\u5f15\u7684\u6620\u5c04 SrcLayout/DstLayout : \u6e90/\u76ee\u6807\u7684(\u7ebf\u7a0b, \u503c)\u5230\u6bd4\u7279\u7684\u6620\u5c04 RefLayout : \u53c2\u8003\u7684(\u7ebf\u7a0b, \u503c)\u5230\u6bd4\u7279\u7684\u6620\u5c04 \u8fd9\u4e9b\u5e03\u5c40\u901a\u8fc7 right_inverse \u548c compose \u7b49\u64cd\u4f5c\u8fdb\u884c\u8f6c\u6362\uff0c\u6784\u5efa\u4ece\u53c2\u8003\u5e03\u5c40\u5230\u6e90\u5e03\u5c40\u548c\u76ee\u6807\u5e03\u5c40\u7684\u6620\u5c04\u3002","title":"\u5e03\u5c40\u8f6c\u6362\u7cfb\u7edf"},{"location":"design/cute/draft_tiledCopy/#_5","text":"\u901a\u8fc7 partition_S \u548c partition_D \u65b9\u6cd5\uff0c\u5c06\u6574\u4f53\u5f20\u91cf\u5206\u533a\u4e3a\u7ebf\u7a0b\u7ea7\u522b\u7684\u5b50\u5f20\u91cf\uff1a auto thr_copy = tiled_copy.get_slice(threadIdx.x); Tensor sA = thr_copy.partition_S(gA); // \u6e90\u5f20\u91cf\u5206\u533a Tensor sB = thr_copy.partition_D(gB); // \u76ee\u6807\u5f20\u91cf\u5206\u533a","title":"\u5206\u533a\u673a\u5236"},{"location":"design/cute/draft_tiledCopy/#_6","text":"\u901a\u8fc7 copy \u51fd\u6570\u6267\u884c\u5b9e\u9645\u7684\u590d\u5236\u64cd\u4f5c\uff1a copy(tiled_copy, sA, sB); // \u4f7f\u7528\u5e73\u94fa\u590d\u5236\u64cd\u4f5c\u590d\u5236\u6570\u636e","title":"\u6267\u884c\u673a\u5236"},{"location":"design/cute/draft_tiledCopy/#_7","text":"// 1. \u521b\u5efa\u590d\u5236\u539f\u5b50 using CopyAtom = Copy_Atom<SM75_U32x4_LDSM_N, float>; // 2. \u521b\u5efa\u5e73\u94fa\u590d\u5236\u64cd\u4f5c auto tiled_copy = make_tiled_copy( CopyAtom{}, Layout<Shape<_32,_8>,Stride<_8,_1>>{}, // 32x8\u7ebf\u7a0b\u5e03\u5c40 Layout<Shape<_1,_1>>{} // 1x1\u503c\u5e03\u5c40 ); // 3. \u83b7\u53d6\u7ebf\u7a0b\u89c6\u56fe auto thr_copy = tiled_copy.get_slice(threadIdx.x); // 4. \u5206\u533a\u5f20\u91cf Tensor sA = thr_copy.partition_S(gA); // \u5206\u533a\u6e90\u5f20\u91cf Tensor sB = thr_copy.partition_D(gB); // \u5206\u533a\u76ee\u6807\u5f20\u91cf // 5. \u6267\u884c\u590d\u5236 copy(tiled_copy, sA, sB);","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"design/cute/draft_tiledCopy/#_8","text":"CUTE \u7684\u590d\u5236\u7cfb\u7edf\u901a\u8fc7 Copy_Atom\u3001TiledCopy \u548c ThrCopy \u4e09\u4e2a\u5c42\u6b21\u63d0\u4f9b\u4e86\u7075\u6d3b\u800c\u5f3a\u5927\u7684\u590d\u5236\u64cd\u4f5c\u62bd\u8c61\uff1a Copy_Atom : \u8868\u793a\u5355\u4e2a\u590d\u5236\u6307\u4ee4 TiledCopy : \u5c06\u590d\u5236\u64cd\u4f5c\u6269\u5c55\u5230\u66f4\u5927\u7684\u6570\u636e\u5757 ThrCopy : \u4e3a\u6bcf\u4e2a\u7ebf\u7a0b\u63d0\u4f9b\u5176\u89c6\u56fe \u8fd9\u79cd\u8bbe\u8ba1\u4f7f\u5f97 CUDA \u5185\u6838\u53ef\u4ee5\u9ad8\u6548\u5730\u7ba1\u7406\u590d\u6742\u7684\u6570\u636e\u79fb\u52a8\u6a21\u5f0f\uff0c\u7279\u522b\u9002\u7528\u4e8e GEMM \u7b49\u9700\u8981\u5927\u91cf\u6570\u636e\u642c\u8fd0\u7684\u8ba1\u7b97\u64cd\u4f5c\u3002","title":"\u603b\u7ed3"}]}