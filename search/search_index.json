{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CUTLASS \u5b66\u4e60\u7b14\u8bb0 \u6b22\u8fce\u6765\u5230 CUTLASS \u5b66\u4e60\u7b14\u8bb0\uff01\u672c\u7cfb\u5217\u6587\u6863\u65e8\u5728\u5e2e\u52a9\u5f00\u53d1\u8005\u6df1\u5165\u7406\u89e3 CUTLASS \u548c CuTe \u5e93\u7684\u6838\u5fc3\u6982\u5ff5\u548c\u4f7f\u7528\u65b9\u6cd5\u3002 \u4ec0\u4e48\u662f CUTLASS\uff1f CUTLASS (CUDA Templates for Linear Algebra Subroutines) \u662f NVIDIA \u5f00\u53d1\u7684\u4e00\u4e2a CUDA C++ \u6a21\u677f\u5e93\uff0c\u7528\u4e8e\u5b9e\u73b0\u9ad8\u6027\u80fd\u7684\u7ebf\u6027\u4ee3\u6570\u8ba1\u7b97\uff0c\u7279\u522b\u662f\u77e9\u9635\u4e58\u6cd5\u64cd\u4f5c\u3002\u5b83\u5e7f\u6cdb\u5e94\u7528\u4e8e\u6df1\u5ea6\u5b66\u4e60\u6846\u67b6\u548c\u9ad8\u6027\u80fd\u8ba1\u7b97\u9886\u57df\u3002 CUTLASS \u7684\u7279\u70b9 \u9ad8\u6027\u80fd \uff1a\u5145\u5206\u5229\u7528 NVIDIA GPU \u7684\u786c\u4ef6\u7279\u6027\uff0c\u5305\u62ec Tensor Cores \u53ef\u6269\u5c55\u6027 \uff1a\u652f\u6301\u4ece\u6d88\u8d39\u7ea7 GPU \u5230\u6570\u636e\u4e2d\u5fc3\u7ea7 GPU \u7684\u5404\u79cd\u786c\u4ef6\u5e73\u53f0 \u6a21\u5757\u5316\u8bbe\u8ba1 \uff1a\u63d0\u4f9b\u53ef\u7ec4\u5408\u7684\u7ec4\u4ef6\uff0c\u4fbf\u4e8e\u5b9a\u5236\u548c\u6269\u5c55 \u5f00\u6e90 \uff1a\u5b8c\u5168\u5f00\u6e90\uff0c\u793e\u533a\u9a71\u52a8\u5f00\u53d1 \u4ec0\u4e48\u662f CuTe\uff1f CuTe (CUDA Template Engine) \u662f CUTLASS 3.0 \u5f15\u5165\u7684\u6838\u5fc3\u7ec4\u4ef6\uff0c\u662f\u4e00\u4e2a\u7528\u4e8e\u5728\u7f16\u8bd1\u65f6\u64cd\u4f5c\u5f20\u91cf\u7684 C++ \u6a21\u677f\u5e93\u3002\u5b83\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u62bd\u8c61\u80fd\u529b\uff0c\u4f7f\u5f97\u5f00\u53d1\u8005\u80fd\u591f\u7f16\u5199\u9ad8\u6027\u80fd\u3001\u53ef\u7ef4\u62a4\u7684 CUDA \u4ee3\u7801\u3002 CuTe \u7684\u6838\u5fc3\u6982\u5ff5 Layout \uff1a\u63cf\u8ff0\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb Tensor \uff1a\u7ed3\u5408\u6570\u636e\u6307\u9488\u548c Layout \u7684\u591a\u7ef4\u6570\u636e\u7ed3\u6784 Copy \uff1a\u5b9e\u73b0\u9ad8\u6548\u7684\u6570\u636e\u590d\u5236\u64cd\u4f5c MMA \uff1a\u5b9e\u73b0\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c \u6587\u6863\u7ed3\u6784 \u672c\u7cfb\u5217\u6587\u6863\u6309\u7167\u4ee5\u4e0b\u7ed3\u6784\u7ec4\u7ec7\uff1a \u6838\u5fc3\u6982\u5ff5 CuTe \u6838\u5fc3\u6982\u5ff5 \uff1a\u4ecb\u7ecd CuTe \u7684\u57fa\u672c\u6982\u5ff5\u548c\u6570\u636e\u7c7b\u578b Layout \u5e03\u5c40\u7cfb\u7edf \uff1a\u8be6\u7ec6\u89e3\u91ca Layout \u7684\u5de5\u4f5c\u673a\u5236\u548c\u4f7f\u7528\u65b9\u6cd5 Tensor \u5f20\u91cf\u64cd\u4f5c \uff1a\u4ecb\u7ecd Tensor \u7684\u521b\u5efa\u548c\u64cd\u4f5c\u65b9\u6cd5 \u6838\u5fc3\u64cd\u4f5c Copy \u64cd\u4f5c\u8be6\u89e3 \uff1a\u6df1\u5165\u63a2\u8ba8 Copy \u64cd\u4f5c\u7684\u5b9e\u73b0\u548c\u4f18\u5316 TMA Copy \u64cd\u4f5c \uff1a\u4e13\u95e8\u4ecb\u7ecd Hopper \u67b6\u6784\u7684 TMA \u64cd\u4f5c MMA \u64cd\u4f5c \uff1a\u8be6\u7ec6\u89e3\u6790\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c\u7684\u5b9e\u73b0 GMMA(SM90)\u64cd\u4f5c \uff1a\u4e13\u95e8\u4ecb\u7ecd Hopper \u67b6\u6784\u7684 GMMA \u64cd\u4f5c \u5b9e\u8df5\u5e94\u7528 \u5b9e\u9645\u5e94\u7528\u793a\u4f8b \uff1a\u901a\u8fc7\u5177\u4f53\u793a\u4f8b\u5c55\u793a\u5982\u4f55\u4f7f\u7528 CuTe \u6784\u5efa\u9ad8\u6027\u80fd CUDA \u7a0b\u5e8f \u5b66\u4e60\u5efa\u8bae \u4e3a\u4e86\u66f4\u597d\u5730\u7406\u89e3\u548c\u638c\u63e1 CUTLASS \u548c CuTe\uff0c\u5efa\u8bae\u6309\u7167\u4ee5\u4e0b\u987a\u5e8f\u5b66\u4e60\uff1a 1. \u7406\u89e3\u57fa\u7840\u6982\u5ff5 \u9996\u5148\u719f\u6089 CuTe \u7684\u6838\u5fc3\u6982\u5ff5\uff0c\u5305\u62ec Layout\u3001Tensor \u7b49\u57fa\u672c\u6570\u636e\u7ed3\u6784\u3002 2. \u638c\u63e1\u57fa\u672c\u64cd\u4f5c \u5b66\u4e60 Copy \u548c MMA \u64cd\u4f5c\u7684\u57fa\u672c\u7528\u6cd5\uff0c\u7406\u89e3\u5b83\u4eec\u5982\u4f55\u4e0e Layout \u548c Tensor \u534f\u540c\u5de5\u4f5c\u3002 3. \u5b9e\u8df5\u5e94\u7528 \u901a\u8fc7\u5b9e\u9645\u793a\u4f8b\u52a0\u6df1\u7406\u89e3\uff0c\u5c1d\u8bd5\u6784\u5efa\u81ea\u5df1\u7684\u9ad8\u6027\u80fd CUDA \u7a0b\u5e8f\u3002 4. \u6df1\u5165\u4f18\u5316 \u6df1\u5165\u4e86\u89e3\u5404\u79cd\u4f18\u5316\u6280\u672f\uff0c\u5305\u62ec\u5185\u5b58\u5e03\u5c40\u4f18\u5316\u3001\u7ebf\u7a0b\u534f\u4f5c\u4f18\u5316\u7b49\u3002 \u76f8\u5173\u8d44\u6e90 \u4ee5\u4e0b\u662f\u4e00\u4e9b\u6709\u7528\u7684\u5b66\u4e60\u8d44\u6e90\uff1a CUTLASS GitHub \u4ed3\u5e93 \uff1a\u5b98\u65b9\u6e90\u4ee3\u7801\u548c\u6587\u6863 CUTLASS Documentation \uff1a\u5b98\u65b9\u6587\u6863 CUDA Programming Guide \uff1aCUDA \u7f16\u7a0b\u6307\u5357 NVIDIA Developer Blog \uff1aNVIDIA \u5f00\u53d1\u8005\u535a\u5ba2 \u8d21\u732e\u4e0e\u53cd\u9988 \u5982\u679c\u60a8\u5728\u5b66\u4e60\u8fc7\u7a0b\u4e2d\u53d1\u73b0\u4efb\u4f55\u95ee\u9898\u6216\u6709\u6539\u8fdb\u5efa\u8bae\uff0c\u6b22\u8fce\u63d0\u4ea4 issue \u6216 pull request\u3002\u60a8\u7684\u8d21\u732e\u5c06\u5e2e\u52a9\u6211\u4eec\u4e0d\u65ad\u5b8c\u5584\u8fd9\u4e9b\u5b66\u4e60\u8d44\u6599\uff0c\u5e2e\u52a9\u66f4\u591a\u5f00\u53d1\u8005\u638c\u63e1 CUTLASS \u548c CuTe\u3002 \u8ba9\u6211\u4eec\u5f00\u59cb\u8fd9\u6bb5 CUTLASS \u548c CuTe \u7684\u5b66\u4e60\u4e4b\u65c5\u5427\uff01","title":"Home"},{"location":"#cutlass","text":"\u6b22\u8fce\u6765\u5230 CUTLASS \u5b66\u4e60\u7b14\u8bb0\uff01\u672c\u7cfb\u5217\u6587\u6863\u65e8\u5728\u5e2e\u52a9\u5f00\u53d1\u8005\u6df1\u5165\u7406\u89e3 CUTLASS \u548c CuTe \u5e93\u7684\u6838\u5fc3\u6982\u5ff5\u548c\u4f7f\u7528\u65b9\u6cd5\u3002","title":"CUTLASS \u5b66\u4e60\u7b14\u8bb0"},{"location":"#cutlass_1","text":"CUTLASS (CUDA Templates for Linear Algebra Subroutines) \u662f NVIDIA \u5f00\u53d1\u7684\u4e00\u4e2a CUDA C++ \u6a21\u677f\u5e93\uff0c\u7528\u4e8e\u5b9e\u73b0\u9ad8\u6027\u80fd\u7684\u7ebf\u6027\u4ee3\u6570\u8ba1\u7b97\uff0c\u7279\u522b\u662f\u77e9\u9635\u4e58\u6cd5\u64cd\u4f5c\u3002\u5b83\u5e7f\u6cdb\u5e94\u7528\u4e8e\u6df1\u5ea6\u5b66\u4e60\u6846\u67b6\u548c\u9ad8\u6027\u80fd\u8ba1\u7b97\u9886\u57df\u3002","title":"\u4ec0\u4e48\u662f CUTLASS\uff1f"},{"location":"#cutlass_2","text":"\u9ad8\u6027\u80fd \uff1a\u5145\u5206\u5229\u7528 NVIDIA GPU \u7684\u786c\u4ef6\u7279\u6027\uff0c\u5305\u62ec Tensor Cores \u53ef\u6269\u5c55\u6027 \uff1a\u652f\u6301\u4ece\u6d88\u8d39\u7ea7 GPU \u5230\u6570\u636e\u4e2d\u5fc3\u7ea7 GPU \u7684\u5404\u79cd\u786c\u4ef6\u5e73\u53f0 \u6a21\u5757\u5316\u8bbe\u8ba1 \uff1a\u63d0\u4f9b\u53ef\u7ec4\u5408\u7684\u7ec4\u4ef6\uff0c\u4fbf\u4e8e\u5b9a\u5236\u548c\u6269\u5c55 \u5f00\u6e90 \uff1a\u5b8c\u5168\u5f00\u6e90\uff0c\u793e\u533a\u9a71\u52a8\u5f00\u53d1","title":"CUTLASS \u7684\u7279\u70b9"},{"location":"#cute","text":"CuTe (CUDA Template Engine) \u662f CUTLASS 3.0 \u5f15\u5165\u7684\u6838\u5fc3\u7ec4\u4ef6\uff0c\u662f\u4e00\u4e2a\u7528\u4e8e\u5728\u7f16\u8bd1\u65f6\u64cd\u4f5c\u5f20\u91cf\u7684 C++ \u6a21\u677f\u5e93\u3002\u5b83\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u62bd\u8c61\u80fd\u529b\uff0c\u4f7f\u5f97\u5f00\u53d1\u8005\u80fd\u591f\u7f16\u5199\u9ad8\u6027\u80fd\u3001\u53ef\u7ef4\u62a4\u7684 CUDA \u4ee3\u7801\u3002","title":"\u4ec0\u4e48\u662f CuTe\uff1f"},{"location":"#cute_1","text":"Layout \uff1a\u63cf\u8ff0\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb Tensor \uff1a\u7ed3\u5408\u6570\u636e\u6307\u9488\u548c Layout \u7684\u591a\u7ef4\u6570\u636e\u7ed3\u6784 Copy \uff1a\u5b9e\u73b0\u9ad8\u6548\u7684\u6570\u636e\u590d\u5236\u64cd\u4f5c MMA \uff1a\u5b9e\u73b0\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c","title":"CuTe \u7684\u6838\u5fc3\u6982\u5ff5"},{"location":"#_1","text":"\u672c\u7cfb\u5217\u6587\u6863\u6309\u7167\u4ee5\u4e0b\u7ed3\u6784\u7ec4\u7ec7\uff1a","title":"\u6587\u6863\u7ed3\u6784"},{"location":"#_2","text":"CuTe \u6838\u5fc3\u6982\u5ff5 \uff1a\u4ecb\u7ecd CuTe \u7684\u57fa\u672c\u6982\u5ff5\u548c\u6570\u636e\u7c7b\u578b Layout \u5e03\u5c40\u7cfb\u7edf \uff1a\u8be6\u7ec6\u89e3\u91ca Layout \u7684\u5de5\u4f5c\u673a\u5236\u548c\u4f7f\u7528\u65b9\u6cd5 Tensor \u5f20\u91cf\u64cd\u4f5c \uff1a\u4ecb\u7ecd Tensor \u7684\u521b\u5efa\u548c\u64cd\u4f5c\u65b9\u6cd5","title":"\u6838\u5fc3\u6982\u5ff5"},{"location":"#_3","text":"Copy \u64cd\u4f5c\u8be6\u89e3 \uff1a\u6df1\u5165\u63a2\u8ba8 Copy \u64cd\u4f5c\u7684\u5b9e\u73b0\u548c\u4f18\u5316 TMA Copy \u64cd\u4f5c \uff1a\u4e13\u95e8\u4ecb\u7ecd Hopper \u67b6\u6784\u7684 TMA \u64cd\u4f5c MMA \u64cd\u4f5c \uff1a\u8be6\u7ec6\u89e3\u6790\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c\u7684\u5b9e\u73b0 GMMA(SM90)\u64cd\u4f5c \uff1a\u4e13\u95e8\u4ecb\u7ecd Hopper \u67b6\u6784\u7684 GMMA \u64cd\u4f5c","title":"\u6838\u5fc3\u64cd\u4f5c"},{"location":"#_4","text":"\u5b9e\u9645\u5e94\u7528\u793a\u4f8b \uff1a\u901a\u8fc7\u5177\u4f53\u793a\u4f8b\u5c55\u793a\u5982\u4f55\u4f7f\u7528 CuTe \u6784\u5efa\u9ad8\u6027\u80fd CUDA \u7a0b\u5e8f","title":"\u5b9e\u8df5\u5e94\u7528"},{"location":"#_5","text":"\u4e3a\u4e86\u66f4\u597d\u5730\u7406\u89e3\u548c\u638c\u63e1 CUTLASS \u548c CuTe\uff0c\u5efa\u8bae\u6309\u7167\u4ee5\u4e0b\u987a\u5e8f\u5b66\u4e60\uff1a","title":"\u5b66\u4e60\u5efa\u8bae"},{"location":"#1","text":"\u9996\u5148\u719f\u6089 CuTe \u7684\u6838\u5fc3\u6982\u5ff5\uff0c\u5305\u62ec Layout\u3001Tensor \u7b49\u57fa\u672c\u6570\u636e\u7ed3\u6784\u3002","title":"1. \u7406\u89e3\u57fa\u7840\u6982\u5ff5"},{"location":"#2","text":"\u5b66\u4e60 Copy \u548c MMA \u64cd\u4f5c\u7684\u57fa\u672c\u7528\u6cd5\uff0c\u7406\u89e3\u5b83\u4eec\u5982\u4f55\u4e0e Layout \u548c Tensor \u534f\u540c\u5de5\u4f5c\u3002","title":"2. \u638c\u63e1\u57fa\u672c\u64cd\u4f5c"},{"location":"#3","text":"\u901a\u8fc7\u5b9e\u9645\u793a\u4f8b\u52a0\u6df1\u7406\u89e3\uff0c\u5c1d\u8bd5\u6784\u5efa\u81ea\u5df1\u7684\u9ad8\u6027\u80fd CUDA \u7a0b\u5e8f\u3002","title":"3. \u5b9e\u8df5\u5e94\u7528"},{"location":"#4","text":"\u6df1\u5165\u4e86\u89e3\u5404\u79cd\u4f18\u5316\u6280\u672f\uff0c\u5305\u62ec\u5185\u5b58\u5e03\u5c40\u4f18\u5316\u3001\u7ebf\u7a0b\u534f\u4f5c\u4f18\u5316\u7b49\u3002","title":"4. \u6df1\u5165\u4f18\u5316"},{"location":"#_6","text":"\u4ee5\u4e0b\u662f\u4e00\u4e9b\u6709\u7528\u7684\u5b66\u4e60\u8d44\u6e90\uff1a CUTLASS GitHub \u4ed3\u5e93 \uff1a\u5b98\u65b9\u6e90\u4ee3\u7801\u548c\u6587\u6863 CUTLASS Documentation \uff1a\u5b98\u65b9\u6587\u6863 CUDA Programming Guide \uff1aCUDA \u7f16\u7a0b\u6307\u5357 NVIDIA Developer Blog \uff1aNVIDIA \u5f00\u53d1\u8005\u535a\u5ba2","title":"\u76f8\u5173\u8d44\u6e90"},{"location":"#_7","text":"\u5982\u679c\u60a8\u5728\u5b66\u4e60\u8fc7\u7a0b\u4e2d\u53d1\u73b0\u4efb\u4f55\u95ee\u9898\u6216\u6709\u6539\u8fdb\u5efa\u8bae\uff0c\u6b22\u8fce\u63d0\u4ea4 issue \u6216 pull request\u3002\u60a8\u7684\u8d21\u732e\u5c06\u5e2e\u52a9\u6211\u4eec\u4e0d\u65ad\u5b8c\u5584\u8fd9\u4e9b\u5b66\u4e60\u8d44\u6599\uff0c\u5e2e\u52a9\u66f4\u591a\u5f00\u53d1\u8005\u638c\u63e1 CUTLASS \u548c CuTe\u3002 \u8ba9\u6211\u4eec\u5f00\u59cb\u8fd9\u6bb5 CUTLASS \u548c CuTe \u7684\u5b66\u4e60\u4e4b\u65c5\u5427\uff01","title":"\u8d21\u732e\u4e0e\u53cd\u9988"},{"location":"cute_copy/","text":"CuTe Copy \u64cd\u4f5c\u8be6\u89e3 Copy \u64cd\u4f5c\u662f CuTe \u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\uff0c\u5b83\u8d1f\u8d23\u5728\u4e0d\u540c\u5185\u5b58\u4f4d\u7f6e\u4e4b\u95f4\u9ad8\u6548\u5730\u590d\u5236\u6570\u636e\u3002Copy \u64cd\u4f5c\u5229\u7528\u4e86 Layout \u62bd\u8c61\uff0c\u53ef\u4ee5\u5904\u7406\u590d\u6742\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u3002 Copy \u57fa\u672c\u6982\u5ff5 \u5728 CuTe \u4e2d\uff0cCopy \u64cd\u4f5c\u4e0d\u4ec5\u4ec5\u662f\u7b80\u5355\u7684\u5185\u5b58\u590d\u5236\u3002\u5b83\u662f\u4e00\u4e2a\u9ad8\u5ea6\u62bd\u8c61\u7684\u64cd\u4f5c\uff0c\u53ef\u4ee5\u5904\u7406\uff1a \u4e0d\u540c\u5185\u5b58\u7a7a\u95f4\u4e4b\u95f4\u7684\u6570\u636e\u4f20\u8f93\uff08\u4f8b\u5982\uff0c\u4e3b\u673a\u5230\u8bbe\u5907\uff0c\u5171\u4eab\u5185\u5b58\u5230\u5bc4\u5b58\u5668\uff09 \u590d\u6742\u7684\u6570\u636e\u91cd\u6392\uff08\u4f8b\u5982\uff0c\u8f6c\u7f6e\uff09 \u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\u4ee5\u63d0\u9ad8\u6027\u80fd \u4e0e\u7ebf\u7a0b\u534f\u4f5c\u8fdb\u884c\u5927\u89c4\u6a21\u6570\u636e\u79fb\u52a8 TiledCopy TiledCopy \u662f CuTe \u4e2d\u7528\u4e8e\u6267\u884c\u590d\u5236\u64cd\u4f5c\u7684\u4e3b\u8981\u62bd\u8c61\u3002\u5b83\u5c06\u590d\u5236\u64cd\u4f5c\u5206\u89e3\u4e3a\u4e24\u4e2a\u4e3b\u8981\u90e8\u5206\uff1a Tiler\uff1a\u5b9a\u4e49\u5982\u4f55\u5c06\u6e90\u548c\u76ee\u6807\u5f20\u91cf\u5206\u89e3\u4e3a tile ThrRef\uff1a\u5b9a\u4e49\u6bcf\u4e2a\u7ebf\u7a0b\u5982\u4f55\u8bbf\u95ee\u8fd9\u4e9b tile \u4e2d\u7684\u6570\u636e TiledCopy \u7684\u7ec4\u6210 \u4e00\u4e2a TiledCopy \u901a\u5e38\u7531\u4ee5\u4e0b\u7ec4\u4ef6\u6784\u6210\uff1a CopyAtom \uff1a\u5b9a\u4e49\u57fa\u672c\u7684\u590d\u5236\u64cd\u4f5c\u5355\u5143 Tiler\uff1a\u5b9a\u4e49\u590d\u5236\u64cd\u4f5c\u7684\u5e73\u94fa\u7b56\u7565 ThrRef\uff1a\u5b9a\u4e49\u7ebf\u7a0b\u5982\u4f55\u5f15\u7528\u6570\u636e CopyAtom CopyAtom \u662f CuTe \u4e2d\u590d\u5236\u64cd\u4f5c\u7684\u57fa\u672c\u6784\u5efa\u5757\u3002\u5b83\u5c01\u88c5\u4e86\uff1a \u5b9e\u9645\u7684\u590d\u5236\u6307\u4ee4\uff08\u5982 LDGSTS\u3001STS\u3001LDS \u7b49\uff09 \u6e90\u548c\u76ee\u6807\u7684\u5e03\u5c40\u4fe1\u606f \u590d\u5236\u64cd\u4f5c\u7684\u7ea6\u675f\u6761\u4ef6 CopyAtom \u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\u67b6\u6784\u548c\u5185\u5b58\u7c7b\u578b\u8fdb\u884c\u4f18\u5316\u3002 Copy \u64cd\u4f5c\u793a\u4f8b \u4e00\u4e2a\u5178\u578b\u7684 Copy \u64cd\u4f5c\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a // \u5b9a\u4e49\u6e90\u5f20\u91cf\u548c\u76ee\u6807\u5f20\u91cf auto src_tensor = make_tensor(src_ptr, src_layout); auto dst_tensor = make_tensor(dst_ptr, dst_layout); // \u521b\u5efa TiledCopy \u5bf9\u8c61 auto tiled_copy = make_tiled_copy(CopyAtom{}, tiled_shape, thread_shape); // \u83b7\u53d6\u590d\u5236\u64cd\u4f5c\u7684\u53c2\u4e0e\u8005 auto copy_thr = tiled_copy.get_thread_slice(thread_idx); // \u6267\u884c\u590d\u5236\u64cd\u4f5c copy_thr.copy(src_tensor, dst_tensor); \u9ad8\u7ea7 Copy \u64cd\u4f5c CuTe \u8fd8\u652f\u6301\u66f4\u9ad8\u7ea7\u7684 Copy \u64cd\u4f5c\uff0c\u5982\uff1a \u6761\u4ef6\u590d\u5236\uff08Predicated Copy\uff09\uff1a\u53ea\u590d\u5236\u6ee1\u8db3\u7279\u5b9a\u6761\u4ef6\u7684\u5143\u7d20 \u5f02\u6b65\u590d\u5236\uff1a\u4f7f\u7528\u5f02\u6b65\u5185\u5b58\u64cd\u4f5c\u63d0\u9ad8\u6027\u80fd \u6709\u5173\u4e13\u95e8\u7684 TMA (Tensor Memory Access) Copy \u64cd\u4f5c\uff0c\u8bf7\u53c2\u9605 TMA Copy \u64cd\u4f5c \u6587\u6863\u3002","title":"Copy \u64cd\u4f5c\u8be6\u89e3"},{"location":"cute_copy/#cute-copy","text":"Copy \u64cd\u4f5c\u662f CuTe \u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\uff0c\u5b83\u8d1f\u8d23\u5728\u4e0d\u540c\u5185\u5b58\u4f4d\u7f6e\u4e4b\u95f4\u9ad8\u6548\u5730\u590d\u5236\u6570\u636e\u3002Copy \u64cd\u4f5c\u5229\u7528\u4e86 Layout \u62bd\u8c61\uff0c\u53ef\u4ee5\u5904\u7406\u590d\u6742\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u3002","title":"CuTe Copy \u64cd\u4f5c\u8be6\u89e3"},{"location":"cute_copy/#copy","text":"\u5728 CuTe \u4e2d\uff0cCopy \u64cd\u4f5c\u4e0d\u4ec5\u4ec5\u662f\u7b80\u5355\u7684\u5185\u5b58\u590d\u5236\u3002\u5b83\u662f\u4e00\u4e2a\u9ad8\u5ea6\u62bd\u8c61\u7684\u64cd\u4f5c\uff0c\u53ef\u4ee5\u5904\u7406\uff1a \u4e0d\u540c\u5185\u5b58\u7a7a\u95f4\u4e4b\u95f4\u7684\u6570\u636e\u4f20\u8f93\uff08\u4f8b\u5982\uff0c\u4e3b\u673a\u5230\u8bbe\u5907\uff0c\u5171\u4eab\u5185\u5b58\u5230\u5bc4\u5b58\u5668\uff09 \u590d\u6742\u7684\u6570\u636e\u91cd\u6392\uff08\u4f8b\u5982\uff0c\u8f6c\u7f6e\uff09 \u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\u4ee5\u63d0\u9ad8\u6027\u80fd \u4e0e\u7ebf\u7a0b\u534f\u4f5c\u8fdb\u884c\u5927\u89c4\u6a21\u6570\u636e\u79fb\u52a8","title":"Copy \u57fa\u672c\u6982\u5ff5"},{"location":"cute_copy/#tiledcopy","text":"TiledCopy \u662f CuTe \u4e2d\u7528\u4e8e\u6267\u884c\u590d\u5236\u64cd\u4f5c\u7684\u4e3b\u8981\u62bd\u8c61\u3002\u5b83\u5c06\u590d\u5236\u64cd\u4f5c\u5206\u89e3\u4e3a\u4e24\u4e2a\u4e3b\u8981\u90e8\u5206\uff1a Tiler\uff1a\u5b9a\u4e49\u5982\u4f55\u5c06\u6e90\u548c\u76ee\u6807\u5f20\u91cf\u5206\u89e3\u4e3a tile ThrRef\uff1a\u5b9a\u4e49\u6bcf\u4e2a\u7ebf\u7a0b\u5982\u4f55\u8bbf\u95ee\u8fd9\u4e9b tile \u4e2d\u7684\u6570\u636e","title":"TiledCopy"},{"location":"cute_copy/#tiledcopy_1","text":"\u4e00\u4e2a TiledCopy \u901a\u5e38\u7531\u4ee5\u4e0b\u7ec4\u4ef6\u6784\u6210\uff1a CopyAtom \uff1a\u5b9a\u4e49\u57fa\u672c\u7684\u590d\u5236\u64cd\u4f5c\u5355\u5143 Tiler\uff1a\u5b9a\u4e49\u590d\u5236\u64cd\u4f5c\u7684\u5e73\u94fa\u7b56\u7565 ThrRef\uff1a\u5b9a\u4e49\u7ebf\u7a0b\u5982\u4f55\u5f15\u7528\u6570\u636e","title":"TiledCopy \u7684\u7ec4\u6210"},{"location":"cute_copy/#copyatom","text":"CopyAtom \u662f CuTe \u4e2d\u590d\u5236\u64cd\u4f5c\u7684\u57fa\u672c\u6784\u5efa\u5757\u3002\u5b83\u5c01\u88c5\u4e86\uff1a \u5b9e\u9645\u7684\u590d\u5236\u6307\u4ee4\uff08\u5982 LDGSTS\u3001STS\u3001LDS \u7b49\uff09 \u6e90\u548c\u76ee\u6807\u7684\u5e03\u5c40\u4fe1\u606f \u590d\u5236\u64cd\u4f5c\u7684\u7ea6\u675f\u6761\u4ef6 CopyAtom \u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\u67b6\u6784\u548c\u5185\u5b58\u7c7b\u578b\u8fdb\u884c\u4f18\u5316\u3002","title":"CopyAtom"},{"location":"cute_copy/#copy_1","text":"\u4e00\u4e2a\u5178\u578b\u7684 Copy \u64cd\u4f5c\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a // \u5b9a\u4e49\u6e90\u5f20\u91cf\u548c\u76ee\u6807\u5f20\u91cf auto src_tensor = make_tensor(src_ptr, src_layout); auto dst_tensor = make_tensor(dst_ptr, dst_layout); // \u521b\u5efa TiledCopy \u5bf9\u8c61 auto tiled_copy = make_tiled_copy(CopyAtom{}, tiled_shape, thread_shape); // \u83b7\u53d6\u590d\u5236\u64cd\u4f5c\u7684\u53c2\u4e0e\u8005 auto copy_thr = tiled_copy.get_thread_slice(thread_idx); // \u6267\u884c\u590d\u5236\u64cd\u4f5c copy_thr.copy(src_tensor, dst_tensor);","title":"Copy \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_copy/#copy_2","text":"CuTe \u8fd8\u652f\u6301\u66f4\u9ad8\u7ea7\u7684 Copy \u64cd\u4f5c\uff0c\u5982\uff1a \u6761\u4ef6\u590d\u5236\uff08Predicated Copy\uff09\uff1a\u53ea\u590d\u5236\u6ee1\u8db3\u7279\u5b9a\u6761\u4ef6\u7684\u5143\u7d20 \u5f02\u6b65\u590d\u5236\uff1a\u4f7f\u7528\u5f02\u6b65\u5185\u5b58\u64cd\u4f5c\u63d0\u9ad8\u6027\u80fd \u6709\u5173\u4e13\u95e8\u7684 TMA (Tensor Memory Access) Copy \u64cd\u4f5c\uff0c\u8bf7\u53c2\u9605 TMA Copy \u64cd\u4f5c \u6587\u6863\u3002","title":"\u9ad8\u7ea7 Copy \u64cd\u4f5c"},{"location":"cute_core/","text":"CuTe \u6838\u5fc3\u6982\u5ff5 CuTe (CUDA Template Engine) \u662f NVIDIA \u5f00\u53d1\u7684\u4e00\u4e2a C++ \u6a21\u677f\u5e93\uff0c\u7528\u4e8e\u5728\u7f16\u8bd1\u65f6\u64cd\u4f5c\u548c\u4f18\u5316\u5f20\u91cf\u8ba1\u7b97\u3002\u5b83\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u62bd\u8c61\u80fd\u529b\uff0c\u4f7f\u5f97\u5f00\u53d1\u8005\u80fd\u591f\u7f16\u5199\u9ad8\u6027\u80fd\u3001\u53ef\u7ef4\u62a4\u7684 CUDA \u4ee3\u7801\u3002 \u6838\u5fc3\u7ec4\u4ef6 CuTe \u7684\u6838\u5fc3\u7ec4\u4ef6\u5305\u62ec\uff1a Layout \uff1a\u63cf\u8ff0\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb Tensor \uff1a\u7ed3\u5408\u6570\u636e\u6307\u9488\u548c Layout \u7684\u591a\u7ef4\u6570\u636e\u7ed3\u6784 Engine \uff1a\u7ba1\u7406 Tensor \u7684\u6570\u636e\u8bbf\u95ee\u548c\u5b58\u50a8 Copy \uff1a\u5b9e\u73b0\u9ad8\u6548\u7684\u6570\u636e\u590d\u5236\u64cd\u4f5c MMA \uff1a\u5b9e\u73b0\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c \u57fa\u672c\u6570\u636e\u7c7b\u578b CuTe \u4f7f\u7528\u4e00\u7cfb\u5217\u57fa\u672c\u6570\u636e\u7c7b\u578b\u6765\u8868\u793a\u7f16\u8bd1\u65f6\u7684\u6570\u503c\u548c\u5f62\u72b6\u4fe1\u606f\u3002 \u6570\u503c\u7c7b\u578b Int \uff1a\u7f16\u8bd1\u65f6\u5e38\u91cf\u6574\u6570\u7c7b\u578b Shape \uff1a\u63cf\u8ff0\u5f20\u91cf\u5f62\u72b6\u7684\u7c7b\u578b Stride \uff1a\u63cf\u8ff0\u5f20\u91cf\u6b65\u5e45\u7684\u7c7b\u578b Layout \uff1a\u63cf\u8ff0\u5750\u6807\u5230\u7ebf\u6027\u4f4d\u7f6e\u6620\u5c04\u7684\u7c7b\u578b \u793a\u4f8b // \u5b9a\u4e49\u7f16\u8bd1\u65f6\u5e38\u91cf using size_m = Int<128>; using size_n = Int<64>; // \u5b9a\u4e49\u5f62\u72b6 using tile_shape = Shape<size_m, size_n>; // \u5b9a\u4e49\u6b65\u5e45 using tile_stride = Stride<Int<1>, size_m>; \u5750\u6807\u7cfb\u7edf CuTe \u4f7f\u7528\u5750\u6807\u7cfb\u7edf\u6765\u8bbf\u95ee\u591a\u7ef4\u6570\u636e\u7ed3\u6784\u3002 \u5750\u6807\u7c7b\u578b Coord \uff1a\u57fa\u672c\u5750\u6807\u7c7b\u578b make_coord \uff1a\u521b\u5efa\u5750\u6807\u5bf9\u8c61\u7684\u51fd\u6570 \u5750\u6807\u64cd\u4f5c\u793a\u4f8b // \u521b\u5efa\u4e8c\u7ef4\u5750\u6807 auto coord_2d = make_coord(10, 20); // \u8bbf\u95ee\u5750\u6807\u5206\u91cf auto x = get<0>(coord_2d); // \u83b7\u53d6\u7b2c\u4e00\u4e2a\u5206\u91cf auto y = get<1>(coord_2d); // \u83b7\u53d6\u7b2c\u4e8c\u4e2a\u5206\u91cf // \u521b\u5efa\u591a\u7ef4\u5750\u6807 auto coord_4d = make_coord(1, 2, 3, 4); \u7f16\u8bd1\u65f6\u8ba1\u7b97 CuTe \u5927\u91cf\u4f7f\u7528\u7f16\u8bd1\u65f6\u8ba1\u7b97\u6765\u4f18\u5316\u6027\u80fd\u3002 \u7f16\u8bd1\u65f6\u64cd\u4f5c \u9759\u6001\u65ad\u8a00 \uff1a\u5728\u7f16\u8bd1\u65f6\u9a8c\u8bc1\u6761\u4ef6 \u6a21\u677f\u7279\u5316 \uff1a\u6839\u636e\u4e0d\u540c\u7c7b\u578b\u63d0\u4f9b\u4e0d\u540c\u5b9e\u73b0 constexpr \u51fd\u6570 \uff1a\u7f16\u8bd1\u65f6\u6267\u884c\u7684\u51fd\u6570 \u793a\u4f8b // \u4f7f\u7528\u9759\u6001\u65ad\u8a00\u9a8c\u8bc1\u6761\u4ef6 static_assert(is_static<Shape<_128,_64>>::value, \"Shape must be static\"); // constexpr \u51fd\u6570\u793a\u4f8b template <class Shape> CUTE_HOST_DEVICE constexpr auto get_total_size(Shape const& shape) { return size(shape); } CuTe \u7684\u8bbe\u8ba1\u54f2\u5b66 CuTe \u7684\u8bbe\u8ba1\u9075\u5faa\u4ee5\u4e0b\u54f2\u5b66\uff1a 1. \u7f16\u8bd1\u65f6\u4f18\u5316 CuTe \u5c06\u5c3d\u53ef\u80fd\u591a\u7684\u8ba1\u7b97\u79fb\u5230\u7f16\u8bd1\u65f6\uff0c\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u5f00\u9500\u3002 // \u7f16\u8bd1\u65f6\u786e\u5b9a\u7684\u5f62\u72b6\u548c\u6b65\u5e45 using ThreadLayout = Layout<Shape<_4,_8>, Stride<_8,_1>>; // \u7f16\u8bd1\u65f6\u8ba1\u7b97\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f auto thread_layout = ThreadLayout{}; 2. \u62bd\u8c61\u4e0e\u6027\u80fd\u7684\u5e73\u8861 CuTe \u63d0\u4f9b\u9ad8\u5c42\u6b21\u7684\u62bd\u8c61\uff0c\u540c\u65f6\u4fdd\u8bc1\u4e0d\u727a\u7272\u6027\u80fd\u3002 // \u9ad8\u5c42\u6b21\u62bd\u8c61\uff0c\u4f46\u751f\u6210\u9ad8\u6548\u7684\u4ee3\u7801 auto tensor = make_tensor(ptr, make_layout(make_shape(M, N), GenRowMajor{})); 3. \u6a21\u5757\u5316\u8bbe\u8ba1 CuTe \u7684\u7ec4\u4ef6\u8bbe\u8ba1\u4e3a\u53ef\u7ec4\u5408\u7684\u6a21\u5757\uff0c\u53ef\u4ee5\u7075\u6d3b\u7ec4\u5408\u4f7f\u7528\u3002 // \u7ec4\u5408\u4e0d\u540c\u7684\u7ec4\u4ef6 auto tiled_copy = make_tiled_copy(Copy_Atom{}, make_shape(BLK_M, BLK_N), make_shape(THR_M, THR_N)); CuTe \u4e0e\u5176\u4ed6\u5e93\u7684\u5173\u7cfb CuTe \u4e0e\u5176\u4ed6 CUDA \u76f8\u5173\u5e93\u6709\u4ee5\u4e0b\u5173\u7cfb\uff1a 1. \u4e0e CUTLASS \u7684\u5173\u7cfb CuTe \u662f CUTLASS 3.0 \u7684\u6838\u5fc3\u7ec4\u4ef6\uff0c\u63d0\u4f9b\u4e86\u5e95\u5c42\u7684\u5f20\u91cf\u64cd\u4f5c\u62bd\u8c61\u3002 2. \u4e0e CUDA \u7684\u5173\u7cfb CuTe \u751f\u6210\u7684\u4ee3\u7801\u76f4\u63a5\u7f16\u8bd1\u4e3a CUDA \u4ee3\u7801\uff0c\u53ef\u4ee5\u4e0e\u539f\u751f CUDA \u4ee3\u7801\u65e0\u7f1d\u96c6\u6210\u3002 3. \u4e0e\u6807\u51c6\u5e93\u7684\u5173\u7cfb CuTe \u501f\u9274\u4e86\u6807\u51c6\u5e93\u7684\u4e00\u4e9b\u8bbe\u8ba1\u601d\u60f3\uff0c\u4f46\u9488\u5bf9 GPU \u8ba1\u7b97\u8fdb\u884c\u4e86\u4f18\u5316\u3002 \u4f7f\u7528 CuTe \u7684\u4f18\u52bf \u4f7f\u7528 CuTe \u5177\u6709\u4ee5\u4e0b\u4f18\u52bf\uff1a \u6027\u80fd \uff1a\u901a\u8fc7\u7f16\u8bd1\u65f6\u4f18\u5316\u751f\u6210\u9ad8\u6548\u7684\u4ee3\u7801 \u7075\u6d3b\u6027 \uff1a\u652f\u6301\u5404\u79cd\u6570\u636e\u5e03\u5c40\u548c\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \u53ef\u7ef4\u62a4\u6027 \uff1a\u63d0\u4f9b\u9ad8\u5c42\u6b21\u62bd\u8c61\uff0c\u4f7f\u4ee3\u7801\u66f4\u6613\u7406\u89e3\u548c\u7ef4\u62a4 \u53ef\u6269\u5c55\u6027 \uff1a\u6a21\u5757\u5316\u8bbe\u8ba1\u652f\u6301\u7075\u6d3b\u7ec4\u5408\u548c\u6269\u5c55 \u57fa\u672c\u4f7f\u7528\u6a21\u5f0f \u4f7f\u7528 CuTe \u7684\u57fa\u672c\u6a21\u5f0f\u5305\u62ec\uff1a 1. \u5b9a\u4e49\u6570\u636e\u7ed3\u6784 // \u5b9a\u4e49\u5f20\u91cf\u5f62\u72b6 auto shape = make_shape(Int<128>{}, Int<64>{}); // \u5b9a\u4e49\u5185\u5b58\u5e03\u5c40 auto layout = make_layout(shape, GenRowMajor{}); // \u521b\u5efa\u5f20\u91cf auto tensor = make_tensor(ptr, layout); 2. \u6267\u884c\u64cd\u4f5c // \u6267\u884c\u590d\u5236\u64cd\u4f5c copy(src_tensor, dst_tensor); // \u6267\u884c\u77e9\u9635\u4e58\u6cd5 gemm(A, B, C); 3. \u7ebf\u7a0b\u534f\u4f5c // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto tile = tiled_copy.get_slice(thread_idx); // \u5206\u533a\u5f20\u91cf auto src_frag = tile.partition_S(src_tensor); auto dst_frag = tile.partition_D(dst_tensor); \u8fd9\u4e9b\u6838\u5fc3\u6982\u5ff5\u6784\u6210\u4e86 CuTe \u7684\u57fa\u7840\uff0c\u7406\u89e3\u5b83\u4eec\u5bf9\u4e8e\u6709\u6548\u4f7f\u7528 CuTe \u81f3\u5173\u91cd\u8981\u3002","title":"Cute \u6838\u5fc3\u6982\u5ff5"},{"location":"cute_core/#cute","text":"CuTe (CUDA Template Engine) \u662f NVIDIA \u5f00\u53d1\u7684\u4e00\u4e2a C++ \u6a21\u677f\u5e93\uff0c\u7528\u4e8e\u5728\u7f16\u8bd1\u65f6\u64cd\u4f5c\u548c\u4f18\u5316\u5f20\u91cf\u8ba1\u7b97\u3002\u5b83\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u62bd\u8c61\u80fd\u529b\uff0c\u4f7f\u5f97\u5f00\u53d1\u8005\u80fd\u591f\u7f16\u5199\u9ad8\u6027\u80fd\u3001\u53ef\u7ef4\u62a4\u7684 CUDA \u4ee3\u7801\u3002","title":"CuTe \u6838\u5fc3\u6982\u5ff5"},{"location":"cute_core/#_1","text":"CuTe \u7684\u6838\u5fc3\u7ec4\u4ef6\u5305\u62ec\uff1a Layout \uff1a\u63cf\u8ff0\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb Tensor \uff1a\u7ed3\u5408\u6570\u636e\u6307\u9488\u548c Layout \u7684\u591a\u7ef4\u6570\u636e\u7ed3\u6784 Engine \uff1a\u7ba1\u7406 Tensor \u7684\u6570\u636e\u8bbf\u95ee\u548c\u5b58\u50a8 Copy \uff1a\u5b9e\u73b0\u9ad8\u6548\u7684\u6570\u636e\u590d\u5236\u64cd\u4f5c MMA \uff1a\u5b9e\u73b0\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c","title":"\u6838\u5fc3\u7ec4\u4ef6"},{"location":"cute_core/#_2","text":"CuTe \u4f7f\u7528\u4e00\u7cfb\u5217\u57fa\u672c\u6570\u636e\u7c7b\u578b\u6765\u8868\u793a\u7f16\u8bd1\u65f6\u7684\u6570\u503c\u548c\u5f62\u72b6\u4fe1\u606f\u3002","title":"\u57fa\u672c\u6570\u636e\u7c7b\u578b"},{"location":"cute_core/#_3","text":"Int \uff1a\u7f16\u8bd1\u65f6\u5e38\u91cf\u6574\u6570\u7c7b\u578b Shape \uff1a\u63cf\u8ff0\u5f20\u91cf\u5f62\u72b6\u7684\u7c7b\u578b Stride \uff1a\u63cf\u8ff0\u5f20\u91cf\u6b65\u5e45\u7684\u7c7b\u578b Layout \uff1a\u63cf\u8ff0\u5750\u6807\u5230\u7ebf\u6027\u4f4d\u7f6e\u6620\u5c04\u7684\u7c7b\u578b","title":"\u6570\u503c\u7c7b\u578b"},{"location":"cute_core/#_4","text":"// \u5b9a\u4e49\u7f16\u8bd1\u65f6\u5e38\u91cf using size_m = Int<128>; using size_n = Int<64>; // \u5b9a\u4e49\u5f62\u72b6 using tile_shape = Shape<size_m, size_n>; // \u5b9a\u4e49\u6b65\u5e45 using tile_stride = Stride<Int<1>, size_m>;","title":"\u793a\u4f8b"},{"location":"cute_core/#_5","text":"CuTe \u4f7f\u7528\u5750\u6807\u7cfb\u7edf\u6765\u8bbf\u95ee\u591a\u7ef4\u6570\u636e\u7ed3\u6784\u3002","title":"\u5750\u6807\u7cfb\u7edf"},{"location":"cute_core/#_6","text":"Coord \uff1a\u57fa\u672c\u5750\u6807\u7c7b\u578b make_coord \uff1a\u521b\u5efa\u5750\u6807\u5bf9\u8c61\u7684\u51fd\u6570","title":"\u5750\u6807\u7c7b\u578b"},{"location":"cute_core/#_7","text":"// \u521b\u5efa\u4e8c\u7ef4\u5750\u6807 auto coord_2d = make_coord(10, 20); // \u8bbf\u95ee\u5750\u6807\u5206\u91cf auto x = get<0>(coord_2d); // \u83b7\u53d6\u7b2c\u4e00\u4e2a\u5206\u91cf auto y = get<1>(coord_2d); // \u83b7\u53d6\u7b2c\u4e8c\u4e2a\u5206\u91cf // \u521b\u5efa\u591a\u7ef4\u5750\u6807 auto coord_4d = make_coord(1, 2, 3, 4);","title":"\u5750\u6807\u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_core/#_8","text":"CuTe \u5927\u91cf\u4f7f\u7528\u7f16\u8bd1\u65f6\u8ba1\u7b97\u6765\u4f18\u5316\u6027\u80fd\u3002","title":"\u7f16\u8bd1\u65f6\u8ba1\u7b97"},{"location":"cute_core/#_9","text":"\u9759\u6001\u65ad\u8a00 \uff1a\u5728\u7f16\u8bd1\u65f6\u9a8c\u8bc1\u6761\u4ef6 \u6a21\u677f\u7279\u5316 \uff1a\u6839\u636e\u4e0d\u540c\u7c7b\u578b\u63d0\u4f9b\u4e0d\u540c\u5b9e\u73b0 constexpr \u51fd\u6570 \uff1a\u7f16\u8bd1\u65f6\u6267\u884c\u7684\u51fd\u6570","title":"\u7f16\u8bd1\u65f6\u64cd\u4f5c"},{"location":"cute_core/#_10","text":"// \u4f7f\u7528\u9759\u6001\u65ad\u8a00\u9a8c\u8bc1\u6761\u4ef6 static_assert(is_static<Shape<_128,_64>>::value, \"Shape must be static\"); // constexpr \u51fd\u6570\u793a\u4f8b template <class Shape> CUTE_HOST_DEVICE constexpr auto get_total_size(Shape const& shape) { return size(shape); }","title":"\u793a\u4f8b"},{"location":"cute_core/#cute_1","text":"CuTe \u7684\u8bbe\u8ba1\u9075\u5faa\u4ee5\u4e0b\u54f2\u5b66\uff1a","title":"CuTe \u7684\u8bbe\u8ba1\u54f2\u5b66"},{"location":"cute_core/#1","text":"CuTe \u5c06\u5c3d\u53ef\u80fd\u591a\u7684\u8ba1\u7b97\u79fb\u5230\u7f16\u8bd1\u65f6\uff0c\u4ee5\u51cf\u5c11\u8fd0\u884c\u65f6\u5f00\u9500\u3002 // \u7f16\u8bd1\u65f6\u786e\u5b9a\u7684\u5f62\u72b6\u548c\u6b65\u5e45 using ThreadLayout = Layout<Shape<_4,_8>, Stride<_8,_1>>; // \u7f16\u8bd1\u65f6\u8ba1\u7b97\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f auto thread_layout = ThreadLayout{};","title":"1. \u7f16\u8bd1\u65f6\u4f18\u5316"},{"location":"cute_core/#2","text":"CuTe \u63d0\u4f9b\u9ad8\u5c42\u6b21\u7684\u62bd\u8c61\uff0c\u540c\u65f6\u4fdd\u8bc1\u4e0d\u727a\u7272\u6027\u80fd\u3002 // \u9ad8\u5c42\u6b21\u62bd\u8c61\uff0c\u4f46\u751f\u6210\u9ad8\u6548\u7684\u4ee3\u7801 auto tensor = make_tensor(ptr, make_layout(make_shape(M, N), GenRowMajor{}));","title":"2. \u62bd\u8c61\u4e0e\u6027\u80fd\u7684\u5e73\u8861"},{"location":"cute_core/#3","text":"CuTe \u7684\u7ec4\u4ef6\u8bbe\u8ba1\u4e3a\u53ef\u7ec4\u5408\u7684\u6a21\u5757\uff0c\u53ef\u4ee5\u7075\u6d3b\u7ec4\u5408\u4f7f\u7528\u3002 // \u7ec4\u5408\u4e0d\u540c\u7684\u7ec4\u4ef6 auto tiled_copy = make_tiled_copy(Copy_Atom{}, make_shape(BLK_M, BLK_N), make_shape(THR_M, THR_N));","title":"3. \u6a21\u5757\u5316\u8bbe\u8ba1"},{"location":"cute_core/#cute_2","text":"CuTe \u4e0e\u5176\u4ed6 CUDA \u76f8\u5173\u5e93\u6709\u4ee5\u4e0b\u5173\u7cfb\uff1a","title":"CuTe \u4e0e\u5176\u4ed6\u5e93\u7684\u5173\u7cfb"},{"location":"cute_core/#1-cutlass","text":"CuTe \u662f CUTLASS 3.0 \u7684\u6838\u5fc3\u7ec4\u4ef6\uff0c\u63d0\u4f9b\u4e86\u5e95\u5c42\u7684\u5f20\u91cf\u64cd\u4f5c\u62bd\u8c61\u3002","title":"1. \u4e0e CUTLASS \u7684\u5173\u7cfb"},{"location":"cute_core/#2-cuda","text":"CuTe \u751f\u6210\u7684\u4ee3\u7801\u76f4\u63a5\u7f16\u8bd1\u4e3a CUDA \u4ee3\u7801\uff0c\u53ef\u4ee5\u4e0e\u539f\u751f CUDA \u4ee3\u7801\u65e0\u7f1d\u96c6\u6210\u3002","title":"2. \u4e0e CUDA \u7684\u5173\u7cfb"},{"location":"cute_core/#3_1","text":"CuTe \u501f\u9274\u4e86\u6807\u51c6\u5e93\u7684\u4e00\u4e9b\u8bbe\u8ba1\u601d\u60f3\uff0c\u4f46\u9488\u5bf9 GPU \u8ba1\u7b97\u8fdb\u884c\u4e86\u4f18\u5316\u3002","title":"3. \u4e0e\u6807\u51c6\u5e93\u7684\u5173\u7cfb"},{"location":"cute_core/#cute_3","text":"\u4f7f\u7528 CuTe \u5177\u6709\u4ee5\u4e0b\u4f18\u52bf\uff1a \u6027\u80fd \uff1a\u901a\u8fc7\u7f16\u8bd1\u65f6\u4f18\u5316\u751f\u6210\u9ad8\u6548\u7684\u4ee3\u7801 \u7075\u6d3b\u6027 \uff1a\u652f\u6301\u5404\u79cd\u6570\u636e\u5e03\u5c40\u548c\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \u53ef\u7ef4\u62a4\u6027 \uff1a\u63d0\u4f9b\u9ad8\u5c42\u6b21\u62bd\u8c61\uff0c\u4f7f\u4ee3\u7801\u66f4\u6613\u7406\u89e3\u548c\u7ef4\u62a4 \u53ef\u6269\u5c55\u6027 \uff1a\u6a21\u5757\u5316\u8bbe\u8ba1\u652f\u6301\u7075\u6d3b\u7ec4\u5408\u548c\u6269\u5c55","title":"\u4f7f\u7528 CuTe \u7684\u4f18\u52bf"},{"location":"cute_core/#_11","text":"\u4f7f\u7528 CuTe \u7684\u57fa\u672c\u6a21\u5f0f\u5305\u62ec\uff1a","title":"\u57fa\u672c\u4f7f\u7528\u6a21\u5f0f"},{"location":"cute_core/#1_1","text":"// \u5b9a\u4e49\u5f20\u91cf\u5f62\u72b6 auto shape = make_shape(Int<128>{}, Int<64>{}); // \u5b9a\u4e49\u5185\u5b58\u5e03\u5c40 auto layout = make_layout(shape, GenRowMajor{}); // \u521b\u5efa\u5f20\u91cf auto tensor = make_tensor(ptr, layout);","title":"1. \u5b9a\u4e49\u6570\u636e\u7ed3\u6784"},{"location":"cute_core/#2_1","text":"// \u6267\u884c\u590d\u5236\u64cd\u4f5c copy(src_tensor, dst_tensor); // \u6267\u884c\u77e9\u9635\u4e58\u6cd5 gemm(A, B, C);","title":"2. \u6267\u884c\u64cd\u4f5c"},{"location":"cute_core/#3_2","text":"// \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto tile = tiled_copy.get_slice(thread_idx); // \u5206\u533a\u5f20\u91cf auto src_frag = tile.partition_S(src_tensor); auto dst_frag = tile.partition_D(dst_tensor); \u8fd9\u4e9b\u6838\u5fc3\u6982\u5ff5\u6784\u6210\u4e86 CuTe \u7684\u57fa\u7840\uff0c\u7406\u89e3\u5b83\u4eec\u5bf9\u4e8e\u6709\u6548\u4f7f\u7528 CuTe \u81f3\u5173\u91cd\u8981\u3002","title":"3. \u7ebf\u7a0b\u534f\u4f5c"},{"location":"cute_examples/","text":"CuTe \u5b9e\u9645\u5e94\u7528\u793a\u4f8b \u901a\u8fc7\u5177\u4f53\u7684\u793a\u4f8b\u6765\u5c55\u793a\u5982\u4f55\u4f7f\u7528 CuTe \u6784\u5efa\u9ad8\u6027\u80fd\u7684 CUDA \u7a0b\u5e8f\u3002 \u57fa\u672c Copy \u64cd\u4f5c\u793a\u4f8b \u4ee5\u4e0b\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 CuTe \u6267\u884c\u57fa\u672c\u7684 Copy \u64cd\u4f5c\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void copy_example() { // \u5b9a\u4e49\u6570\u636e\u6307\u9488 float *src_ptr = /* \u6e90\u6570\u636e\u6307\u9488 */; float *dst_ptr = /* \u76ee\u6807\u6570\u636e\u6307\u9488 */; // \u521b\u5efa Layout auto layout = make_layout(make_shape(32, 32), GenRowMajor{}); // \u521b\u5efa Tensor auto src_tensor = make_tensor(make_gmem_ptr(src_ptr), layout); auto dst_tensor = make_tensor(make_gmem_ptr(dst_ptr), layout); // \u6267\u884c Copy \u64cd\u4f5c copy(src_tensor, dst_tensor); } \u77e9\u9635\u8f6c\u7f6e\u793a\u4f8b \u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 CuTe \u5b9e\u73b0\u9ad8\u6548\u7684\u77e9\u9635\u8f6c\u7f6e\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void matrix_transpose() { // \u5b9a\u4e49\u77e9\u9635\u7ef4\u5ea6 constexpr int M = 64; constexpr int N = 64; // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *src_ptr = /* \u6e90\u77e9\u9635\u6307\u9488 */; float *dst_ptr = /* \u76ee\u6807\u77e9\u9635\u6307\u9488 */; // \u521b\u5efa\u6e90\u77e9\u9635 Tensor (\u884c\u4e3b\u5e8f) auto src_layout = make_layout(make_shape(M, N), GenRowMajor{}); auto src_tensor = make_tensor(make_gmem_ptr(src_ptr), src_layout); // \u521b\u5efa\u76ee\u6807\u77e9\u9635 Tensor (\u5217\u4e3b\u5e8f\uff0c\u5b9e\u73b0\u8f6c\u7f6e\u6548\u679c) auto dst_layout = make_layout(make_shape(M, N), GenColMajor{}); auto dst_tensor = make_tensor(make_gmem_ptr(dst_ptr), dst_layout); // \u6267\u884c Copy \u64cd\u4f5c\uff0c\u5b9e\u73b0\u8f6c\u7f6e copy(src_tensor, dst_tensor); } \u4f7f\u7528 TiledCopy \u7684\u793a\u4f8b \u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 TiledCopy \u5b9e\u73b0\u9ad8\u6548\u7684\u5757\u72b6\u590d\u5236\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void tiled_copy_example() { // \u5b9a\u4e49\u5757\u5927\u5c0f constexpr int BLK_M = 32; constexpr int BLK_N = 32; // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *src_ptr = /* \u6e90\u6570\u636e\u6307\u9488 */; float *dst_ptr = /* \u76ee\u6807\u6570\u636e\u6307\u9488 */; // \u521b\u5efa Layout auto layout = make_layout(make_shape(BLK_M, BLK_N), GenRowMajor{}); // \u521b\u5efa Tensor auto src_tensor = make_tensor(make_gmem_ptr(src_ptr), layout); auto dst_tensor = make_tensor(make_gmem_ptr(dst_ptr), layout); // \u521b\u5efa TiledCopy auto tiled_copy = make_tiled_copy(Copy_Atom<UniversalCopy<float>, float>{}, make_shape(BLK_M, BLK_N), make_shape(4, 8)); // 4x8 \u7ebf\u7a0b\u5757 // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto thr_copy = tiled_copy.get_thread_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto src_frag = thr_copy.partition_S(src_tensor); auto dst_frag = thr_copy.partition_D(dst_tensor); // \u6267\u884c\u590d\u5236 copy(src_frag, dst_frag); } MMA \u64cd\u4f5c\u793a\u4f8b \u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 CuTe \u6267\u884c\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void mma_example() { // \u5b9a\u4e49\u77e9\u9635\u7ef4\u5ea6 constexpr int M = 16; constexpr int N = 16; constexpr int K = 8; // \u83b7\u53d6\u6570\u636e\u6307\u9488 half_t *A_ptr = /* A \u77e9\u9635\u6307\u9488 */; half_t *B_ptr = /* B \u77e9\u9635\u6307\u9488 */; float *C_ptr = /* C \u77e9\u9635\u6307\u9488 */; // \u521b\u5efa\u5f20\u91cf Layout auto A_layout = make_layout(make_shape(M, K), GenRowMajor{}); auto B_layout = make_layout(make_shape(N, K), GenColMajor{}); auto C_layout = make_layout(make_shape(M, N), GenRowMajor{}); // \u521b\u5efa\u5f20\u91cf auto A_tensor = make_tensor(make_gmem_ptr(A_ptr), A_layout); auto B_tensor = make_tensor(make_gmem_ptr(B_ptr), B_layout); auto C_tensor = make_tensor(make_gmem_ptr(C_ptr), C_layout); // \u521b\u5efa MMA \u64cd\u4f5c auto mma_atom = MMA_Atom<SM70_8x8x4_F32F16F16F32_NT>{}; // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto mma_thr = mma_atom.get_thread_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto A_frag = mma_thr.partition_A(A_tensor); auto B_frag = mma_thr.partition_B(B_tensor); auto C_frag = mma_thr.partition_C(C_tensor); // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto acc_frag = make_fragment_like(C_frag); clear(acc_frag); // \u6267\u884c MMA \u64cd\u4f5c mma_thr.mma(A_frag, B_frag, acc_frag, acc_frag); // \u5c06\u7ed3\u679c\u5199\u56de copy(acc_frag, C_frag); } TMA Copy \u793a\u4f8b \u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u5728 Hopper \u67b6\u6784\u4e0a\u4f7f\u7528 TMA \u8fdb\u884c\u9ad8\u6548\u7684\u5185\u5b58\u590d\u5236\u3002 #include <cute/tensor.hpp> using namespace cute; #if defined(CUTE_ARCH_TMA_SM90_ENABLED) __global__ void tma_copy_example() { // \u5b9a\u4e49\u77e9\u9635\u7ef4\u5ea6 constexpr int M = 512; constexpr int N = 512; // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *gmem_ptr = /* \u5168\u5c40\u5185\u5b58\u6307\u9488 */; extern __shared__ float smem[]; // \u521b\u5efa\u5168\u5c40\u5185\u5b58\u5f20\u91cf auto gmem_tensor = make_tensor(make_gmem_ptr(gmem_ptr), make_shape(M, N), GenRowMajor{}); // \u521b\u5efa\u5171\u4eab\u5185\u5b58 Layout auto smem_layout = tile_to_shape(GMMA::Layout_MN_SW128_Atom<float>{}, make_shape(64, 64)); // \u521b\u5efa\u5171\u4eab\u5185\u5b58\u5f20\u91cf auto smem_tensor = make_tensor(make_smem_ptr<float>(smem), smem_layout); // \u521b\u5efa TMA Copy \u5bf9\u8c61 auto tma_load = make_tma_copy(SM90_TMA_LOAD{}, gmem_tensor, smem_layout); // \u83b7\u53d6 TMA \u5f20\u91cf auto tma_tensor = tma_load.get_tma_tensor(make_shape(M, N)); // \u5206\u5757\u5904\u7406 auto tma_gmem = local_tile(tma_tensor, make_shape(64, 64), make_coord(blockIdx.x, blockIdx.y)); // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto thr_x = tma_load.get_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto tma_gmem_x = thr_x.partition_S(tma_gmem); auto tma_smem_x = thr_x.partition_D(smem_tensor); // \u540c\u6b65\u5bf9\u8c61 uint64_t bar; auto mbar = make_mbarrier(bar); // \u6267\u884c TMA \u52a0\u8f7d copy(tma_load.with(mbar), tma_gmem_x, tma_smem_x); // \u7b49\u5f85\u5b8c\u6210 tma_load.wait(mbar); } #endif \u590d\u5408\u793a\u4f8b\uff1aGEMM \u5b9e\u73b0 \u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u4e00\u4e2a\u5b8c\u6574\u7684 GEMM (General Matrix Multiply) \u5b9e\u73b0\u3002 #include <cute/tensor.hpp> using namespace cute; template <class TiledMMA, class TiledCopyA, class TiledCopyB> __global__ void gemm_example(TiledMMA tiled_mma, TiledCopyA tiled_copy_a, TiledCopyB tiled_copy_b) { // \u83b7\u53d6\u5171\u4eab\u5185\u5b58\u6307\u9488 extern __shared__ float smem[]; // \u5206\u914d\u5171\u4eab\u5185\u5b58\u7ed9 A \u548c B float *smem_a = smem; float *smem_b = smem + sizeof(float) * 64 * 16; // \u521b\u5efa\u5171\u4eab\u5185\u5b58\u5f20\u91cf auto smem_a_tensor = make_tensor(make_smem_ptr<float>(smem_a), make_layout(make_shape(64, 16), GenRowMajor{})); auto smem_b_tensor = make_tensor(make_smem_ptr<float>(smem_b), make_layout(make_shape(64, 16), GenRowMajor{})); // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *A_ptr = /* A \u77e9\u9635\u6307\u9488 */; float *B_ptr = /* B \u77e9\u9635\u6307\u9488 */; float *C_ptr = /* C \u77e9\u9635\u6307\u9488 */; // \u521b\u5efa\u5168\u5c40\u5185\u5b58\u5f20\u91cf auto A_tensor = make_tensor(make_gmem_ptr(A_ptr), make_layout(make_shape(64, 64), GenRowMajor{})); auto B_tensor = make_tensor(make_gmem_ptr(B_ptr), make_layout(make_shape(64, 64), GenColMajor{})); auto C_tensor = make_tensor(make_gmem_ptr(C_ptr), make_layout(make_shape(64, 64), GenRowMajor{})); // \u83b7\u53d6 MMA \u5207\u7247 auto mma_thr = tiled_mma.get_thread_slice(threadIdx.x); // \u5206\u533a\u7d2f\u52a0\u5f20\u91cf auto C_frag = mma_thr.partition_C(C_tensor); auto acc_frag = make_fragment_like(C_frag); clear(acc_frag); // \u4e3b\u8ba1\u7b97\u5faa\u73af for (int k = 0; k < 64; k += 16) { // \u5206\u533a\u6e90\u5f20\u91cf auto A_frag = tiled_copy_a.partition_S(A_tensor(_, make_coord(k, k+16))); auto B_frag = tiled_copy_b.partition_S(B_tensor(_, make_coord(k, k+16))); // \u5206\u533a\u76ee\u6807\u5f20\u91cf auto smem_a_frag = tiled_copy_a.partition_D(smem_a_tensor); auto smem_b_frag = tiled_copy_b.partition_D(smem_b_tensor); // \u590d\u5236\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58 copy(tiled_copy_a, A_frag, smem_a_frag); copy(tiled_copy_b, B_frag, smem_b_frag); // \u540c\u6b65 __syncthreads(); // \u5206\u533a\u5171\u4eab\u5185\u5b58\u5f20\u91cf\u7528\u4e8e\u8ba1\u7b97 auto smem_a_mma = mma_thr.partition_A(smem_a_tensor); auto smem_b_mma = mma_thr.partition_B(smem_b_tensor); // \u6267\u884c MMA \u64cd\u4f5c gemm(tiled_mma, smem_a_mma, smem_b_mma, acc_frag); // \u540c\u6b65 __syncthreads(); } // \u5c06\u7ed3\u679c\u5199\u56de copy(acc_frag, C_frag); } \u6027\u80fd\u4f18\u5316\u6280\u5de7 \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u9700\u8981\u6ce8\u610f\u4ee5\u4e0b\u6027\u80fd\u4f18\u5316\u6280\u5de7\uff1a 1. \u5185\u5b58\u5bf9\u9f50 // \u786e\u4fdd\u6570\u636e\u5bf9\u9f50\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd alignas(128) float data[1024]; // 128 \u5b57\u8282\u5bf9\u9f50 2. \u5408\u7406\u7684\u5757\u5927\u5c0f\u9009\u62e9 // \u6839\u636e\u786c\u4ef6\u7279\u6027\u9009\u62e9\u5408\u9002\u7684\u5757\u5927\u5c0f constexpr int TILE_M = 128; // \u9002\u5e94 GPU \u7684 warp \u5927\u5c0f constexpr int TILE_N = 64; // \u5e73\u8861\u5bc4\u5b58\u5668\u4f7f\u7528\u548c\u5e76\u884c\u5ea6 constexpr int TILE_K = 16; // \u9002\u5e94 MMA \u6307\u4ee4\u7684\u8981\u6c42 3. \u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee // \u4f7f\u7528\u5408\u9002\u7684 Layout \u5b9e\u73b0\u5411\u91cf\u5316\u8bbf\u95ee auto vectorized_layout = make_layout(make_shape(32, 8), make_stride(8, 1)); // \u5b9e\u73b0 8 \u5143\u7d20\u5411\u91cf\u5316 \u8fd9\u4e9b\u793a\u4f8b\u5c55\u793a\u4e86 CuTe \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u7684\u5f3a\u5927\u529f\u80fd\u3002\u901a\u8fc7\u5408\u7406\u4f7f\u7528 CuTe \u7684\u5404\u79cd\u7ec4\u4ef6\uff0c\u53ef\u4ee5\u6784\u5efa\u51fa\u9ad8\u6027\u80fd\u3001\u53ef\u7ef4\u62a4\u7684 CUDA \u7a0b\u5e8f\u3002","title":"\u5b9e\u9645\u5e94\u7528\u793a\u4f8b"},{"location":"cute_examples/#cute","text":"\u901a\u8fc7\u5177\u4f53\u7684\u793a\u4f8b\u6765\u5c55\u793a\u5982\u4f55\u4f7f\u7528 CuTe \u6784\u5efa\u9ad8\u6027\u80fd\u7684 CUDA \u7a0b\u5e8f\u3002","title":"CuTe \u5b9e\u9645\u5e94\u7528\u793a\u4f8b"},{"location":"cute_examples/#copy","text":"\u4ee5\u4e0b\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 CuTe \u6267\u884c\u57fa\u672c\u7684 Copy \u64cd\u4f5c\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void copy_example() { // \u5b9a\u4e49\u6570\u636e\u6307\u9488 float *src_ptr = /* \u6e90\u6570\u636e\u6307\u9488 */; float *dst_ptr = /* \u76ee\u6807\u6570\u636e\u6307\u9488 */; // \u521b\u5efa Layout auto layout = make_layout(make_shape(32, 32), GenRowMajor{}); // \u521b\u5efa Tensor auto src_tensor = make_tensor(make_gmem_ptr(src_ptr), layout); auto dst_tensor = make_tensor(make_gmem_ptr(dst_ptr), layout); // \u6267\u884c Copy \u64cd\u4f5c copy(src_tensor, dst_tensor); }","title":"\u57fa\u672c Copy \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_examples/#_1","text":"\u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 CuTe \u5b9e\u73b0\u9ad8\u6548\u7684\u77e9\u9635\u8f6c\u7f6e\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void matrix_transpose() { // \u5b9a\u4e49\u77e9\u9635\u7ef4\u5ea6 constexpr int M = 64; constexpr int N = 64; // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *src_ptr = /* \u6e90\u77e9\u9635\u6307\u9488 */; float *dst_ptr = /* \u76ee\u6807\u77e9\u9635\u6307\u9488 */; // \u521b\u5efa\u6e90\u77e9\u9635 Tensor (\u884c\u4e3b\u5e8f) auto src_layout = make_layout(make_shape(M, N), GenRowMajor{}); auto src_tensor = make_tensor(make_gmem_ptr(src_ptr), src_layout); // \u521b\u5efa\u76ee\u6807\u77e9\u9635 Tensor (\u5217\u4e3b\u5e8f\uff0c\u5b9e\u73b0\u8f6c\u7f6e\u6548\u679c) auto dst_layout = make_layout(make_shape(M, N), GenColMajor{}); auto dst_tensor = make_tensor(make_gmem_ptr(dst_ptr), dst_layout); // \u6267\u884c Copy \u64cd\u4f5c\uff0c\u5b9e\u73b0\u8f6c\u7f6e copy(src_tensor, dst_tensor); }","title":"\u77e9\u9635\u8f6c\u7f6e\u793a\u4f8b"},{"location":"cute_examples/#tiledcopy","text":"\u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 TiledCopy \u5b9e\u73b0\u9ad8\u6548\u7684\u5757\u72b6\u590d\u5236\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void tiled_copy_example() { // \u5b9a\u4e49\u5757\u5927\u5c0f constexpr int BLK_M = 32; constexpr int BLK_N = 32; // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *src_ptr = /* \u6e90\u6570\u636e\u6307\u9488 */; float *dst_ptr = /* \u76ee\u6807\u6570\u636e\u6307\u9488 */; // \u521b\u5efa Layout auto layout = make_layout(make_shape(BLK_M, BLK_N), GenRowMajor{}); // \u521b\u5efa Tensor auto src_tensor = make_tensor(make_gmem_ptr(src_ptr), layout); auto dst_tensor = make_tensor(make_gmem_ptr(dst_ptr), layout); // \u521b\u5efa TiledCopy auto tiled_copy = make_tiled_copy(Copy_Atom<UniversalCopy<float>, float>{}, make_shape(BLK_M, BLK_N), make_shape(4, 8)); // 4x8 \u7ebf\u7a0b\u5757 // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto thr_copy = tiled_copy.get_thread_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto src_frag = thr_copy.partition_S(src_tensor); auto dst_frag = thr_copy.partition_D(dst_tensor); // \u6267\u884c\u590d\u5236 copy(src_frag, dst_frag); }","title":"\u4f7f\u7528 TiledCopy \u7684\u793a\u4f8b"},{"location":"cute_examples/#mma","text":"\u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 CuTe \u6267\u884c\u77e9\u9635\u4e58\u52a0\u64cd\u4f5c\u3002 #include <cute/tensor.hpp> using namespace cute; __global__ void mma_example() { // \u5b9a\u4e49\u77e9\u9635\u7ef4\u5ea6 constexpr int M = 16; constexpr int N = 16; constexpr int K = 8; // \u83b7\u53d6\u6570\u636e\u6307\u9488 half_t *A_ptr = /* A \u77e9\u9635\u6307\u9488 */; half_t *B_ptr = /* B \u77e9\u9635\u6307\u9488 */; float *C_ptr = /* C \u77e9\u9635\u6307\u9488 */; // \u521b\u5efa\u5f20\u91cf Layout auto A_layout = make_layout(make_shape(M, K), GenRowMajor{}); auto B_layout = make_layout(make_shape(N, K), GenColMajor{}); auto C_layout = make_layout(make_shape(M, N), GenRowMajor{}); // \u521b\u5efa\u5f20\u91cf auto A_tensor = make_tensor(make_gmem_ptr(A_ptr), A_layout); auto B_tensor = make_tensor(make_gmem_ptr(B_ptr), B_layout); auto C_tensor = make_tensor(make_gmem_ptr(C_ptr), C_layout); // \u521b\u5efa MMA \u64cd\u4f5c auto mma_atom = MMA_Atom<SM70_8x8x4_F32F16F16F32_NT>{}; // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto mma_thr = mma_atom.get_thread_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto A_frag = mma_thr.partition_A(A_tensor); auto B_frag = mma_thr.partition_B(B_tensor); auto C_frag = mma_thr.partition_C(C_tensor); // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto acc_frag = make_fragment_like(C_frag); clear(acc_frag); // \u6267\u884c MMA \u64cd\u4f5c mma_thr.mma(A_frag, B_frag, acc_frag, acc_frag); // \u5c06\u7ed3\u679c\u5199\u56de copy(acc_frag, C_frag); }","title":"MMA \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_examples/#tma-copy","text":"\u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u5982\u4f55\u5728 Hopper \u67b6\u6784\u4e0a\u4f7f\u7528 TMA \u8fdb\u884c\u9ad8\u6548\u7684\u5185\u5b58\u590d\u5236\u3002 #include <cute/tensor.hpp> using namespace cute; #if defined(CUTE_ARCH_TMA_SM90_ENABLED) __global__ void tma_copy_example() { // \u5b9a\u4e49\u77e9\u9635\u7ef4\u5ea6 constexpr int M = 512; constexpr int N = 512; // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *gmem_ptr = /* \u5168\u5c40\u5185\u5b58\u6307\u9488 */; extern __shared__ float smem[]; // \u521b\u5efa\u5168\u5c40\u5185\u5b58\u5f20\u91cf auto gmem_tensor = make_tensor(make_gmem_ptr(gmem_ptr), make_shape(M, N), GenRowMajor{}); // \u521b\u5efa\u5171\u4eab\u5185\u5b58 Layout auto smem_layout = tile_to_shape(GMMA::Layout_MN_SW128_Atom<float>{}, make_shape(64, 64)); // \u521b\u5efa\u5171\u4eab\u5185\u5b58\u5f20\u91cf auto smem_tensor = make_tensor(make_smem_ptr<float>(smem), smem_layout); // \u521b\u5efa TMA Copy \u5bf9\u8c61 auto tma_load = make_tma_copy(SM90_TMA_LOAD{}, gmem_tensor, smem_layout); // \u83b7\u53d6 TMA \u5f20\u91cf auto tma_tensor = tma_load.get_tma_tensor(make_shape(M, N)); // \u5206\u5757\u5904\u7406 auto tma_gmem = local_tile(tma_tensor, make_shape(64, 64), make_coord(blockIdx.x, blockIdx.y)); // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto thr_x = tma_load.get_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto tma_gmem_x = thr_x.partition_S(tma_gmem); auto tma_smem_x = thr_x.partition_D(smem_tensor); // \u540c\u6b65\u5bf9\u8c61 uint64_t bar; auto mbar = make_mbarrier(bar); // \u6267\u884c TMA \u52a0\u8f7d copy(tma_load.with(mbar), tma_gmem_x, tma_smem_x); // \u7b49\u5f85\u5b8c\u6210 tma_load.wait(mbar); } #endif","title":"TMA Copy \u793a\u4f8b"},{"location":"cute_examples/#gemm","text":"\u8fd9\u4e2a\u793a\u4f8b\u5c55\u793a\u4e86\u4e00\u4e2a\u5b8c\u6574\u7684 GEMM (General Matrix Multiply) \u5b9e\u73b0\u3002 #include <cute/tensor.hpp> using namespace cute; template <class TiledMMA, class TiledCopyA, class TiledCopyB> __global__ void gemm_example(TiledMMA tiled_mma, TiledCopyA tiled_copy_a, TiledCopyB tiled_copy_b) { // \u83b7\u53d6\u5171\u4eab\u5185\u5b58\u6307\u9488 extern __shared__ float smem[]; // \u5206\u914d\u5171\u4eab\u5185\u5b58\u7ed9 A \u548c B float *smem_a = smem; float *smem_b = smem + sizeof(float) * 64 * 16; // \u521b\u5efa\u5171\u4eab\u5185\u5b58\u5f20\u91cf auto smem_a_tensor = make_tensor(make_smem_ptr<float>(smem_a), make_layout(make_shape(64, 16), GenRowMajor{})); auto smem_b_tensor = make_tensor(make_smem_ptr<float>(smem_b), make_layout(make_shape(64, 16), GenRowMajor{})); // \u83b7\u53d6\u6570\u636e\u6307\u9488 float *A_ptr = /* A \u77e9\u9635\u6307\u9488 */; float *B_ptr = /* B \u77e9\u9635\u6307\u9488 */; float *C_ptr = /* C \u77e9\u9635\u6307\u9488 */; // \u521b\u5efa\u5168\u5c40\u5185\u5b58\u5f20\u91cf auto A_tensor = make_tensor(make_gmem_ptr(A_ptr), make_layout(make_shape(64, 64), GenRowMajor{})); auto B_tensor = make_tensor(make_gmem_ptr(B_ptr), make_layout(make_shape(64, 64), GenColMajor{})); auto C_tensor = make_tensor(make_gmem_ptr(C_ptr), make_layout(make_shape(64, 64), GenRowMajor{})); // \u83b7\u53d6 MMA \u5207\u7247 auto mma_thr = tiled_mma.get_thread_slice(threadIdx.x); // \u5206\u533a\u7d2f\u52a0\u5f20\u91cf auto C_frag = mma_thr.partition_C(C_tensor); auto acc_frag = make_fragment_like(C_frag); clear(acc_frag); // \u4e3b\u8ba1\u7b97\u5faa\u73af for (int k = 0; k < 64; k += 16) { // \u5206\u533a\u6e90\u5f20\u91cf auto A_frag = tiled_copy_a.partition_S(A_tensor(_, make_coord(k, k+16))); auto B_frag = tiled_copy_b.partition_S(B_tensor(_, make_coord(k, k+16))); // \u5206\u533a\u76ee\u6807\u5f20\u91cf auto smem_a_frag = tiled_copy_a.partition_D(smem_a_tensor); auto smem_b_frag = tiled_copy_b.partition_D(smem_b_tensor); // \u590d\u5236\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58 copy(tiled_copy_a, A_frag, smem_a_frag); copy(tiled_copy_b, B_frag, smem_b_frag); // \u540c\u6b65 __syncthreads(); // \u5206\u533a\u5171\u4eab\u5185\u5b58\u5f20\u91cf\u7528\u4e8e\u8ba1\u7b97 auto smem_a_mma = mma_thr.partition_A(smem_a_tensor); auto smem_b_mma = mma_thr.partition_B(smem_b_tensor); // \u6267\u884c MMA \u64cd\u4f5c gemm(tiled_mma, smem_a_mma, smem_b_mma, acc_frag); // \u540c\u6b65 __syncthreads(); } // \u5c06\u7ed3\u679c\u5199\u56de copy(acc_frag, C_frag); }","title":"\u590d\u5408\u793a\u4f8b\uff1aGEMM \u5b9e\u73b0"},{"location":"cute_examples/#_2","text":"\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u9700\u8981\u6ce8\u610f\u4ee5\u4e0b\u6027\u80fd\u4f18\u5316\u6280\u5de7\uff1a","title":"\u6027\u80fd\u4f18\u5316\u6280\u5de7"},{"location":"cute_examples/#1","text":"// \u786e\u4fdd\u6570\u636e\u5bf9\u9f50\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd alignas(128) float data[1024]; // 128 \u5b57\u8282\u5bf9\u9f50","title":"1. \u5185\u5b58\u5bf9\u9f50"},{"location":"cute_examples/#2","text":"// \u6839\u636e\u786c\u4ef6\u7279\u6027\u9009\u62e9\u5408\u9002\u7684\u5757\u5927\u5c0f constexpr int TILE_M = 128; // \u9002\u5e94 GPU \u7684 warp \u5927\u5c0f constexpr int TILE_N = 64; // \u5e73\u8861\u5bc4\u5b58\u5668\u4f7f\u7528\u548c\u5e76\u884c\u5ea6 constexpr int TILE_K = 16; // \u9002\u5e94 MMA \u6307\u4ee4\u7684\u8981\u6c42","title":"2. \u5408\u7406\u7684\u5757\u5927\u5c0f\u9009\u62e9"},{"location":"cute_examples/#3","text":"// \u4f7f\u7528\u5408\u9002\u7684 Layout \u5b9e\u73b0\u5411\u91cf\u5316\u8bbf\u95ee auto vectorized_layout = make_layout(make_shape(32, 8), make_stride(8, 1)); // \u5b9e\u73b0 8 \u5143\u7d20\u5411\u91cf\u5316 \u8fd9\u4e9b\u793a\u4f8b\u5c55\u793a\u4e86 CuTe \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u7684\u5f3a\u5927\u529f\u80fd\u3002\u901a\u8fc7\u5408\u7406\u4f7f\u7528 CuTe \u7684\u5404\u79cd\u7ec4\u4ef6\uff0c\u53ef\u4ee5\u6784\u5efa\u51fa\u9ad8\u6027\u80fd\u3001\u53ef\u7ef4\u62a4\u7684 CUDA \u7a0b\u5e8f\u3002","title":"3. \u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee"},{"location":"cute_layout/","text":"CuTe Layout \u5e03\u5c40\u7cfb\u7edf Layout \u662f CuTe \u7684\u6838\u5fc3\u6982\u5ff5\u4e4b\u4e00\uff0c\u5b83\u63cf\u8ff0\u4e86\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb\u3002\u901a\u8fc7 Layout\uff0cCuTe \u80fd\u591f\u5b9e\u73b0\u590d\u6742\u7684\u6570\u636e\u91cd\u6392\u548c\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u3002 Layout \u57fa\u672c\u6982\u5ff5 Layout \u5b9a\u4e49\u4e86\u4ece\u591a\u7ef4\u903b\u8f91\u5750\u6807\u5230\u4e00\u7ef4\u7ebf\u6027\u4f4d\u7f6e\uff08\u901a\u5e38\u4ee5\u4f4d\u6216\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u7684\u6620\u5c04\u3002\u5b83\u7531\u4e24\u4e2a\u4e3b\u8981\u90e8\u5206\u7ec4\u6210\uff1a Shape\uff08\u5f62\u72b6\uff09\uff1a\u63cf\u8ff0\u6bcf\u4e2a\u7ef4\u5ea6\u7684\u5927\u5c0f Stride\uff08\u6b65\u5e45\uff09\uff1a\u63cf\u8ff0\u6bcf\u4e2a\u7ef4\u5ea6\u7684\u8de8\u5ea6 Layout \u7684\u6570\u5b66\u8868\u793a Layout \u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u4e2a\u51fd\u6570\uff1a L(c) = sum(c[i] * stride[i]) for i in range(rank) \u5176\u4e2d c \u662f\u903b\u8f91\u5750\u6807\uff0cstride \u662f\u6b65\u5e45\u5411\u91cf\uff0cL(c) \u662f\u7ebf\u6027\u504f\u79fb\u91cf\u3002 Layout \u7684\u521b\u5efa Layout \u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u521b\u5efa\uff1a \u57fa\u672c Layout \u521b\u5efa // \u521b\u5efa\u4e00\u4e2a 2D \u884c\u4e3b\u5e8f Layout auto layout_2d = make_layout(make_shape(3, 4), GenRowMajor{}); // \u7b49\u4ef7\u4e8e make_layout(make_shape(3, 4), make_stride(4, 1)); // \u521b\u5efa\u4e00\u4e2a 2D \u5217\u4e3b\u5e8f Layout auto layout_2d_col = make_layout(make_shape(3, 4), GenColMajor{}); // \u7b49\u4ef7\u4e8e make_layout(make_shape(3, 4), make_stride(1, 3)); Layout \u7684\u7ec4\u5408 Layout \u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u7ec4\u5408\uff0c\u521b\u5efa\u66f4\u590d\u6742\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff1a // \u7ec4\u5408\u4e24\u4e2a Layout auto layout_combined = make_layout(make_shape(Shape<_2,_3>{}, Shape<_4,_5>{}), make_stride(Stride<_1,_6>{}, Stride<_2,_7>{})); Composed Layout\uff08\u7ec4\u5408\u5e03\u5c40\uff09 Composed Layout \u662f CuTe \u4e2d\u4e00\u79cd\u5f3a\u5927\u7684\u62bd\u8c61\uff0c\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u5e03\u5c40\u548c\u53d8\u6362\u6765\u5b9e\u73b0\u590d\u6742\u7684\u6570\u636e\u8f6c\u6362\u3002\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u7075\u6d3b\u7684\u65b9\u5f0f\u6765\u64cd\u4f5c\u5185\u5b58\u5e03\u5c40\u548c\u5750\u6807\u7cfb\u7edf\u3002 Composed Layout \u7684\u7ec4\u6210 Composed Layout \u7531\u4e09\u4e2a\u5173\u952e\u7ec4\u4ef6\u7ec4\u6210\uff1a \u5185\u90e8\u5e03\u5c40/\u53d8\u6362 \uff08inner\uff09\uff1a \u53ef\u4ee5\u662f\u5e03\u5c40\u3001\u4ea4\u6362\u64cd\u4f5c\uff08swizzle\uff09\u6216\u81ea\u5b9a\u4e49\u53d8\u6362\u51fd\u6570 \u5e94\u7528\u4e8e\u5750\u6807\u7684\u6700\u7ec8\u53d8\u6362 \u652f\u6301\u4efb\u610f\u7684\u5750\u6807\u64cd\u4f5c \u504f\u79fb\u91cf \uff08offset\uff09\uff1a \u901a\u5e38\u8868\u793a\u4e3a\u6574\u6570\u5143\u7ec4 \u5411\u5750\u6807\u6dfb\u52a0\u5e38\u91cf\u4f4d\u79fb \u5b9e\u73b0\u5bf9\u6570\u636e\u4f4d\u7f6e\u7684\u7cbe\u7ec6\u63a7\u5236 \u5916\u90e8\u5e03\u5c40 \uff08outer\uff09\uff1a \u7528\u6237\u53ef\u89c1\u7684\u5e03\u5c40 \u5b9a\u4e49\u521d\u59cb\u7684\u5750\u6807\u53d8\u6362 \u786e\u5b9a\u6570\u636e\u7ed3\u6784\u7684\u5f62\u72b6\u548c\u7ec4\u7ec7\u65b9\u5f0f Composed Layout \u7684\u6570\u5b66\u8868\u793a \u8fd9\u4e9b\u7ec4\u4ef6\u7684\u6570\u5b66\u7ec4\u5408\u5b9a\u4e49\u4e3a\uff1a R(c) := (inner \u2218 offset \u2218 outer)(c) := inner(offset + outer(c)) \u5176\u4e2d\uff1a - c \u4ee3\u8868\u8f93\u5165\u5750\u6807 - \u2218 \u8868\u793a\u51fd\u6570\u7ec4\u5408 - \u53d8\u6362\u4ece\u53f3\u5230\u5de6\u5e94\u7528 Composed Layout \u7684\u521b\u5efa \u5728 C++ \u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u521b\u5efa Composed Layout\uff1a // \u521b\u5efa\u4e00\u4e2a Composed Layout auto composed_layout = make_composed_layout(inner, offset, outer); \u5728 CuTe \u7684 GMMA \u64cd\u4f5c\u4e2d\uff0c\u7ecf\u5e38\u4f7f\u7528 Composed Layout \u6765\u63cf\u8ff0\u5171\u4eab\u5185\u5b58\u7684\u5e03\u5c40\uff0c\u7279\u522b\u662f\u5f53\u6d89\u53ca swizzle \u64cd\u4f5c\u65f6\uff1a // M|N-major GMMA layouts in units of bits using Layout_MN_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape< _128,_8>,Stride<_1, _128>>>; using Layout_MN_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape< _256,_8>,Stride<_1, _256>>>; using Layout_MN_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape< _512,_8>,Stride<_1, _512>>>; using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_1024,_8>,Stride<_1,_1024>>>; Composed Layout \u4e0e composition \u7684\u5173\u7cfb Composed Layout \u4e0e composition \u64cd\u4f5c\u5bc6\u5207\u76f8\u5173\uff0c\u4f46\u5b83\u4eec\u6709\u4e0d\u540c\u7684\u7528\u9014\u548c\u7279\u70b9\uff1a composition \u51fd\u6570 \uff1a composition \u662f CuTe \u4e2d\u7684\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u4e8e\u5c06\u4e24\u4e2a Layout \u8fdb\u884c\u7ec4\u5408 \u5b83\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Layout\uff0c\u8868\u793a\u4e24\u4e2a Layout \u7684\u51fd\u6570\u7ec4\u5408 \u8bed\u6cd5\uff1a composition(layoutA, layoutB) \u6216 layoutA.compose(layoutB) Composed Layout \uff1a Composed Layout \u662f\u4e00\u4e2a\u7279\u5b9a\u7684\u7c7b\u578b\uff0c\u7528\u4e8e\u8868\u793a\u65e0\u6cd5\u901a\u8fc7\u666e\u901a composition \u51fd\u6570\u7ec4\u5408\u7684\u5e03\u5c40 \u5b83\u4e13\u95e8\u7528\u4e8e\u5904\u7406\u5f53\"\u53ef\u9664\u6027\u6761\u4ef6\"\u4e0d\u6ee1\u8db3\u65f6\u7684\u60c5\u51b5 \u5b83\u7531\u4e09\u4e2a\u90e8\u5206\u7ec4\u6210\uff1ainner layout\u3001offset \u548c outer layout \u4e24\u8005\u5173\u7cfb \uff1a Composed Layout \u662f composition \u6982\u5ff5\u7684\u4e00\u79cd\u6269\u5c55\u5b9e\u73b0 \u5f53\u666e\u901a composition \u65e0\u6cd5\u5e94\u7528\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528 Composed Layout Composed Layout \u63d0\u4f9b\u4e86\u4e0e\u666e\u901a Layout \u7c7b\u4f3c\u7684\u529f\u80fd\uff0c\u5305\u62ec\u5207\u7247\u3001\u5206\u533a\u3001\u5750\u6807\u5230\u7d22\u5f15\u7684\u6620\u5c04\u7b49 \u793a\u4f8b\uff1a // \u4f7f\u7528 composition \u51fd\u6570\u7ec4\u5408\u4e24\u4e2a\u666e\u901a Layout auto layoutA = make_layout(make_shape(6, 2), make_stride(8, 2)); auto layoutB = make_layout(make_shape(4, 3), make_stride(3, 1)); auto result = composition(layoutA, layoutB); // \u7ed3\u679c\u662f\u4e00\u4e2a\u666e\u901a Layout // \u4f7f\u7528 Composed Layout \u5904\u7406\u66f4\u590d\u6742\u7684\u60c5\u51b5 auto swizzle = Swizzle<3,4,3>{}; auto offset = Int<0>{}; auto layout = make_layout(make_shape(1024, 8), make_stride(1, 1024)); auto composed = make_composed_layout(swizzle, offset, layout); Layout \u64cd\u4f5c CuTe \u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684 Layout \u64cd\u4f5c\u51fd\u6570\uff0c\u7528\u4e8e\u521b\u5efa\u3001\u8f6c\u6362\u548c\u7ec4\u5408 Layout\u3002 \u57fa\u672c\u64cd\u4f5c composition \uff1a\u7ec4\u5408\u4e24\u4e2a Layout complement \uff1a\u8ba1\u7b97 Layout \u7684\u8865\u96c6 compact \uff1a\u521b\u5efa\u7d27\u51d1\u7248\u672c\u7684 Layout coalesce \uff1a\u5408\u5e76\u8fde\u7eed\u7684\u7ef4\u5ea6 flatten \uff1a\u5c55\u5e73 Layout Layout \u7ec4\u5408\u793a\u4f8b // \u521b\u5efa\u4e24\u4e2a Layout auto layout_a = make_layout(make_shape(2, 3), make_stride(1, 2)); auto layout_b = make_layout(make_shape(6, 1), make_stride(1, 0)); // \u7ec4\u5408 Layout auto composed_layout = composition(layout_a, layout_b); Layout \u5728 Tensor \u4e2d\u7684\u5e94\u7528 Layout \u4e0e Tensor \u7d27\u5bc6\u7ed3\u5408\uff0c\u5b9a\u4e49\u4e86 Tensor \u6570\u636e\u5728\u5185\u5b58\u4e2d\u7684\u5b58\u50a8\u65b9\u5f0f\u3002 // \u521b\u5efa\u4e00\u4e2a\u5e26\u6709\u7279\u5b9a Layout \u7684 Tensor auto tensor = make_tensor(make_gmem_ptr<float>(ptr), make_layout(make_shape(16, 32), GenRowMajor{})); Layout \u7684\u7c7b\u578b CuTe \u63d0\u4f9b\u4e86\u591a\u79cd\u9884\u5b9a\u4e49\u7684 Layout \u7c7b\u578b\uff1a \u57fa\u672c Layout \u7c7b\u578b Layout \uff1a\u57fa\u672c\u7684 Layout \u7c7b\u578b\uff0c\u7531 Shape \u548c Stride \u7ec4\u6210\uff0c\u7528\u4e8e\u63cf\u8ff0\u4efb\u610f\u7ef4\u5ea6\u7684\u6570\u636e\u5e03\u5c40 LogicalLayout \uff1a\u903b\u8f91 Layout\uff0c\u7528\u4e8e\u63cf\u8ff0\u903b\u8f91\u5750\u6807\u7a7a\u95f4\u7684\u5e03\u5c40\uff0c\u4e0d\u76f4\u63a5\u5173\u8054\u7269\u7406\u5185\u5b58\u5730\u5740 PhysicalLayout \uff1a\u7269\u7406 Layout\uff0c\u7528\u4e8e\u63cf\u8ff0\u7269\u7406\u5185\u5b58\u4e2d\u7684\u5b9e\u9645\u5e03\u5c40\uff0c\u4e0e\u5177\u4f53\u7684\u5185\u5b58\u5730\u5740\u76f8\u5173\u8054 \u7279\u6b8a Layout GenRowMajor \uff1a\u751f\u6210\u884c\u4e3b\u5e8f Layout\uff0c\u521b\u5efa\u6309\u884c\u4f18\u5148\u987a\u5e8f\u6392\u5217\u7684\u5185\u5b58\u5e03\u5c40 GenColMajor \uff1a\u751f\u6210\u5217\u4e3b\u5e8f Layout\uff0c\u521b\u5efa\u6309\u5217\u4f18\u5148\u987a\u5e8f\u6392\u5217\u7684\u5185\u5b58\u5e03\u5c40 Swizzle \uff1a\u5185\u5b58\u4ea4\u6362 Layout\uff0c\u7528\u4e8e\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u5b9e\u73b0\u7279\u5b9a\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u4ee5\u4f18\u5316\u6027\u80fd Layout \u7684\u5c5e\u6027 Layout \u5177\u6709\u591a\u79cd\u5c5e\u6027\uff0c\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570\u83b7\u53d6\uff1a \u57fa\u672c\u5c5e\u6027 rank \uff1aLayout \u7684\u7ef4\u5ea6\u6570 size \uff1aLayout \u8986\u76d6\u7684\u5143\u7d20\u603b\u6570 cosize \uff1aLayout \u7684\u5171\u5927\u5c0f \u793a\u4f8b auto layout = make_layout(make_shape(3, 4), make_stride(4, 1)); // \u83b7\u53d6 Layout \u5c5e\u6027 auto layout_rank = rank(layout); // \u8fd4\u56de 2 auto layout_size = size(layout); // \u8fd4\u56de 12 Layout \u7684\u8f6c\u6362 Layout \u53ef\u4ee5\u8fdb\u884c\u591a\u79cd\u8f6c\u6362\u64cd\u4f5c\uff1a \u5e38\u89c1\u8f6c\u6362 recast \uff1a\u91cd\u65b0\u89e3\u91ca Layout \u7684\u5143\u7d20\u7c7b\u578b right_inverse \uff1a\u8ba1\u7b97 Layout \u7684\u53f3\u9006 left_inverse \uff1a\u8ba1\u7b97 Layout \u7684\u5de6\u9006 zip \uff1a\u538b\u7f29\u591a\u4e2a Layout Layout \u8f6c\u6362\u793a\u4f8b // \u521b\u5efa\u4e00\u4e2a Layout auto layout = make_layout(make_shape(4, 4), make_stride(1, 4)); // \u8ba1\u7b97\u53f3\u9006 auto inv_layout = right_inverse(layout); Layout \u7684\u5b9e\u9645\u5e94\u7528 Layout \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u53d1\u6325\u7740\u91cd\u8981\u4f5c\u7528\uff1a \u5185\u5b58\u8bbf\u95ee\u4f18\u5316 \u901a\u8fc7\u5408\u7406\u8bbe\u8ba1 Layout\uff0c\u53ef\u4ee5\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u63d0\u9ad8\u7f13\u5b58\u547d\u4e2d\u7387\u548c\u5185\u5b58\u5e26\u5bbd\u5229\u7528\u7387\u3002 \u6570\u636e\u91cd\u6392 Layout \u53ef\u4ee5\u5b9e\u73b0\u590d\u6742\u7684\u6570\u636e\u91cd\u6392\u64cd\u4f5c\uff0c\u5982\u77e9\u9635\u8f6c\u7f6e\u3001\u5206\u5757\u7b49\u3002 \u786c\u4ef6\u9002\u914d Layout \u53ef\u4ee5\u9002\u914d\u4e0d\u540c\u7684\u786c\u4ef6\u7279\u6027\uff0c\u5982\u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\u3001\u5171\u4eab\u5185\u5b58\u4ea4\u6362\u7b49\u3002 Layout \u4e0e Copy \u64cd\u4f5c Layout \u5728 Copy \u64cd\u4f5c\u4e2d\u8d77\u7740\u5173\u952e\u4f5c\u7528\uff0c\u5b83\u5b9a\u4e49\u4e86\u6e90\u548c\u76ee\u6807\u6570\u636e\u7684\u5185\u5b58\u5e03\u5c40\u3002 // \u5b9a\u4e49\u6e90 Layout \u548c\u76ee\u6807 Layout auto src_layout = make_layout(make_shape(16, 16), GenRowMajor{}); auto dst_layout = make_layout(make_shape(16, 16), GenColMajor{}); // \u521b\u5efa Tensors auto src_tensor = make_tensor(src_ptr, src_layout); auto dst_tensor = make_tensor(dst_ptr, dst_layout); // \u6267\u884c Copy \u64cd\u4f5c\uff08\u5305\u542b\u8f6c\u7f6e\uff09 copy(src_tensor, dst_tensor); Layout \u4e0e MMA \u64cd\u4f5c \u5728 MMA (Matrix Multiply-Accumulate) \u64cd\u4f5c\u4e2d\uff0cLayout \u5b9a\u4e49\u4e86\u77e9\u9635\u5143\u7d20\u5728\u5bc4\u5b58\u5668\u548c\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u3002 // \u5b9a\u4e49 MMA \u64cd\u4f5c\u76f8\u5173\u7684 Layout using MMA_LAYOUT = Layout<Shape<_2,_2>, Stride<_1,_2>>; // \u4f7f\u7528 Layout \u521b\u5efa MMA \u64cd\u4f5c auto mma_layout = MMA_LAYOUT{}; Layout \u662f CuTe \u7cfb\u7edf\u4e2d\u7684\u6838\u5fc3\u62bd\u8c61\u4e4b\u4e00\uff0c\u901a\u8fc7\u5b83\u5b9e\u73b0\u4e86\u5bf9\u590d\u6742\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u7684\u7075\u6d3b\u63a7\u5236\uff0c\u4e3a\u9ad8\u6027\u80fd\u8ba1\u7b97\u63d0\u4f9b\u4e86\u57fa\u7840\u652f\u6301\u3002","title":"Layout \u5e03\u5c40\u7cfb\u7edf"},{"location":"cute_layout/#cute-layout","text":"Layout \u662f CuTe \u7684\u6838\u5fc3\u6982\u5ff5\u4e4b\u4e00\uff0c\u5b83\u63cf\u8ff0\u4e86\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb\u3002\u901a\u8fc7 Layout\uff0cCuTe \u80fd\u591f\u5b9e\u73b0\u590d\u6742\u7684\u6570\u636e\u91cd\u6392\u548c\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u3002","title":"CuTe Layout \u5e03\u5c40\u7cfb\u7edf"},{"location":"cute_layout/#layout","text":"Layout \u5b9a\u4e49\u4e86\u4ece\u591a\u7ef4\u903b\u8f91\u5750\u6807\u5230\u4e00\u7ef4\u7ebf\u6027\u4f4d\u7f6e\uff08\u901a\u5e38\u4ee5\u4f4d\u6216\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u7684\u6620\u5c04\u3002\u5b83\u7531\u4e24\u4e2a\u4e3b\u8981\u90e8\u5206\u7ec4\u6210\uff1a Shape\uff08\u5f62\u72b6\uff09\uff1a\u63cf\u8ff0\u6bcf\u4e2a\u7ef4\u5ea6\u7684\u5927\u5c0f Stride\uff08\u6b65\u5e45\uff09\uff1a\u63cf\u8ff0\u6bcf\u4e2a\u7ef4\u5ea6\u7684\u8de8\u5ea6","title":"Layout \u57fa\u672c\u6982\u5ff5"},{"location":"cute_layout/#layout_1","text":"Layout \u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u4e2a\u51fd\u6570\uff1a L(c) = sum(c[i] * stride[i]) for i in range(rank) \u5176\u4e2d c \u662f\u903b\u8f91\u5750\u6807\uff0cstride \u662f\u6b65\u5e45\u5411\u91cf\uff0cL(c) \u662f\u7ebf\u6027\u504f\u79fb\u91cf\u3002","title":"Layout \u7684\u6570\u5b66\u8868\u793a"},{"location":"cute_layout/#layout_2","text":"Layout \u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u521b\u5efa\uff1a","title":"Layout \u7684\u521b\u5efa"},{"location":"cute_layout/#layout_3","text":"// \u521b\u5efa\u4e00\u4e2a 2D \u884c\u4e3b\u5e8f Layout auto layout_2d = make_layout(make_shape(3, 4), GenRowMajor{}); // \u7b49\u4ef7\u4e8e make_layout(make_shape(3, 4), make_stride(4, 1)); // \u521b\u5efa\u4e00\u4e2a 2D \u5217\u4e3b\u5e8f Layout auto layout_2d_col = make_layout(make_shape(3, 4), GenColMajor{}); // \u7b49\u4ef7\u4e8e make_layout(make_shape(3, 4), make_stride(1, 3));","title":"\u57fa\u672c Layout \u521b\u5efa"},{"location":"cute_layout/#layout_4","text":"Layout \u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u7ec4\u5408\uff0c\u521b\u5efa\u66f4\u590d\u6742\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff1a // \u7ec4\u5408\u4e24\u4e2a Layout auto layout_combined = make_layout(make_shape(Shape<_2,_3>{}, Shape<_4,_5>{}), make_stride(Stride<_1,_6>{}, Stride<_2,_7>{}));","title":"Layout \u7684\u7ec4\u5408"},{"location":"cute_layout/#composed-layout","text":"Composed Layout \u662f CuTe \u4e2d\u4e00\u79cd\u5f3a\u5927\u7684\u62bd\u8c61\uff0c\u5b83\u901a\u8fc7\u7ec4\u5408\u591a\u4e2a\u5e03\u5c40\u548c\u53d8\u6362\u6765\u5b9e\u73b0\u590d\u6742\u7684\u6570\u636e\u8f6c\u6362\u3002\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u7075\u6d3b\u7684\u65b9\u5f0f\u6765\u64cd\u4f5c\u5185\u5b58\u5e03\u5c40\u548c\u5750\u6807\u7cfb\u7edf\u3002","title":"Composed Layout\uff08\u7ec4\u5408\u5e03\u5c40\uff09"},{"location":"cute_layout/#composed-layout_1","text":"Composed Layout \u7531\u4e09\u4e2a\u5173\u952e\u7ec4\u4ef6\u7ec4\u6210\uff1a \u5185\u90e8\u5e03\u5c40/\u53d8\u6362 \uff08inner\uff09\uff1a \u53ef\u4ee5\u662f\u5e03\u5c40\u3001\u4ea4\u6362\u64cd\u4f5c\uff08swizzle\uff09\u6216\u81ea\u5b9a\u4e49\u53d8\u6362\u51fd\u6570 \u5e94\u7528\u4e8e\u5750\u6807\u7684\u6700\u7ec8\u53d8\u6362 \u652f\u6301\u4efb\u610f\u7684\u5750\u6807\u64cd\u4f5c \u504f\u79fb\u91cf \uff08offset\uff09\uff1a \u901a\u5e38\u8868\u793a\u4e3a\u6574\u6570\u5143\u7ec4 \u5411\u5750\u6807\u6dfb\u52a0\u5e38\u91cf\u4f4d\u79fb \u5b9e\u73b0\u5bf9\u6570\u636e\u4f4d\u7f6e\u7684\u7cbe\u7ec6\u63a7\u5236 \u5916\u90e8\u5e03\u5c40 \uff08outer\uff09\uff1a \u7528\u6237\u53ef\u89c1\u7684\u5e03\u5c40 \u5b9a\u4e49\u521d\u59cb\u7684\u5750\u6807\u53d8\u6362 \u786e\u5b9a\u6570\u636e\u7ed3\u6784\u7684\u5f62\u72b6\u548c\u7ec4\u7ec7\u65b9\u5f0f","title":"Composed Layout \u7684\u7ec4\u6210"},{"location":"cute_layout/#composed-layout_2","text":"\u8fd9\u4e9b\u7ec4\u4ef6\u7684\u6570\u5b66\u7ec4\u5408\u5b9a\u4e49\u4e3a\uff1a R(c) := (inner \u2218 offset \u2218 outer)(c) := inner(offset + outer(c)) \u5176\u4e2d\uff1a - c \u4ee3\u8868\u8f93\u5165\u5750\u6807 - \u2218 \u8868\u793a\u51fd\u6570\u7ec4\u5408 - \u53d8\u6362\u4ece\u53f3\u5230\u5de6\u5e94\u7528","title":"Composed Layout \u7684\u6570\u5b66\u8868\u793a"},{"location":"cute_layout/#composed-layout_3","text":"\u5728 C++ \u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u521b\u5efa Composed Layout\uff1a // \u521b\u5efa\u4e00\u4e2a Composed Layout auto composed_layout = make_composed_layout(inner, offset, outer); \u5728 CuTe \u7684 GMMA \u64cd\u4f5c\u4e2d\uff0c\u7ecf\u5e38\u4f7f\u7528 Composed Layout \u6765\u63cf\u8ff0\u5171\u4eab\u5185\u5b58\u7684\u5e03\u5c40\uff0c\u7279\u522b\u662f\u5f53\u6d89\u53ca swizzle \u64cd\u4f5c\u65f6\uff1a // M|N-major GMMA layouts in units of bits using Layout_MN_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape< _128,_8>,Stride<_1, _128>>>; using Layout_MN_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape< _256,_8>,Stride<_1, _256>>>; using Layout_MN_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape< _512,_8>,Stride<_1, _512>>>; using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_1024,_8>,Stride<_1,_1024>>>;","title":"Composed Layout \u7684\u521b\u5efa"},{"location":"cute_layout/#composed-layout-composition","text":"Composed Layout \u4e0e composition \u64cd\u4f5c\u5bc6\u5207\u76f8\u5173\uff0c\u4f46\u5b83\u4eec\u6709\u4e0d\u540c\u7684\u7528\u9014\u548c\u7279\u70b9\uff1a composition \u51fd\u6570 \uff1a composition \u662f CuTe \u4e2d\u7684\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u4e8e\u5c06\u4e24\u4e2a Layout \u8fdb\u884c\u7ec4\u5408 \u5b83\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Layout\uff0c\u8868\u793a\u4e24\u4e2a Layout \u7684\u51fd\u6570\u7ec4\u5408 \u8bed\u6cd5\uff1a composition(layoutA, layoutB) \u6216 layoutA.compose(layoutB) Composed Layout \uff1a Composed Layout \u662f\u4e00\u4e2a\u7279\u5b9a\u7684\u7c7b\u578b\uff0c\u7528\u4e8e\u8868\u793a\u65e0\u6cd5\u901a\u8fc7\u666e\u901a composition \u51fd\u6570\u7ec4\u5408\u7684\u5e03\u5c40 \u5b83\u4e13\u95e8\u7528\u4e8e\u5904\u7406\u5f53\"\u53ef\u9664\u6027\u6761\u4ef6\"\u4e0d\u6ee1\u8db3\u65f6\u7684\u60c5\u51b5 \u5b83\u7531\u4e09\u4e2a\u90e8\u5206\u7ec4\u6210\uff1ainner layout\u3001offset \u548c outer layout \u4e24\u8005\u5173\u7cfb \uff1a Composed Layout \u662f composition \u6982\u5ff5\u7684\u4e00\u79cd\u6269\u5c55\u5b9e\u73b0 \u5f53\u666e\u901a composition \u65e0\u6cd5\u5e94\u7528\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528 Composed Layout Composed Layout \u63d0\u4f9b\u4e86\u4e0e\u666e\u901a Layout \u7c7b\u4f3c\u7684\u529f\u80fd\uff0c\u5305\u62ec\u5207\u7247\u3001\u5206\u533a\u3001\u5750\u6807\u5230\u7d22\u5f15\u7684\u6620\u5c04\u7b49 \u793a\u4f8b\uff1a // \u4f7f\u7528 composition \u51fd\u6570\u7ec4\u5408\u4e24\u4e2a\u666e\u901a Layout auto layoutA = make_layout(make_shape(6, 2), make_stride(8, 2)); auto layoutB = make_layout(make_shape(4, 3), make_stride(3, 1)); auto result = composition(layoutA, layoutB); // \u7ed3\u679c\u662f\u4e00\u4e2a\u666e\u901a Layout // \u4f7f\u7528 Composed Layout \u5904\u7406\u66f4\u590d\u6742\u7684\u60c5\u51b5 auto swizzle = Swizzle<3,4,3>{}; auto offset = Int<0>{}; auto layout = make_layout(make_shape(1024, 8), make_stride(1, 1024)); auto composed = make_composed_layout(swizzle, offset, layout);","title":"Composed Layout \u4e0e composition \u7684\u5173\u7cfb"},{"location":"cute_layout/#layout_5","text":"CuTe \u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684 Layout \u64cd\u4f5c\u51fd\u6570\uff0c\u7528\u4e8e\u521b\u5efa\u3001\u8f6c\u6362\u548c\u7ec4\u5408 Layout\u3002","title":"Layout \u64cd\u4f5c"},{"location":"cute_layout/#_1","text":"composition \uff1a\u7ec4\u5408\u4e24\u4e2a Layout complement \uff1a\u8ba1\u7b97 Layout \u7684\u8865\u96c6 compact \uff1a\u521b\u5efa\u7d27\u51d1\u7248\u672c\u7684 Layout coalesce \uff1a\u5408\u5e76\u8fde\u7eed\u7684\u7ef4\u5ea6 flatten \uff1a\u5c55\u5e73 Layout","title":"\u57fa\u672c\u64cd\u4f5c"},{"location":"cute_layout/#layout_6","text":"// \u521b\u5efa\u4e24\u4e2a Layout auto layout_a = make_layout(make_shape(2, 3), make_stride(1, 2)); auto layout_b = make_layout(make_shape(6, 1), make_stride(1, 0)); // \u7ec4\u5408 Layout auto composed_layout = composition(layout_a, layout_b);","title":"Layout \u7ec4\u5408\u793a\u4f8b"},{"location":"cute_layout/#layout-tensor","text":"Layout \u4e0e Tensor \u7d27\u5bc6\u7ed3\u5408\uff0c\u5b9a\u4e49\u4e86 Tensor \u6570\u636e\u5728\u5185\u5b58\u4e2d\u7684\u5b58\u50a8\u65b9\u5f0f\u3002 // \u521b\u5efa\u4e00\u4e2a\u5e26\u6709\u7279\u5b9a Layout \u7684 Tensor auto tensor = make_tensor(make_gmem_ptr<float>(ptr), make_layout(make_shape(16, 32), GenRowMajor{}));","title":"Layout \u5728 Tensor \u4e2d\u7684\u5e94\u7528"},{"location":"cute_layout/#layout_7","text":"CuTe \u63d0\u4f9b\u4e86\u591a\u79cd\u9884\u5b9a\u4e49\u7684 Layout \u7c7b\u578b\uff1a","title":"Layout \u7684\u7c7b\u578b"},{"location":"cute_layout/#layout_8","text":"Layout \uff1a\u57fa\u672c\u7684 Layout \u7c7b\u578b\uff0c\u7531 Shape \u548c Stride \u7ec4\u6210\uff0c\u7528\u4e8e\u63cf\u8ff0\u4efb\u610f\u7ef4\u5ea6\u7684\u6570\u636e\u5e03\u5c40 LogicalLayout \uff1a\u903b\u8f91 Layout\uff0c\u7528\u4e8e\u63cf\u8ff0\u903b\u8f91\u5750\u6807\u7a7a\u95f4\u7684\u5e03\u5c40\uff0c\u4e0d\u76f4\u63a5\u5173\u8054\u7269\u7406\u5185\u5b58\u5730\u5740 PhysicalLayout \uff1a\u7269\u7406 Layout\uff0c\u7528\u4e8e\u63cf\u8ff0\u7269\u7406\u5185\u5b58\u4e2d\u7684\u5b9e\u9645\u5e03\u5c40\uff0c\u4e0e\u5177\u4f53\u7684\u5185\u5b58\u5730\u5740\u76f8\u5173\u8054","title":"\u57fa\u672c Layout \u7c7b\u578b"},{"location":"cute_layout/#layout_9","text":"GenRowMajor \uff1a\u751f\u6210\u884c\u4e3b\u5e8f Layout\uff0c\u521b\u5efa\u6309\u884c\u4f18\u5148\u987a\u5e8f\u6392\u5217\u7684\u5185\u5b58\u5e03\u5c40 GenColMajor \uff1a\u751f\u6210\u5217\u4e3b\u5e8f Layout\uff0c\u521b\u5efa\u6309\u5217\u4f18\u5148\u987a\u5e8f\u6392\u5217\u7684\u5185\u5b58\u5e03\u5c40 Swizzle \uff1a\u5185\u5b58\u4ea4\u6362 Layout\uff0c\u7528\u4e8e\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u5b9e\u73b0\u7279\u5b9a\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u4ee5\u4f18\u5316\u6027\u80fd","title":"\u7279\u6b8a Layout"},{"location":"cute_layout/#layout_10","text":"Layout \u5177\u6709\u591a\u79cd\u5c5e\u6027\uff0c\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570\u83b7\u53d6\uff1a","title":"Layout \u7684\u5c5e\u6027"},{"location":"cute_layout/#_2","text":"rank \uff1aLayout \u7684\u7ef4\u5ea6\u6570 size \uff1aLayout \u8986\u76d6\u7684\u5143\u7d20\u603b\u6570 cosize \uff1aLayout \u7684\u5171\u5927\u5c0f","title":"\u57fa\u672c\u5c5e\u6027"},{"location":"cute_layout/#_3","text":"auto layout = make_layout(make_shape(3, 4), make_stride(4, 1)); // \u83b7\u53d6 Layout \u5c5e\u6027 auto layout_rank = rank(layout); // \u8fd4\u56de 2 auto layout_size = size(layout); // \u8fd4\u56de 12","title":"\u793a\u4f8b"},{"location":"cute_layout/#layout_11","text":"Layout \u53ef\u4ee5\u8fdb\u884c\u591a\u79cd\u8f6c\u6362\u64cd\u4f5c\uff1a","title":"Layout \u7684\u8f6c\u6362"},{"location":"cute_layout/#_4","text":"recast \uff1a\u91cd\u65b0\u89e3\u91ca Layout \u7684\u5143\u7d20\u7c7b\u578b right_inverse \uff1a\u8ba1\u7b97 Layout \u7684\u53f3\u9006 left_inverse \uff1a\u8ba1\u7b97 Layout \u7684\u5de6\u9006 zip \uff1a\u538b\u7f29\u591a\u4e2a Layout","title":"\u5e38\u89c1\u8f6c\u6362"},{"location":"cute_layout/#layout_12","text":"// \u521b\u5efa\u4e00\u4e2a Layout auto layout = make_layout(make_shape(4, 4), make_stride(1, 4)); // \u8ba1\u7b97\u53f3\u9006 auto inv_layout = right_inverse(layout);","title":"Layout \u8f6c\u6362\u793a\u4f8b"},{"location":"cute_layout/#layout_13","text":"Layout \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u53d1\u6325\u7740\u91cd\u8981\u4f5c\u7528\uff1a","title":"Layout \u7684\u5b9e\u9645\u5e94\u7528"},{"location":"cute_layout/#_5","text":"\u901a\u8fc7\u5408\u7406\u8bbe\u8ba1 Layout\uff0c\u53ef\u4ee5\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u63d0\u9ad8\u7f13\u5b58\u547d\u4e2d\u7387\u548c\u5185\u5b58\u5e26\u5bbd\u5229\u7528\u7387\u3002","title":"\u5185\u5b58\u8bbf\u95ee\u4f18\u5316"},{"location":"cute_layout/#_6","text":"Layout \u53ef\u4ee5\u5b9e\u73b0\u590d\u6742\u7684\u6570\u636e\u91cd\u6392\u64cd\u4f5c\uff0c\u5982\u77e9\u9635\u8f6c\u7f6e\u3001\u5206\u5757\u7b49\u3002","title":"\u6570\u636e\u91cd\u6392"},{"location":"cute_layout/#_7","text":"Layout \u53ef\u4ee5\u9002\u914d\u4e0d\u540c\u7684\u786c\u4ef6\u7279\u6027\uff0c\u5982\u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\u3001\u5171\u4eab\u5185\u5b58\u4ea4\u6362\u7b49\u3002","title":"\u786c\u4ef6\u9002\u914d"},{"location":"cute_layout/#layout-copy","text":"Layout \u5728 Copy \u64cd\u4f5c\u4e2d\u8d77\u7740\u5173\u952e\u4f5c\u7528\uff0c\u5b83\u5b9a\u4e49\u4e86\u6e90\u548c\u76ee\u6807\u6570\u636e\u7684\u5185\u5b58\u5e03\u5c40\u3002 // \u5b9a\u4e49\u6e90 Layout \u548c\u76ee\u6807 Layout auto src_layout = make_layout(make_shape(16, 16), GenRowMajor{}); auto dst_layout = make_layout(make_shape(16, 16), GenColMajor{}); // \u521b\u5efa Tensors auto src_tensor = make_tensor(src_ptr, src_layout); auto dst_tensor = make_tensor(dst_ptr, dst_layout); // \u6267\u884c Copy \u64cd\u4f5c\uff08\u5305\u542b\u8f6c\u7f6e\uff09 copy(src_tensor, dst_tensor);","title":"Layout \u4e0e Copy \u64cd\u4f5c"},{"location":"cute_layout/#layout-mma","text":"\u5728 MMA (Matrix Multiply-Accumulate) \u64cd\u4f5c\u4e2d\uff0cLayout \u5b9a\u4e49\u4e86\u77e9\u9635\u5143\u7d20\u5728\u5bc4\u5b58\u5668\u548c\u5185\u5b58\u4e2d\u7684\u5e03\u5c40\u3002 // \u5b9a\u4e49 MMA \u64cd\u4f5c\u76f8\u5173\u7684 Layout using MMA_LAYOUT = Layout<Shape<_2,_2>, Stride<_1,_2>>; // \u4f7f\u7528 Layout \u521b\u5efa MMA \u64cd\u4f5c auto mma_layout = MMA_LAYOUT{}; Layout \u662f CuTe \u7cfb\u7edf\u4e2d\u7684\u6838\u5fc3\u62bd\u8c61\u4e4b\u4e00\uff0c\u901a\u8fc7\u5b83\u5b9e\u73b0\u4e86\u5bf9\u590d\u6742\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u7684\u7075\u6d3b\u63a7\u5236\uff0c\u4e3a\u9ad8\u6027\u80fd\u8ba1\u7b97\u63d0\u4f9b\u4e86\u57fa\u7840\u652f\u6301\u3002","title":"Layout \u4e0e MMA \u64cd\u4f5c"},{"location":"cute_mma/","text":"CuTe MMA (Matrix Multiply-Accumulate) \u64cd\u4f5c MMA (Matrix Multiply-Accumulate) \u662f CuTe \u4e2d\u7528\u4e8e\u6267\u884c\u77e9\u9635\u4e58\u52a0\u8fd0\u7b97\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002\u5728\u6df1\u5ea6\u5b66\u4e60\u548c\u79d1\u5b66\u8ba1\u7b97\u4e2d\uff0cMMA \u64cd\u4f5c\u662f\u6700\u5173\u952e\u7684\u8ba1\u7b97\u4e4b\u4e00\u3002 MMA \u57fa\u672c\u6982\u5ff5 MMA \u64cd\u4f5c\u6267\u884c\u4ee5\u4e0b\u8ba1\u7b97\uff1a D = A * B + C \u5176\u4e2d A\u3001B \u662f\u8f93\u5165\u77e9\u9635\uff0cC \u662f\u7d2f\u52a0\u77e9\u9635\uff0cD \u662f\u8f93\u51fa\u77e9\u9635\u3002 \u5728 CuTe \u4e2d\uff0cMMA \u64cd\u4f5c\u88ab\u9ad8\u5ea6\u62bd\u8c61\u5316\uff0c\u5141\u8bb8\u5f00\u53d1\u8005\uff1a \u4f7f\u7528\u4e0d\u540c\u7cbe\u5ea6\u7684\u6570\u636e\u7c7b\u578b \u5229\u7528\u4e13\u95e8\u7684\u786c\u4ef6\u6307\u4ee4\uff08\u5982 Tensor Cores\uff09 \u9002\u5e94\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40 \u4e0e\u7ebf\u7a0b\u534f\u4f5c\u8fdb\u884c\u5927\u89c4\u6a21\u8ba1\u7b97 CuTe MMA \u62bd\u8c61\u5c42\u6b21 CuTe \u5bf9 MMA \u64cd\u4f5c\u8fdb\u884c\u4e86\u591a\u5c42\u62bd\u8c61\uff0c\u4ece\u5e95\u5c42\u786c\u4ef6\u6307\u4ee4\u5230\u9ad8\u7ea7\u63a5\u53e3\uff1a 1. Operation \u7ed3\u6784\u4f53 Operation \u7ed3\u6784\u4f53\u5c01\u88c5\u4e86\u7279\u5b9a\u7684 PTX \u6307\u4ee4\u3002\u5b83\u5b9a\u4e49\u4e86\u6307\u4ee4\u6240\u9700\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u5b9e\u9645\u7684 fma \u51fd\u6570\u5b9e\u73b0\u3002 \u8bbe\u8ba1\u539f\u56e0\uff1a \u5c06\u5e95\u5c42\u786c\u4ef6\u6307\u4ee4\u5c01\u88c5\u5728\u7edf\u4e00\u63a5\u53e3\u4e0b\uff0c\u9690\u85cf\u786c\u4ef6\u5dee\u5f02 \u660e\u786e\u5b9a\u4e49\u5bc4\u5b58\u5668\u4f7f\u7528\u6a21\u5f0f\uff0c\u4fbf\u4e8e\u7f16\u8bd1\u5668\u4f18\u5316 \u63d0\u4f9b\u7c7b\u578b\u5b89\u5168\u7684\u63a5\u53e3\uff0c\u9632\u6b62\u5bc4\u5b58\u5668\u7c7b\u578b\u9519\u8bef \u4f8b\u5982\uff0c SM70_8x8x4_F32F16F16F32_NT \u5b9a\u4e49\u4e86 Volta \u67b6\u6784\u4e0a\u7684\u4e00\u4e2a MMA \u64cd\u4f5c\uff1a struct SM70_8x8x4_F32F16F16F32_NT { // \u5b9a\u4e49 D \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // 8\u4e2afloat\u5bc4\u5b58\u5668\u7528\u4e8e\u5b58\u50a88x8\u77e9\u9635\u7684\u8f93\u51fa\u7ed3\u679c using DRegisters = float[8]; // \u5b9a\u4e49 A \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // 2\u4e2auint32_t\u5bc4\u5b58\u5668\uff0c\u6bcf\u4e2a\u5305\u542b2\u4e2aF16\u503c\uff08\u51714\u4e2aF16\u503c\uff09 using ARegisters = uint32_t[2]; // \u5b9a\u4e49 B \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // \u4e0eA\u77e9\u9635\u76f8\u540c\uff0c2\u4e2auint32_t\u5bc4\u5b58\u5668 using BRegisters = uint32_t[2]; // \u5b9a\u4e49 C \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // 8\u4e2afloat\u5bc4\u5b58\u5668\u7528\u4e8e\u5b58\u50a88x8\u77e9\u9635\u7684\u8f93\u5165\u548c\u7d2f\u52a0\u7ed3\u679c using CRegisters = float[8]; // FMA\u64cd\u4f5c\u7684\u9759\u6001\u51fd\u6570\u5b9e\u73b0 // \u901a\u8fc7\u5185\u8054\u6c47\u7f16\u8c03\u7528\u5b9e\u9645\u7684PTX\u6307\u4ee4 CUTE_HOST_DEVICE static void fma(float & d0, float & d1, float & d2, float & d3, float & d4, float & d5, float & d6, float & d7, uint32_t const& a0, uint32_t const& a1, uint32_t const& b0, uint32_t const& b1, float const& c0, float const& c1, float const& c2, float const& c3, float const& c4, float const& c5, float const& c6, float const& c7) { // \u5b9e\u9645\u7684 PTX \u6307\u4ee4\u8c03\u7528 // \u6267\u884c 8x8x4 \u7684\u77e9\u9635\u4e58\u6cd5\u7d2f\u52a0\u64cd\u4f5c // .m8n8k4 \u8868\u793a\u64cd\u4f5c\u7684\u5c3a\u5bf8\uff1aM=8, N=8, K=4 // .row.col \u8868\u793a A \u77e9\u9635\u662f\u884c\u4e3b\u5e8f\uff0cB \u77e9\u9635\u662f\u5217\u4e3b\u5e8f // .f32.f16.f16.f32 \u8868\u793a\u6570\u636e\u7c7b\u578b\uff1aD(F32), A(F16), B(F16), C(F32) asm volatile( \"mma.sync.aligned.m8n8k4.row.col.f32.f16.f16.f32\" \"{%0, %1, %2, %3, %4, %5, %6, %7},\" \"{%8, %9},\" \"{%10, %11},\" \"{%12, %13, %14, %15, %16, %17, %18, %19};\" : \"=f\"(d0), \"=f\"(d1), \"=f\"(d2), \"=f\"(d3), \"=f\"(d4), \"=f\"(d5), \"=f\"(d6), \"=f\"(d7) : \"r\"(a0), \"r\"(a1), \"r\"(b0), \"r\"(b1), \"f\"(c0), \"f\"(c1), \"f\"(c2), \"f\"(c3), \"f\"(c4), \"f\"(c5), \"f\"(c6), \"f\"(c7)); } }; 2. MMA_Traits \u7279\u6027\u7ed3\u6784\u4f53 MMA_Traits \u4e3a\u6bcf\u4e2a Operation \u63d0\u4f9b\u5143\u4fe1\u606f\uff0c\u5305\u62ec\uff1a ValTypeD, ValTypeA, ValTypeB, ValTypeC: \u903b\u8f91\u6570\u636e\u7c7b\u578b Shape_MNK: MMA \u64cd\u4f5c\u7684\u903b\u8f91\u5f62\u72b6(MxNxK) ThrID: MMA \u64cd\u4f5c\u4e2d\u7684\u7ebf\u7a0b\u6620\u5c04 ALayout, BLayout, CLayout: \u7ebf\u7a0b\u548c\u503c\u5230\u5750\u6807\u7a7a\u95f4\u7684\u6620\u5c04\u5e03\u5c40 \u8bbe\u8ba1\u539f\u56e0\uff1a \u5206\u79bb\u786c\u4ef6\u6307\u4ee4\u5b9e\u73b0\u548c\u903b\u8f91\u4fe1\u606f\u63cf\u8ff0 \u63d0\u4f9b\u7f16\u8bd1\u65f6\u5143\u4fe1\u606f\uff0c\u652f\u6301\u6a21\u677f\u7279\u5316 \u63cf\u8ff0\u7ebf\u7a0b\u548c\u6570\u636e\u7684\u5e03\u5c40\u5173\u7cfb\uff0c\u4fbf\u4e8e\u5185\u5b58\u8bbf\u95ee\u4f18\u5316 template <> struct MMA_Traits<SM70_8x8x4_F32F16F16F32_NT> { // \u5b9a\u4e49\u903b\u8f91\u6570\u636e\u7c7b\u578b using ValTypeD = float; // \u8f93\u51fa\u77e9\u9635 D \u7684\u7c7b\u578b using ValTypeA = half_t; // \u8f93\u5165\u77e9\u9635 A \u7684\u7c7b\u578b using ValTypeB = half_t; // \u8f93\u5165\u77e9\u9635 B \u7684\u7c7b\u578b using ValTypeC = float; // \u8f93\u5165/\u8f93\u51fa\u77e9\u9635 C \u7684\u7c7b\u578b // \u5b9a\u4e49 MMA \u64cd\u4f5c\u7684\u903b\u8f91\u5f62\u72b6\uff1aM=8, N=8, K=4 using Shape_MNK = Shape<_8,_8,_4>; // \u5b9a\u4e49\u7ebf\u7a0bID\u6620\u5c04\u5e03\u5c40 // 4x2\u5e03\u5c40\uff0c\u6b65\u5e45\u4e3a1\u548c16 // \u8868\u793a8\u4e2a\u7ebf\u7a0b\u7ec4\u6210\u7684quadpair\u7ed3\u6784 using ThrID = Layout<Shape <_4, _2>, Stride<_1,_16>>; // \u5b9a\u4e49 A \u77e9\u9635\u7684\u7ebf\u7a0b-\u503c\u5e03\u5c40 // Shape <Shape <_4,_2>,_4> \u8868\u793a 4x2 \u7684\u7ebf\u7a0b\u5e03\u5c40\u548c 4 \u4e2a\u503c // Stride<Stride<_8,_4>,_1> \u5b9a\u4e49\u4e86\u5185\u5b58\u8bbf\u95ee\u7684\u6b65\u5e45\u6a21\u5f0f using ALayout = Layout<Shape <Shape <_4,_2>,_4>, Stride<Stride<_8,_4>,_1>>; // \u5b9a\u4e49 B \u77e9\u9635\u7684\u7ebf\u7a0b-\u503c\u5e03\u5c40 // \u4e0e A \u77e9\u9635\u76f8\u540c\uff0c\u56e0\u4e3a\u5b83\u4eec\u6709\u76f8\u4f3c\u7684\u8bbf\u95ee\u6a21\u5f0f using BLayout = Layout<Shape <Shape <_4,_2>,_4>, Stride<Stride<_8,_4>,_1>>; // \u5b9a\u4e49 C \u77e9\u9635\u7684\u7ebf\u7a0b-\u503c\u5e03\u5c40 // \u66f4\u590d\u6742\u7684\u4e09\u7ef4\u5e03\u5c40\uff0c\u7cbe\u786e\u63cf\u8ff0\u4e868\u4e2a\u7ebf\u7a0b\u5982\u4f55\u8bbf\u95ee8\u4e2a\u503c using CLayout = Layout<Shape <Shape <_2, _2,_2>, Shape <_2,_2, _2>>, Stride<Stride<_1,_16,_4>, Stride<_8,_2,_32>>>; }; 3. MMA_Atom \u539f\u5b50\u64cd\u4f5c MMA_Atom \u5c06 Operation \u548c MMA_Traits \u7ed3\u5408\u8d77\u6765\uff0c\u63d0\u4f9b\u7edf\u4e00\u63a5\u53e3\uff1a \u8bbe\u8ba1\u539f\u56e0\uff1a \u7edf\u4e00\u5c01\u88c5Operation\u548cTraits\uff0c\u63d0\u4f9b\u4e00\u81f4\u7684API \u652f\u6301\u6a21\u677f\u7279\u5316\uff0c\u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u64cd\u4f5c\u8fdb\u884c\u4f18\u5316 \u63d0\u4f9bmake_fragment\u65b9\u6cd5\uff0c\u4fbf\u4e8e\u521b\u5efa\u9002\u5408\u7684\u5f20\u91cf\u7247\u6bb5 \u5b9e\u73b0call\u63a5\u53e3\uff0c\u7b80\u5316MMA\u64cd\u4f5c\u7684\u8c03\u7528 // \u4e3b\u6a21\u677f\uff0c\u901a\u8fc7MMA_Traits\u7279\u5316\u6765\u5b9e\u73b0\u5177\u4f53\u529f\u80fd template <class MMAOperation> struct MMA_Atom<MMAOperation> : MMA_Atom<MMA_Traits<MMAOperation>> {}; // \u7279\u5316\u7248\u672c\uff0c\u5b9e\u73b0\u5177\u4f53\u529f\u80fd template <class MMAOperation, class... Args> struct MMA_Atom<MMA_Traits<MMAOperation, Args...>> : MMA_Traits<MMAOperation, Args...> { // \u4eceTraits\u7ee7\u627f\u7c7b\u578b\u5b9a\u4e49 using ValTypeD = typename Traits::ValTypeD; using ValTypeA = typename Traits::ValTypeA; using ValTypeB = typename Traits::ValTypeB; using ValTypeC = typename Traits::ValTypeC; using Shape_MNK = typename Traits::Shape_MNK; using ThrID = typename Traits::ThrID; using LayoutC_TV = typename Traits::CLayout; using LayoutA_TV = typename Traits::ALayout; using LayoutB_TV = typename Traits::BLayout; // \u4e3b\u8981\u7684\u8c03\u7528\u63a5\u53e3 // \u63a5\u53d7\u56db\u4e2a\u5f20\u91cf\u53c2\u6570\uff1aD(\u8f93\u51fa), A(\u8f93\u5165), B(\u8f93\u5165), C(\u8f93\u5165/\u8f93\u51fa) template <class TD, class DLayout, class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE constexpr void call(Tensor<TD, DLayout> & D, Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> const& C) const { // \u9759\u6001\u65ad\u8a00\u786e\u4fdd\u5f20\u91cf\u662f\u4e00\u7ef4\u7684\uff08\u5bc4\u5b58\u5668\u7ea7\u64cd\u4f5c\uff09 static_assert(DLayout::rank == 1, \"Expected rank-1 D tensor\"); static_assert(ALayout::rank == 1, \"Expected rank-1 A tensor\"); static_assert(BLayout::rank == 1, \"Expected rank-1 B tensor\"); static_assert(CLayout::rank == 1, \"Expected rank-1 C tensor\"); // \u8c03\u7528\u5e95\u5c42\u7684mma_unpack\u51fd\u6570\u6267\u884c\u5b9e\u9645\u64cd\u4f5c return mma_unpack(static_cast<Traits const&>(*this), D, A, B, C); } // \u4e09\u4e2a\u53c2\u6570\u7684\u91cd\u8f7d\u7248\u672c\uff0c\u590d\u7528C\u4f5c\u4e3a\u8f93\u51fa template <class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE constexpr void call(Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> & C) const { // \u8c03\u7528\u56db\u53c2\u6570\u7248\u672c\uff0c\u5c06C\u540c\u65f6\u4f5c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa return call(C, A, B, C); } }; 4. TiledMMA \u5e73\u94fa\u64cd\u4f5c TiledMMA \u5141\u8bb8\u5c06\u591a\u4e2a MMA_Atom \u7ec4\u5408\u6210\u66f4\u5927\u7684\u64cd\u4f5c\uff0c\u652f\u6301\u591a\u7ebf\u7a0b\u534f\u4f5c\uff1a \u8bbe\u8ba1\u539f\u56e0\uff1a \u652f\u6301\u66f4\u5927\u89c4\u6a21\u7684\u77e9\u9635\u8fd0\u7b97\uff0c\u8d85\u8d8a\u5355\u4e2aMMA\u6307\u4ee4\u7684\u80fd\u529b \u5b9e\u73b0\u7ebf\u7a0b\u7ea7\u522b\u7684\u5e76\u884c\u5316\uff0c\u63d0\u9ad8\u786c\u4ef6\u5229\u7528\u7387 \u63d0\u4f9b\u7075\u6d3b\u7684\u5e73\u94fa\u7b56\u7565\uff0c\u9002\u5e94\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40\u9700\u6c42 \u901a\u8fc7\u7ec4\u5408\u591a\u4e2aAtom\uff0c\u6784\u5efa\u66f4\u590d\u6742\u7684\u8ba1\u7b97\u6a21\u5f0f // TiledMMA\u6a21\u677f\u5b9a\u4e49 // MMA_Atom: \u57fa\u7840\u7684MMA\u64cd\u4f5c\u539f\u5b50 // AtomLayoutMNK: \u5728MNK\u7ef4\u5ea6\u4e0aAtom\u7684\u5e03\u5c40 // PermutationMNK: \u5e94\u7528\u4e8e\u6bcf\u4e2aMNK\u6a21\u5f0f\u7684\u6392\u5217 template <class MMA_Atom, class AtomLayoutMNK, class PermutationMNK = Tile<Underscore,Underscore,Underscore>> struct TiledMMA : MMA_Atom { // \u4eceMMA_Atom\u7ee7\u627f\u76f8\u5173\u7c7b\u578b using Atom = MMA_Atom; using AtomShape_MNK = typename MMA_Atom::Shape_MNK; using AtomThrID = typename MMA_Atom::ThrID; using AtomLayoutC_TV = typename MMA_Atom::LayoutC_TV; using AtomLayoutA_TV = typename MMA_Atom::LayoutA_TV; using AtomLayoutB_TV = typename MMA_Atom::LayoutB_TV; // \u7ebf\u7a0b\u5e03\u5c40\uff0c\u901a\u8fc7\u5c06AtomThrID\u4e0eAtomLayoutMNK\u8fdb\u884ctiled_product\u5f97\u5230 using ThrLayoutVMNK = decltype(tiled_product(AtomThrID{}, AtomLayoutMNK{})); ThrLayoutVMNK thr_layout_vmnk_; // \u6784\u9020\u51fd\u6570 CUTE_HOST_DEVICE constexpr TiledMMA(MMA_Atom const& mma_atom = {}, AtomLayoutMNK const& thr_layout_mnk = {}) : MMA_Atom(mma_atom), thr_layout_vmnk_(tiled_product(AtomThrID{}, thr_layout_mnk)) {} // \u83b7\u53d6\u7ebf\u7a0b\u5e03\u5c40 CUTE_HOST_DEVICE constexpr auto get_thr_layout_vmnk() const { return thr_layout_vmnk_; } // \u6839\u636e\u7ebf\u7a0b\u7d22\u5f15\u83b7\u53d6\u5207\u7247 template <class ThrIdx> CUTE_HOST_DEVICE constexpr auto get_slice(ThrIdx const& thr_idx) const { // \u5c06\u7ebf\u7a0b\u7d22\u5f15\u8f6c\u6362\u4e3aVMNK\u5750\u6807 auto thr_vmnk = thr_layout_vmnk_.get_flat_coord(thr_idx); // \u8fd4\u56deThrMMA\u5bf9\u8c61\uff0c\u7528\u4e8e\u7279\u5b9a\u7ebf\u7a0b\u7684\u64cd\u4f5c return ThrMMA<TiledMMA, decltype(thr_vmnk)>{*this, thr_vmnk}; } }; // ThrMMA\u4e3a\u7279\u5b9a\u7ebf\u7a0b\u63d0\u4f9b\u64cd\u4f5c\u63a5\u53e3 template <class TiledMMA, class ThrVMNK> struct ThrMMA : TiledMMA { ThrVMNK thr_vmnk_; // \u5206\u533aC\u77e9\u9635\uff0c\u4e3a\u5f53\u524d\u7ebf\u7a0b\u51c6\u5907\u6570\u636e template <class CTensor> CUTE_HOST_DEVICE constexpr auto partition_C(CTensor&& ctensor) const { // \u521b\u5efa\u5f20\u91cf\u5e76\u5e94\u7528thrfrg_C\u5e03\u5c40\u53d8\u6362 auto thr_tensor = make_tensor(static_cast<CTensor&&>(ctensor).data(), this->thrfrg_C(ctensor.layout())); // \u6784\u9020\u7ebf\u7a0b\u5750\u6807\u5e76\u83b7\u53d6\u5f53\u524d\u7ebf\u7a0b\u7684\u6570\u636e\u5207\u7247 auto thr_vmn = make_coord(get<0>(thr_vmnk_), make_coord(get<1>(thr_vmnk_), get<2>(thr_vmnk_))); return thr_tensor(thr_vmn, make_coord(_, repeat<rank<1,1>(thr_tensor)>(_))); } // \u7c7b\u4f3c\u5730\u5b9e\u73b0 partition_A \u548c partition_B }; Algorithm GEMM \u63a5\u53e3 CuTe \u63d0\u4f9b\u4e86\u7edf\u4e00\u7684 GEMM \u63a5\u53e3\uff0c\u53ef\u4ee5\u5904\u7406\u4e0d\u540c\u5c42\u6b21\u7684\u77e9\u9635\u4e58\u6cd5\u64cd\u4f5c\uff1a \u8bbe\u8ba1\u539f\u56e0\uff1a \u63d0\u4f9b\u7edf\u4e00\u7684\u63a5\u53e3\uff0c\u9690\u85cf\u5e95\u5c42\u5b9e\u73b0\u590d\u6742\u6027 \u652f\u6301\u591a\u79cd\u6570\u636e\u5e03\u5c40\u548c\u5185\u5b58\u7c7b\u578b \u6839\u636e\u5f20\u91cf\u7ef4\u5ea6\u548c\u5185\u5b58\u7c7b\u578b\u81ea\u52a8\u5206\u53d1\u5230\u5408\u9002\u7684\u5b9e\u73b0 \u5b9e\u73b0\u5bc4\u5b58\u5668\u7ea7\u548c\u5171\u4eab\u5185\u5b58\u7ea7\u64cd\u4f5c\u7684\u7edf\u4e00\u8c03\u7528 // \u57fa\u672c GEMM \u63a5\u53e3\uff0c\u4f7f\u7528\u901a\u7528FMA\u64cd\u4f5c template <class TD, class DLayout, class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE void gemm(Tensor<TD, DLayout> & D, Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> const& C) { // \u6839\u636e\u5f20\u91cf\u7684\u6570\u636e\u7c7b\u578b\u521b\u5efa\u5408\u9002\u7684MMA\u64cd\u4f5c using MMA = MMA_Atom<UniversalFMA<typename Tensor<TD,DLayout>::value_type, typename Tensor<TA,ALayout>::value_type, typename Tensor<TB,BLayout>::value_type, typename Tensor<TC,CLayout>::value_type>>; // \u8c03\u7528\u5177\u4f53\u7684GEMM\u5b9e\u73b0 return gemm(MMA{}, D, A, B, C); } // \u4f7f\u7528\u7279\u5b9a MMA_Atom \u7684 GEMM \u63a5\u53e3 template <class MMA, class TD, class DLayout, class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE void gemm(MMA_Atom<MMA> const& mma, Tensor<TD, DLayout> & D, Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> const& C) { // \u6839\u636e\u5f20\u91cf\u7684\u7ef4\u5ea6\u548c\u5185\u5b58\u7c7b\u578b\u8fdb\u884c\u5206\u53d1 // Dispatch [1]: (V) x (V) => (V) - \u5143\u7d20\u7ea7\u4e58\u6cd5\uff0c\u76f4\u63a5\u8c03\u7528MMA\u539f\u5b50\u64cd\u4f5c // Dispatch [2]: (M) x (N) => (M,N) - \u5916\u79ef\uff0c\u8f6c\u6362\u4e3a\u77e9\u9635\u4e58\u6cd5 // Dispatch [3]: (M,K) x (N,K) => (M,N) - \u77e9\u9635\u4e58\u6cd5\uff0c\u6dfb\u52a0\u5411\u91cf\u7ef4\u5ea6 // Dispatch [4]: (V,M) x (V,N) => (V,M,N) - \u6279\u91cf\u5916\u79ef\uff0c\u6309\u5143\u7d20\u8fdb\u884c\u5bc4\u5b58\u5668\u4f18\u5316 // Dispatch [5]: (V,M,K) x (V,N,K) => (V,M,N) - \u6279\u91cf\u77e9\u9635\u4e58\u6cd5\uff0c\u6309K\u7ef4\u5ea6\u5faa\u73af\u5904\u7406 // \u8fd9\u79cd\u5206\u53d1\u673a\u5236\u4f7f\u5f97GEMM\u63a5\u53e3\u53ef\u4ee5\u5904\u7406\u4ece\u7b80\u5355\u5143\u7d20\u64cd\u4f5c\u5230\u590d\u6742\u6279\u91cf\u77e9\u9635\u8fd0\u7b97\u7684\u5404\u79cd\u60c5\u51b5 } MMA_Atom MMA_Atom \u662f CuTe \u4e2d MMA \u64cd\u4f5c\u7684\u57fa\u672c\u6784\u5efa\u5757\u3002\u5b83\u5c01\u88c5\u4e86\uff1a \u5b9e\u9645\u7684 MMA \u6307\u4ee4\uff08\u5982 HMMA\u3001WMMA \u7b49\uff09 \u8f93\u5165\u548c\u8f93\u51fa\u7684\u5e03\u5c40\u4fe1\u606f MMA \u64cd\u4f5c\u7684\u7ea6\u675f\u6761\u4ef6 MMA_Atom \u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\u67b6\u6784\u548c\u6570\u636e\u7c7b\u578b\u8fdb\u884c\u4f18\u5316\u3002 MMA \u64cd\u4f5c\u793a\u4f8b \u4e00\u4e2a\u5178\u578b\u7684 MMA \u64cd\u4f5c\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a // \u5b9a\u4e49\u8f93\u5165\u5f20\u91cf A\u3001B \u548c\u7d2f\u52a0\u5f20\u91cf C auto A_tensor = make_tensor(A_ptr, A_layout); auto B_tensor = make_tensor(B_ptr, B_layout); auto C_tensor = make_tensor(C_ptr, C_layout); // \u521b\u5efa MMA \u64cd\u4f5c\u5bf9\u8c61 auto mma_atom = MMA_Atom<SM70_8x8x4_F32F16F16F32_NT>{}; // \u83b7\u53d6 MMA \u64cd\u4f5c\u7684\u53c2\u4e0e\u8005 auto mma_thr = mma_atom.get_thread_slice(thread_idx); // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto accum_fragment = make_fragment_like(C_tensor); clear(accum_fragment); // \u6267\u884c MMA \u64cd\u4f5c mma_thr.call(A_tensor, B_tensor, accum_fragment); mma_thr.call() \u4e0e cute::gemm() \u7684\u533a\u522b \u867d\u7136\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 mma_thr.call() \u6267\u884c MMA \u64cd\u4f5c\uff0c\u4f46 CuTe \u4ecd\u7136\u63d0\u4f9b\u4e86 cute::gemm() \u63a5\u53e3\uff0c\u8fd9\u662f\u56e0\u4e3a\u4e24\u8005\u6709\u4e0d\u540c\u7684\u4f7f\u7528\u573a\u666f\u548c\u62bd\u8c61\u5c42\u6b21\uff1a mma_thr.call() \u7684\u7279\u70b9\uff1a \u4f4e\u7ea7\u63a5\u53e3 \uff1a\u76f4\u63a5\u64cd\u4f5c\u5bc4\u5b58\u5668\u7ea7\u522b\u7684\u5f20\u91cf\u7247\u6bb5 \u7cbe\u786e\u63a7\u5236 \uff1a\u9700\u8981\u624b\u52a8\u7ba1\u7406\u5f20\u91cf\u7684\u5206\u533a\u548c\u5e03\u5c40 \u786c\u4ef6\u76f8\u5173 \uff1a\u9700\u8981\u660e\u786e\u6307\u5b9a\u4f7f\u7528\u7684 MMA \u64cd\u4f5c\u7c7b\u578b \u9002\u5408\u573a\u666f \uff1a\u9700\u8981\u7cbe\u7ec6\u63a7\u5236\u8ba1\u7b97\u8fc7\u7a0b\u7684\u9ad8\u6027\u80fd\u573a\u666f cute::gemm() \u7684\u7279\u70b9\uff1a \u9ad8\u7ea7\u63a5\u53e3 \uff1a\u63d0\u4f9b\u7edf\u4e00\u7684 GEMM \u63a5\u53e3\uff0c\u81ea\u52a8\u5904\u7406\u5e95\u5c42\u7ec6\u8282 \u81ea\u52a8\u5206\u53d1 \uff1a\u6839\u636e\u5f20\u91cf\u7684\u7ef4\u5ea6\u548c\u5185\u5b58\u7c7b\u578b\u81ea\u52a8\u9009\u62e9\u5408\u9002\u7684\u5b9e\u73b0 \u7c7b\u578b\u63a8\u5bfc \uff1a\u53ef\u4ee5\u6839\u636e\u8f93\u5165\u5f20\u91cf\u7684\u7c7b\u578b\u81ea\u52a8\u63a8\u5bfc\u5408\u9002\u7684 MMA \u64cd\u4f5c \u7075\u6d3b\u9002\u914d \uff1a\u53ef\u4ee5\u5904\u7406\u4ece\u7b80\u5355\u5143\u7d20\u64cd\u4f5c\u5230\u590d\u6742\u6279\u91cf\u77e9\u9635\u8fd0\u7b97\u7684\u5404\u79cd\u60c5\u51b5 \u9002\u5408\u573a\u666f \uff1a\u901a\u7528\u7684\u77e9\u9635\u4e58\u6cd5\u8ba1\u7b97\uff0c\u7b80\u5316\u5f00\u53d1\u6d41\u7a0b \u4f7f\u7528\u5efa\u8bae\uff1a // \u5f53\u9700\u8981\u7cbe\u7ec6\u63a7\u5236\u65f6\uff0c\u4f7f\u7528 mma_thr.call() auto mma_atom = MMA_Atom<SM70_8x8x4_F32F16F16F32_NT>{}; auto mma_thr = mma_atom.get_thread_slice(thread_idx); mma_thr.call(A_frag, B_frag, C_frag); // \u5f53\u9700\u8981\u901a\u7528\u63a5\u53e3\u65f6\uff0c\u4f7f\u7528 cute::gemm() cute::gemm(D_tensor, A_tensor, B_tensor, C_tensor); \u603b\u7684\u6765\u8bf4\uff0c mma_thr.call() \u63d0\u4f9b\u4e86\u66f4\u5e95\u5c42\u3001\u66f4\u7cbe\u786e\u7684\u63a7\u5236\uff0c\u800c cute::gemm() \u63d0\u4f9b\u4e86\u66f4\u9ad8\u7ea7\u3001\u66f4\u901a\u7528\u7684\u63a5\u53e3\u3002\u5f00\u53d1\u8005\u53ef\u4ee5\u6839\u636e\u5177\u4f53\u9700\u6c42\u9009\u62e9\u5408\u9002\u7684\u63a5\u53e3\u3002 GMMA Descriptor \u4e0e Swizzle \u4fe1\u606f \u5bf9\u4e8e Hopper (SM90) \u67b6\u6784\u4e2d\u7684 GMMA \u64cd\u4f5c\uff0c\u8bf7\u53c2\u8003\u4e13\u95e8\u7684\u6587\u6863\uff1a CuTe WGmma SM90 \u7d2f\u52a0\u7247\u6bb5 (Accumulator Fragment) \u5728 MMA \u64cd\u4f5c\u4e2d\uff0c\u7d2f\u52a0\u7247\u6bb5\u662f\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\u3002\u5b83\u4ee3\u8868\u4e86\u7d2f\u52a0\u5668\u5bc4\u5b58\u5668\u4e2d\u7684\u6570\u636e\u5757\u3002CuTe \u63d0\u4f9b\u4e86\u4e13\u95e8\u7684\u7c7b\u578b\u548c\u64cd\u4f5c\u6765\u5904\u7406\u7d2f\u52a0\u7247\u6bb5\uff1a // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto accum_fragment = make_fragment_like(C_tensor); // \u521d\u59cb\u5316\u7d2f\u52a0\u7247\u6bb5 clear(accum_fragment); // \u6267\u884c\u591a\u6b21 MMA \u64cd\u4f5c\u7d2f\u52a0\u7ed3\u679c mma_thr.call(A_tensor, B_tensor, accum_fragment, accum_fragment); \u4e0e Copy \u64cd\u4f5c\u7684\u534f\u540c \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0cMMA \u64cd\u4f5c\u901a\u5e38\u4e0e Copy \u64cd\u4f5c\u534f\u540c\u5de5\u4f5c\uff1a \u4f7f\u7528 Copy \u64cd\u4f5c\u5c06\u6570\u636e\u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u5230\u5171\u4eab\u5185\u5b58\u6216\u5bc4\u5b58\u5668 \u4f7f\u7528 MMA \u64cd\u4f5c\u6267\u884c\u8ba1\u7b97 \u4f7f\u7528 Copy \u64cd\u4f5c\u5c06\u7ed3\u679c\u4ece\u5bc4\u5b58\u5668\u5199\u56de\u5230\u5168\u5c40\u5185\u5b58 \u8fd9\u79cd\u534f\u540c\u5de5\u4f5c\u6a21\u5f0f\u5145\u5206\u5229\u7528\u4e86 GPU \u7684\u5185\u5b58\u5c42\u6b21\u7ed3\u6784\u548c\u8ba1\u7b97\u80fd\u529b\u3002 \u4e0d\u540c\u67b6\u6784\u7684\u652f\u6301 CuTe \u652f\u6301\u591a\u79cd NVIDIA GPU \u67b6\u6784\u7684 MMA \u6307\u4ee4\uff1a Volta (SM70) \u4f7f\u7528 HMMA \u6307\u4ee4 8\u4e2a\u7ebf\u7a0b\u7684 quadpair \u534f\u4f5c\u5b8c\u6210 8x8x4 \u7684\u77e9\u9635\u4e58\u6cd5 Turing (SM75) \u589e\u5f3a\u7684 HMMA \u6307\u4ee4\u652f\u6301 Ampere (SM80) \u66f4\u591a\u7684 MMA \u6307\u4ee4\u53d8\u4f53 \u5bf9\u7a00\u758f\u77e9\u9635\u4e58\u6cd5\u7684\u652f\u6301 Hopper (SM90) \u5f15\u5165\u4e86\u65b0\u4e00\u4ee3\u7684 GMMA (Group MMA) \u6307\u4ee4 \u652f\u6301\u66f4\u5927\u7684\u77e9\u9635\u64cd\u4f5c (\u5982 64x128x16) warpgroup \u7ea7\u522b\u7684\u534f\u4f5c (128\u4e2a\u7ebf\u7a0b) \u9ad8\u7ea7\u7279\u6027 CuTe \u7684 MMA \u64cd\u4f5c\u5177\u6709\u4ee5\u4e0b\u9ad8\u7ea7\u7279\u6027\uff1a \u53ef\u6269\u5c55\u6027 \u901a\u8fc7 TiledMMA\uff0c\u53ef\u4ee5\u8f7b\u677e\u5730\u6269\u5c55\u57fa\u672c\u7684 MMA \u64cd\u4f5c\u4ee5\u9002\u5e94\u66f4\u5927\u7684\u77e9\u9635\u8ba1\u7b97\u9700\u6c42\u3002 \u7075\u6d3b\u7684\u5e03\u5c40\u652f\u6301 CuTe \u7684 Layout \u7cfb\u7edf\u4f7f\u5f97\u53ef\u4ee5\u7075\u6d3b\u5730\u5904\u7406\u4e0d\u540c\u7684\u6570\u636e\u5e03\u5c40\uff0c\u5305\u62ec\u884c\u4e3b\u5e8f\u3001\u5217\u4e3b\u5e8f\u4ee5\u53ca\u81ea\u5b9a\u4e49\u5e03\u5c40\u3002 \u7c7b\u578b\u5b89\u5168 \u901a\u8fc7\u6a21\u677f\u548c\u7c7b\u578b\u7cfb\u7edf\uff0c\u786e\u4fdd\u5728\u7f16\u8bd1\u65f6\u5c31\u80fd\u53d1\u73b0\u7c7b\u578b\u4e0d\u5339\u914d\u7684\u9519\u8bef\u3002 \u8fd9\u4e9b\u62bd\u8c61\u4f7f\u5f97\u5f00\u53d1\u8005\u53ef\u4ee5\u7f16\u5199\u9ad8\u6548\u4e14\u53ef\u7ef4\u62a4\u7684 CUDA \u4ee3\u7801\uff0c\u540c\u65f6\u5145\u5206\u5229\u7528\u73b0\u4ee3 GPU \u7684\u8ba1\u7b97\u80fd\u529b\u3002","title":"MMA \u64cd\u4f5c\u8be6\u89e3"},{"location":"cute_mma/#cute-mma-matrix-multiply-accumulate","text":"MMA (Matrix Multiply-Accumulate) \u662f CuTe \u4e2d\u7528\u4e8e\u6267\u884c\u77e9\u9635\u4e58\u52a0\u8fd0\u7b97\u7684\u6838\u5fc3\u7ec4\u4ef6\u3002\u5728\u6df1\u5ea6\u5b66\u4e60\u548c\u79d1\u5b66\u8ba1\u7b97\u4e2d\uff0cMMA \u64cd\u4f5c\u662f\u6700\u5173\u952e\u7684\u8ba1\u7b97\u4e4b\u4e00\u3002","title":"CuTe MMA (Matrix Multiply-Accumulate) \u64cd\u4f5c"},{"location":"cute_mma/#mma","text":"MMA \u64cd\u4f5c\u6267\u884c\u4ee5\u4e0b\u8ba1\u7b97\uff1a D = A * B + C \u5176\u4e2d A\u3001B \u662f\u8f93\u5165\u77e9\u9635\uff0cC \u662f\u7d2f\u52a0\u77e9\u9635\uff0cD \u662f\u8f93\u51fa\u77e9\u9635\u3002 \u5728 CuTe \u4e2d\uff0cMMA \u64cd\u4f5c\u88ab\u9ad8\u5ea6\u62bd\u8c61\u5316\uff0c\u5141\u8bb8\u5f00\u53d1\u8005\uff1a \u4f7f\u7528\u4e0d\u540c\u7cbe\u5ea6\u7684\u6570\u636e\u7c7b\u578b \u5229\u7528\u4e13\u95e8\u7684\u786c\u4ef6\u6307\u4ee4\uff08\u5982 Tensor Cores\uff09 \u9002\u5e94\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40 \u4e0e\u7ebf\u7a0b\u534f\u4f5c\u8fdb\u884c\u5927\u89c4\u6a21\u8ba1\u7b97","title":"MMA \u57fa\u672c\u6982\u5ff5"},{"location":"cute_mma/#cute-mma","text":"CuTe \u5bf9 MMA \u64cd\u4f5c\u8fdb\u884c\u4e86\u591a\u5c42\u62bd\u8c61\uff0c\u4ece\u5e95\u5c42\u786c\u4ef6\u6307\u4ee4\u5230\u9ad8\u7ea7\u63a5\u53e3\uff1a","title":"CuTe MMA \u62bd\u8c61\u5c42\u6b21"},{"location":"cute_mma/#1-operation","text":"Operation \u7ed3\u6784\u4f53\u5c01\u88c5\u4e86\u7279\u5b9a\u7684 PTX \u6307\u4ee4\u3002\u5b83\u5b9a\u4e49\u4e86\u6307\u4ee4\u6240\u9700\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u5b9e\u9645\u7684 fma \u51fd\u6570\u5b9e\u73b0\u3002 \u8bbe\u8ba1\u539f\u56e0\uff1a \u5c06\u5e95\u5c42\u786c\u4ef6\u6307\u4ee4\u5c01\u88c5\u5728\u7edf\u4e00\u63a5\u53e3\u4e0b\uff0c\u9690\u85cf\u786c\u4ef6\u5dee\u5f02 \u660e\u786e\u5b9a\u4e49\u5bc4\u5b58\u5668\u4f7f\u7528\u6a21\u5f0f\uff0c\u4fbf\u4e8e\u7f16\u8bd1\u5668\u4f18\u5316 \u63d0\u4f9b\u7c7b\u578b\u5b89\u5168\u7684\u63a5\u53e3\uff0c\u9632\u6b62\u5bc4\u5b58\u5668\u7c7b\u578b\u9519\u8bef \u4f8b\u5982\uff0c SM70_8x8x4_F32F16F16F32_NT \u5b9a\u4e49\u4e86 Volta \u67b6\u6784\u4e0a\u7684\u4e00\u4e2a MMA \u64cd\u4f5c\uff1a struct SM70_8x8x4_F32F16F16F32_NT { // \u5b9a\u4e49 D \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // 8\u4e2afloat\u5bc4\u5b58\u5668\u7528\u4e8e\u5b58\u50a88x8\u77e9\u9635\u7684\u8f93\u51fa\u7ed3\u679c using DRegisters = float[8]; // \u5b9a\u4e49 A \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // 2\u4e2auint32_t\u5bc4\u5b58\u5668\uff0c\u6bcf\u4e2a\u5305\u542b2\u4e2aF16\u503c\uff08\u51714\u4e2aF16\u503c\uff09 using ARegisters = uint32_t[2]; // \u5b9a\u4e49 B \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // \u4e0eA\u77e9\u9635\u76f8\u540c\uff0c2\u4e2auint32_t\u5bc4\u5b58\u5668 using BRegisters = uint32_t[2]; // \u5b9a\u4e49 C \u77e9\u9635\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u7c7b\u578b\u548c\u6570\u91cf // 8\u4e2afloat\u5bc4\u5b58\u5668\u7528\u4e8e\u5b58\u50a88x8\u77e9\u9635\u7684\u8f93\u5165\u548c\u7d2f\u52a0\u7ed3\u679c using CRegisters = float[8]; // FMA\u64cd\u4f5c\u7684\u9759\u6001\u51fd\u6570\u5b9e\u73b0 // \u901a\u8fc7\u5185\u8054\u6c47\u7f16\u8c03\u7528\u5b9e\u9645\u7684PTX\u6307\u4ee4 CUTE_HOST_DEVICE static void fma(float & d0, float & d1, float & d2, float & d3, float & d4, float & d5, float & d6, float & d7, uint32_t const& a0, uint32_t const& a1, uint32_t const& b0, uint32_t const& b1, float const& c0, float const& c1, float const& c2, float const& c3, float const& c4, float const& c5, float const& c6, float const& c7) { // \u5b9e\u9645\u7684 PTX \u6307\u4ee4\u8c03\u7528 // \u6267\u884c 8x8x4 \u7684\u77e9\u9635\u4e58\u6cd5\u7d2f\u52a0\u64cd\u4f5c // .m8n8k4 \u8868\u793a\u64cd\u4f5c\u7684\u5c3a\u5bf8\uff1aM=8, N=8, K=4 // .row.col \u8868\u793a A \u77e9\u9635\u662f\u884c\u4e3b\u5e8f\uff0cB \u77e9\u9635\u662f\u5217\u4e3b\u5e8f // .f32.f16.f16.f32 \u8868\u793a\u6570\u636e\u7c7b\u578b\uff1aD(F32), A(F16), B(F16), C(F32) asm volatile( \"mma.sync.aligned.m8n8k4.row.col.f32.f16.f16.f32\" \"{%0, %1, %2, %3, %4, %5, %6, %7},\" \"{%8, %9},\" \"{%10, %11},\" \"{%12, %13, %14, %15, %16, %17, %18, %19};\" : \"=f\"(d0), \"=f\"(d1), \"=f\"(d2), \"=f\"(d3), \"=f\"(d4), \"=f\"(d5), \"=f\"(d6), \"=f\"(d7) : \"r\"(a0), \"r\"(a1), \"r\"(b0), \"r\"(b1), \"f\"(c0), \"f\"(c1), \"f\"(c2), \"f\"(c3), \"f\"(c4), \"f\"(c5), \"f\"(c6), \"f\"(c7)); } };","title":"1. Operation \u7ed3\u6784\u4f53"},{"location":"cute_mma/#2-mma_traits","text":"MMA_Traits \u4e3a\u6bcf\u4e2a Operation \u63d0\u4f9b\u5143\u4fe1\u606f\uff0c\u5305\u62ec\uff1a ValTypeD, ValTypeA, ValTypeB, ValTypeC: \u903b\u8f91\u6570\u636e\u7c7b\u578b Shape_MNK: MMA \u64cd\u4f5c\u7684\u903b\u8f91\u5f62\u72b6(MxNxK) ThrID: MMA \u64cd\u4f5c\u4e2d\u7684\u7ebf\u7a0b\u6620\u5c04 ALayout, BLayout, CLayout: \u7ebf\u7a0b\u548c\u503c\u5230\u5750\u6807\u7a7a\u95f4\u7684\u6620\u5c04\u5e03\u5c40 \u8bbe\u8ba1\u539f\u56e0\uff1a \u5206\u79bb\u786c\u4ef6\u6307\u4ee4\u5b9e\u73b0\u548c\u903b\u8f91\u4fe1\u606f\u63cf\u8ff0 \u63d0\u4f9b\u7f16\u8bd1\u65f6\u5143\u4fe1\u606f\uff0c\u652f\u6301\u6a21\u677f\u7279\u5316 \u63cf\u8ff0\u7ebf\u7a0b\u548c\u6570\u636e\u7684\u5e03\u5c40\u5173\u7cfb\uff0c\u4fbf\u4e8e\u5185\u5b58\u8bbf\u95ee\u4f18\u5316 template <> struct MMA_Traits<SM70_8x8x4_F32F16F16F32_NT> { // \u5b9a\u4e49\u903b\u8f91\u6570\u636e\u7c7b\u578b using ValTypeD = float; // \u8f93\u51fa\u77e9\u9635 D \u7684\u7c7b\u578b using ValTypeA = half_t; // \u8f93\u5165\u77e9\u9635 A \u7684\u7c7b\u578b using ValTypeB = half_t; // \u8f93\u5165\u77e9\u9635 B \u7684\u7c7b\u578b using ValTypeC = float; // \u8f93\u5165/\u8f93\u51fa\u77e9\u9635 C \u7684\u7c7b\u578b // \u5b9a\u4e49 MMA \u64cd\u4f5c\u7684\u903b\u8f91\u5f62\u72b6\uff1aM=8, N=8, K=4 using Shape_MNK = Shape<_8,_8,_4>; // \u5b9a\u4e49\u7ebf\u7a0bID\u6620\u5c04\u5e03\u5c40 // 4x2\u5e03\u5c40\uff0c\u6b65\u5e45\u4e3a1\u548c16 // \u8868\u793a8\u4e2a\u7ebf\u7a0b\u7ec4\u6210\u7684quadpair\u7ed3\u6784 using ThrID = Layout<Shape <_4, _2>, Stride<_1,_16>>; // \u5b9a\u4e49 A \u77e9\u9635\u7684\u7ebf\u7a0b-\u503c\u5e03\u5c40 // Shape <Shape <_4,_2>,_4> \u8868\u793a 4x2 \u7684\u7ebf\u7a0b\u5e03\u5c40\u548c 4 \u4e2a\u503c // Stride<Stride<_8,_4>,_1> \u5b9a\u4e49\u4e86\u5185\u5b58\u8bbf\u95ee\u7684\u6b65\u5e45\u6a21\u5f0f using ALayout = Layout<Shape <Shape <_4,_2>,_4>, Stride<Stride<_8,_4>,_1>>; // \u5b9a\u4e49 B \u77e9\u9635\u7684\u7ebf\u7a0b-\u503c\u5e03\u5c40 // \u4e0e A \u77e9\u9635\u76f8\u540c\uff0c\u56e0\u4e3a\u5b83\u4eec\u6709\u76f8\u4f3c\u7684\u8bbf\u95ee\u6a21\u5f0f using BLayout = Layout<Shape <Shape <_4,_2>,_4>, Stride<Stride<_8,_4>,_1>>; // \u5b9a\u4e49 C \u77e9\u9635\u7684\u7ebf\u7a0b-\u503c\u5e03\u5c40 // \u66f4\u590d\u6742\u7684\u4e09\u7ef4\u5e03\u5c40\uff0c\u7cbe\u786e\u63cf\u8ff0\u4e868\u4e2a\u7ebf\u7a0b\u5982\u4f55\u8bbf\u95ee8\u4e2a\u503c using CLayout = Layout<Shape <Shape <_2, _2,_2>, Shape <_2,_2, _2>>, Stride<Stride<_1,_16,_4>, Stride<_8,_2,_32>>>; };","title":"2. MMA_Traits \u7279\u6027\u7ed3\u6784\u4f53"},{"location":"cute_mma/#3-mma_atom","text":"MMA_Atom \u5c06 Operation \u548c MMA_Traits \u7ed3\u5408\u8d77\u6765\uff0c\u63d0\u4f9b\u7edf\u4e00\u63a5\u53e3\uff1a \u8bbe\u8ba1\u539f\u56e0\uff1a \u7edf\u4e00\u5c01\u88c5Operation\u548cTraits\uff0c\u63d0\u4f9b\u4e00\u81f4\u7684API \u652f\u6301\u6a21\u677f\u7279\u5316\uff0c\u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u64cd\u4f5c\u8fdb\u884c\u4f18\u5316 \u63d0\u4f9bmake_fragment\u65b9\u6cd5\uff0c\u4fbf\u4e8e\u521b\u5efa\u9002\u5408\u7684\u5f20\u91cf\u7247\u6bb5 \u5b9e\u73b0call\u63a5\u53e3\uff0c\u7b80\u5316MMA\u64cd\u4f5c\u7684\u8c03\u7528 // \u4e3b\u6a21\u677f\uff0c\u901a\u8fc7MMA_Traits\u7279\u5316\u6765\u5b9e\u73b0\u5177\u4f53\u529f\u80fd template <class MMAOperation> struct MMA_Atom<MMAOperation> : MMA_Atom<MMA_Traits<MMAOperation>> {}; // \u7279\u5316\u7248\u672c\uff0c\u5b9e\u73b0\u5177\u4f53\u529f\u80fd template <class MMAOperation, class... Args> struct MMA_Atom<MMA_Traits<MMAOperation, Args...>> : MMA_Traits<MMAOperation, Args...> { // \u4eceTraits\u7ee7\u627f\u7c7b\u578b\u5b9a\u4e49 using ValTypeD = typename Traits::ValTypeD; using ValTypeA = typename Traits::ValTypeA; using ValTypeB = typename Traits::ValTypeB; using ValTypeC = typename Traits::ValTypeC; using Shape_MNK = typename Traits::Shape_MNK; using ThrID = typename Traits::ThrID; using LayoutC_TV = typename Traits::CLayout; using LayoutA_TV = typename Traits::ALayout; using LayoutB_TV = typename Traits::BLayout; // \u4e3b\u8981\u7684\u8c03\u7528\u63a5\u53e3 // \u63a5\u53d7\u56db\u4e2a\u5f20\u91cf\u53c2\u6570\uff1aD(\u8f93\u51fa), A(\u8f93\u5165), B(\u8f93\u5165), C(\u8f93\u5165/\u8f93\u51fa) template <class TD, class DLayout, class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE constexpr void call(Tensor<TD, DLayout> & D, Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> const& C) const { // \u9759\u6001\u65ad\u8a00\u786e\u4fdd\u5f20\u91cf\u662f\u4e00\u7ef4\u7684\uff08\u5bc4\u5b58\u5668\u7ea7\u64cd\u4f5c\uff09 static_assert(DLayout::rank == 1, \"Expected rank-1 D tensor\"); static_assert(ALayout::rank == 1, \"Expected rank-1 A tensor\"); static_assert(BLayout::rank == 1, \"Expected rank-1 B tensor\"); static_assert(CLayout::rank == 1, \"Expected rank-1 C tensor\"); // \u8c03\u7528\u5e95\u5c42\u7684mma_unpack\u51fd\u6570\u6267\u884c\u5b9e\u9645\u64cd\u4f5c return mma_unpack(static_cast<Traits const&>(*this), D, A, B, C); } // \u4e09\u4e2a\u53c2\u6570\u7684\u91cd\u8f7d\u7248\u672c\uff0c\u590d\u7528C\u4f5c\u4e3a\u8f93\u51fa template <class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE constexpr void call(Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> & C) const { // \u8c03\u7528\u56db\u53c2\u6570\u7248\u672c\uff0c\u5c06C\u540c\u65f6\u4f5c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa return call(C, A, B, C); } };","title":"3. MMA_Atom \u539f\u5b50\u64cd\u4f5c"},{"location":"cute_mma/#4-tiledmma","text":"TiledMMA \u5141\u8bb8\u5c06\u591a\u4e2a MMA_Atom \u7ec4\u5408\u6210\u66f4\u5927\u7684\u64cd\u4f5c\uff0c\u652f\u6301\u591a\u7ebf\u7a0b\u534f\u4f5c\uff1a \u8bbe\u8ba1\u539f\u56e0\uff1a \u652f\u6301\u66f4\u5927\u89c4\u6a21\u7684\u77e9\u9635\u8fd0\u7b97\uff0c\u8d85\u8d8a\u5355\u4e2aMMA\u6307\u4ee4\u7684\u80fd\u529b \u5b9e\u73b0\u7ebf\u7a0b\u7ea7\u522b\u7684\u5e76\u884c\u5316\uff0c\u63d0\u9ad8\u786c\u4ef6\u5229\u7528\u7387 \u63d0\u4f9b\u7075\u6d3b\u7684\u5e73\u94fa\u7b56\u7565\uff0c\u9002\u5e94\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40\u9700\u6c42 \u901a\u8fc7\u7ec4\u5408\u591a\u4e2aAtom\uff0c\u6784\u5efa\u66f4\u590d\u6742\u7684\u8ba1\u7b97\u6a21\u5f0f // TiledMMA\u6a21\u677f\u5b9a\u4e49 // MMA_Atom: \u57fa\u7840\u7684MMA\u64cd\u4f5c\u539f\u5b50 // AtomLayoutMNK: \u5728MNK\u7ef4\u5ea6\u4e0aAtom\u7684\u5e03\u5c40 // PermutationMNK: \u5e94\u7528\u4e8e\u6bcf\u4e2aMNK\u6a21\u5f0f\u7684\u6392\u5217 template <class MMA_Atom, class AtomLayoutMNK, class PermutationMNK = Tile<Underscore,Underscore,Underscore>> struct TiledMMA : MMA_Atom { // \u4eceMMA_Atom\u7ee7\u627f\u76f8\u5173\u7c7b\u578b using Atom = MMA_Atom; using AtomShape_MNK = typename MMA_Atom::Shape_MNK; using AtomThrID = typename MMA_Atom::ThrID; using AtomLayoutC_TV = typename MMA_Atom::LayoutC_TV; using AtomLayoutA_TV = typename MMA_Atom::LayoutA_TV; using AtomLayoutB_TV = typename MMA_Atom::LayoutB_TV; // \u7ebf\u7a0b\u5e03\u5c40\uff0c\u901a\u8fc7\u5c06AtomThrID\u4e0eAtomLayoutMNK\u8fdb\u884ctiled_product\u5f97\u5230 using ThrLayoutVMNK = decltype(tiled_product(AtomThrID{}, AtomLayoutMNK{})); ThrLayoutVMNK thr_layout_vmnk_; // \u6784\u9020\u51fd\u6570 CUTE_HOST_DEVICE constexpr TiledMMA(MMA_Atom const& mma_atom = {}, AtomLayoutMNK const& thr_layout_mnk = {}) : MMA_Atom(mma_atom), thr_layout_vmnk_(tiled_product(AtomThrID{}, thr_layout_mnk)) {} // \u83b7\u53d6\u7ebf\u7a0b\u5e03\u5c40 CUTE_HOST_DEVICE constexpr auto get_thr_layout_vmnk() const { return thr_layout_vmnk_; } // \u6839\u636e\u7ebf\u7a0b\u7d22\u5f15\u83b7\u53d6\u5207\u7247 template <class ThrIdx> CUTE_HOST_DEVICE constexpr auto get_slice(ThrIdx const& thr_idx) const { // \u5c06\u7ebf\u7a0b\u7d22\u5f15\u8f6c\u6362\u4e3aVMNK\u5750\u6807 auto thr_vmnk = thr_layout_vmnk_.get_flat_coord(thr_idx); // \u8fd4\u56deThrMMA\u5bf9\u8c61\uff0c\u7528\u4e8e\u7279\u5b9a\u7ebf\u7a0b\u7684\u64cd\u4f5c return ThrMMA<TiledMMA, decltype(thr_vmnk)>{*this, thr_vmnk}; } }; // ThrMMA\u4e3a\u7279\u5b9a\u7ebf\u7a0b\u63d0\u4f9b\u64cd\u4f5c\u63a5\u53e3 template <class TiledMMA, class ThrVMNK> struct ThrMMA : TiledMMA { ThrVMNK thr_vmnk_; // \u5206\u533aC\u77e9\u9635\uff0c\u4e3a\u5f53\u524d\u7ebf\u7a0b\u51c6\u5907\u6570\u636e template <class CTensor> CUTE_HOST_DEVICE constexpr auto partition_C(CTensor&& ctensor) const { // \u521b\u5efa\u5f20\u91cf\u5e76\u5e94\u7528thrfrg_C\u5e03\u5c40\u53d8\u6362 auto thr_tensor = make_tensor(static_cast<CTensor&&>(ctensor).data(), this->thrfrg_C(ctensor.layout())); // \u6784\u9020\u7ebf\u7a0b\u5750\u6807\u5e76\u83b7\u53d6\u5f53\u524d\u7ebf\u7a0b\u7684\u6570\u636e\u5207\u7247 auto thr_vmn = make_coord(get<0>(thr_vmnk_), make_coord(get<1>(thr_vmnk_), get<2>(thr_vmnk_))); return thr_tensor(thr_vmn, make_coord(_, repeat<rank<1,1>(thr_tensor)>(_))); } // \u7c7b\u4f3c\u5730\u5b9e\u73b0 partition_A \u548c partition_B };","title":"4. TiledMMA \u5e73\u94fa\u64cd\u4f5c"},{"location":"cute_mma/#algorithm-gemm","text":"CuTe \u63d0\u4f9b\u4e86\u7edf\u4e00\u7684 GEMM \u63a5\u53e3\uff0c\u53ef\u4ee5\u5904\u7406\u4e0d\u540c\u5c42\u6b21\u7684\u77e9\u9635\u4e58\u6cd5\u64cd\u4f5c\uff1a \u8bbe\u8ba1\u539f\u56e0\uff1a \u63d0\u4f9b\u7edf\u4e00\u7684\u63a5\u53e3\uff0c\u9690\u85cf\u5e95\u5c42\u5b9e\u73b0\u590d\u6742\u6027 \u652f\u6301\u591a\u79cd\u6570\u636e\u5e03\u5c40\u548c\u5185\u5b58\u7c7b\u578b \u6839\u636e\u5f20\u91cf\u7ef4\u5ea6\u548c\u5185\u5b58\u7c7b\u578b\u81ea\u52a8\u5206\u53d1\u5230\u5408\u9002\u7684\u5b9e\u73b0 \u5b9e\u73b0\u5bc4\u5b58\u5668\u7ea7\u548c\u5171\u4eab\u5185\u5b58\u7ea7\u64cd\u4f5c\u7684\u7edf\u4e00\u8c03\u7528 // \u57fa\u672c GEMM \u63a5\u53e3\uff0c\u4f7f\u7528\u901a\u7528FMA\u64cd\u4f5c template <class TD, class DLayout, class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE void gemm(Tensor<TD, DLayout> & D, Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> const& C) { // \u6839\u636e\u5f20\u91cf\u7684\u6570\u636e\u7c7b\u578b\u521b\u5efa\u5408\u9002\u7684MMA\u64cd\u4f5c using MMA = MMA_Atom<UniversalFMA<typename Tensor<TD,DLayout>::value_type, typename Tensor<TA,ALayout>::value_type, typename Tensor<TB,BLayout>::value_type, typename Tensor<TC,CLayout>::value_type>>; // \u8c03\u7528\u5177\u4f53\u7684GEMM\u5b9e\u73b0 return gemm(MMA{}, D, A, B, C); } // \u4f7f\u7528\u7279\u5b9a MMA_Atom \u7684 GEMM \u63a5\u53e3 template <class MMA, class TD, class DLayout, class TA, class ALayout, class TB, class BLayout, class TC, class CLayout> CUTE_HOST_DEVICE void gemm(MMA_Atom<MMA> const& mma, Tensor<TD, DLayout> & D, Tensor<TA, ALayout> const& A, Tensor<TB, BLayout> const& B, Tensor<TC, CLayout> const& C) { // \u6839\u636e\u5f20\u91cf\u7684\u7ef4\u5ea6\u548c\u5185\u5b58\u7c7b\u578b\u8fdb\u884c\u5206\u53d1 // Dispatch [1]: (V) x (V) => (V) - \u5143\u7d20\u7ea7\u4e58\u6cd5\uff0c\u76f4\u63a5\u8c03\u7528MMA\u539f\u5b50\u64cd\u4f5c // Dispatch [2]: (M) x (N) => (M,N) - \u5916\u79ef\uff0c\u8f6c\u6362\u4e3a\u77e9\u9635\u4e58\u6cd5 // Dispatch [3]: (M,K) x (N,K) => (M,N) - \u77e9\u9635\u4e58\u6cd5\uff0c\u6dfb\u52a0\u5411\u91cf\u7ef4\u5ea6 // Dispatch [4]: (V,M) x (V,N) => (V,M,N) - \u6279\u91cf\u5916\u79ef\uff0c\u6309\u5143\u7d20\u8fdb\u884c\u5bc4\u5b58\u5668\u4f18\u5316 // Dispatch [5]: (V,M,K) x (V,N,K) => (V,M,N) - \u6279\u91cf\u77e9\u9635\u4e58\u6cd5\uff0c\u6309K\u7ef4\u5ea6\u5faa\u73af\u5904\u7406 // \u8fd9\u79cd\u5206\u53d1\u673a\u5236\u4f7f\u5f97GEMM\u63a5\u53e3\u53ef\u4ee5\u5904\u7406\u4ece\u7b80\u5355\u5143\u7d20\u64cd\u4f5c\u5230\u590d\u6742\u6279\u91cf\u77e9\u9635\u8fd0\u7b97\u7684\u5404\u79cd\u60c5\u51b5 }","title":"Algorithm GEMM \u63a5\u53e3"},{"location":"cute_mma/#mma_atom","text":"MMA_Atom \u662f CuTe \u4e2d MMA \u64cd\u4f5c\u7684\u57fa\u672c\u6784\u5efa\u5757\u3002\u5b83\u5c01\u88c5\u4e86\uff1a \u5b9e\u9645\u7684 MMA \u6307\u4ee4\uff08\u5982 HMMA\u3001WMMA \u7b49\uff09 \u8f93\u5165\u548c\u8f93\u51fa\u7684\u5e03\u5c40\u4fe1\u606f MMA \u64cd\u4f5c\u7684\u7ea6\u675f\u6761\u4ef6 MMA_Atom \u53ef\u4ee5\u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\u67b6\u6784\u548c\u6570\u636e\u7c7b\u578b\u8fdb\u884c\u4f18\u5316\u3002","title":"MMA_Atom"},{"location":"cute_mma/#mma_1","text":"\u4e00\u4e2a\u5178\u578b\u7684 MMA \u64cd\u4f5c\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a // \u5b9a\u4e49\u8f93\u5165\u5f20\u91cf A\u3001B \u548c\u7d2f\u52a0\u5f20\u91cf C auto A_tensor = make_tensor(A_ptr, A_layout); auto B_tensor = make_tensor(B_ptr, B_layout); auto C_tensor = make_tensor(C_ptr, C_layout); // \u521b\u5efa MMA \u64cd\u4f5c\u5bf9\u8c61 auto mma_atom = MMA_Atom<SM70_8x8x4_F32F16F16F32_NT>{}; // \u83b7\u53d6 MMA \u64cd\u4f5c\u7684\u53c2\u4e0e\u8005 auto mma_thr = mma_atom.get_thread_slice(thread_idx); // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto accum_fragment = make_fragment_like(C_tensor); clear(accum_fragment); // \u6267\u884c MMA \u64cd\u4f5c mma_thr.call(A_tensor, B_tensor, accum_fragment);","title":"MMA \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_mma/#mma_thrcall-cutegemm","text":"\u867d\u7136\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 mma_thr.call() \u6267\u884c MMA \u64cd\u4f5c\uff0c\u4f46 CuTe \u4ecd\u7136\u63d0\u4f9b\u4e86 cute::gemm() \u63a5\u53e3\uff0c\u8fd9\u662f\u56e0\u4e3a\u4e24\u8005\u6709\u4e0d\u540c\u7684\u4f7f\u7528\u573a\u666f\u548c\u62bd\u8c61\u5c42\u6b21\uff1a","title":"mma_thr.call() \u4e0e cute::gemm() \u7684\u533a\u522b"},{"location":"cute_mma/#mma_thrcall","text":"\u4f4e\u7ea7\u63a5\u53e3 \uff1a\u76f4\u63a5\u64cd\u4f5c\u5bc4\u5b58\u5668\u7ea7\u522b\u7684\u5f20\u91cf\u7247\u6bb5 \u7cbe\u786e\u63a7\u5236 \uff1a\u9700\u8981\u624b\u52a8\u7ba1\u7406\u5f20\u91cf\u7684\u5206\u533a\u548c\u5e03\u5c40 \u786c\u4ef6\u76f8\u5173 \uff1a\u9700\u8981\u660e\u786e\u6307\u5b9a\u4f7f\u7528\u7684 MMA \u64cd\u4f5c\u7c7b\u578b \u9002\u5408\u573a\u666f \uff1a\u9700\u8981\u7cbe\u7ec6\u63a7\u5236\u8ba1\u7b97\u8fc7\u7a0b\u7684\u9ad8\u6027\u80fd\u573a\u666f","title":"mma_thr.call() \u7684\u7279\u70b9\uff1a"},{"location":"cute_mma/#cutegemm","text":"\u9ad8\u7ea7\u63a5\u53e3 \uff1a\u63d0\u4f9b\u7edf\u4e00\u7684 GEMM \u63a5\u53e3\uff0c\u81ea\u52a8\u5904\u7406\u5e95\u5c42\u7ec6\u8282 \u81ea\u52a8\u5206\u53d1 \uff1a\u6839\u636e\u5f20\u91cf\u7684\u7ef4\u5ea6\u548c\u5185\u5b58\u7c7b\u578b\u81ea\u52a8\u9009\u62e9\u5408\u9002\u7684\u5b9e\u73b0 \u7c7b\u578b\u63a8\u5bfc \uff1a\u53ef\u4ee5\u6839\u636e\u8f93\u5165\u5f20\u91cf\u7684\u7c7b\u578b\u81ea\u52a8\u63a8\u5bfc\u5408\u9002\u7684 MMA \u64cd\u4f5c \u7075\u6d3b\u9002\u914d \uff1a\u53ef\u4ee5\u5904\u7406\u4ece\u7b80\u5355\u5143\u7d20\u64cd\u4f5c\u5230\u590d\u6742\u6279\u91cf\u77e9\u9635\u8fd0\u7b97\u7684\u5404\u79cd\u60c5\u51b5 \u9002\u5408\u573a\u666f \uff1a\u901a\u7528\u7684\u77e9\u9635\u4e58\u6cd5\u8ba1\u7b97\uff0c\u7b80\u5316\u5f00\u53d1\u6d41\u7a0b","title":"cute::gemm() \u7684\u7279\u70b9\uff1a"},{"location":"cute_mma/#_1","text":"// \u5f53\u9700\u8981\u7cbe\u7ec6\u63a7\u5236\u65f6\uff0c\u4f7f\u7528 mma_thr.call() auto mma_atom = MMA_Atom<SM70_8x8x4_F32F16F16F32_NT>{}; auto mma_thr = mma_atom.get_thread_slice(thread_idx); mma_thr.call(A_frag, B_frag, C_frag); // \u5f53\u9700\u8981\u901a\u7528\u63a5\u53e3\u65f6\uff0c\u4f7f\u7528 cute::gemm() cute::gemm(D_tensor, A_tensor, B_tensor, C_tensor); \u603b\u7684\u6765\u8bf4\uff0c mma_thr.call() \u63d0\u4f9b\u4e86\u66f4\u5e95\u5c42\u3001\u66f4\u7cbe\u786e\u7684\u63a7\u5236\uff0c\u800c cute::gemm() \u63d0\u4f9b\u4e86\u66f4\u9ad8\u7ea7\u3001\u66f4\u901a\u7528\u7684\u63a5\u53e3\u3002\u5f00\u53d1\u8005\u53ef\u4ee5\u6839\u636e\u5177\u4f53\u9700\u6c42\u9009\u62e9\u5408\u9002\u7684\u63a5\u53e3\u3002","title":"\u4f7f\u7528\u5efa\u8bae\uff1a"},{"location":"cute_mma/#gmma-descriptor-swizzle","text":"\u5bf9\u4e8e Hopper (SM90) \u67b6\u6784\u4e2d\u7684 GMMA \u64cd\u4f5c\uff0c\u8bf7\u53c2\u8003\u4e13\u95e8\u7684\u6587\u6863\uff1a CuTe WGmma SM90","title":"GMMA Descriptor \u4e0e Swizzle \u4fe1\u606f"},{"location":"cute_mma/#accumulator-fragment","text":"\u5728 MMA \u64cd\u4f5c\u4e2d\uff0c\u7d2f\u52a0\u7247\u6bb5\u662f\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\u3002\u5b83\u4ee3\u8868\u4e86\u7d2f\u52a0\u5668\u5bc4\u5b58\u5668\u4e2d\u7684\u6570\u636e\u5757\u3002CuTe \u63d0\u4f9b\u4e86\u4e13\u95e8\u7684\u7c7b\u578b\u548c\u64cd\u4f5c\u6765\u5904\u7406\u7d2f\u52a0\u7247\u6bb5\uff1a // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto accum_fragment = make_fragment_like(C_tensor); // \u521d\u59cb\u5316\u7d2f\u52a0\u7247\u6bb5 clear(accum_fragment); // \u6267\u884c\u591a\u6b21 MMA \u64cd\u4f5c\u7d2f\u52a0\u7ed3\u679c mma_thr.call(A_tensor, B_tensor, accum_fragment, accum_fragment);","title":"\u7d2f\u52a0\u7247\u6bb5 (Accumulator Fragment)"},{"location":"cute_mma/#copy","text":"\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0cMMA \u64cd\u4f5c\u901a\u5e38\u4e0e Copy \u64cd\u4f5c\u534f\u540c\u5de5\u4f5c\uff1a \u4f7f\u7528 Copy \u64cd\u4f5c\u5c06\u6570\u636e\u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u5230\u5171\u4eab\u5185\u5b58\u6216\u5bc4\u5b58\u5668 \u4f7f\u7528 MMA \u64cd\u4f5c\u6267\u884c\u8ba1\u7b97 \u4f7f\u7528 Copy \u64cd\u4f5c\u5c06\u7ed3\u679c\u4ece\u5bc4\u5b58\u5668\u5199\u56de\u5230\u5168\u5c40\u5185\u5b58 \u8fd9\u79cd\u534f\u540c\u5de5\u4f5c\u6a21\u5f0f\u5145\u5206\u5229\u7528\u4e86 GPU \u7684\u5185\u5b58\u5c42\u6b21\u7ed3\u6784\u548c\u8ba1\u7b97\u80fd\u529b\u3002","title":"\u4e0e Copy \u64cd\u4f5c\u7684\u534f\u540c"},{"location":"cute_mma/#_2","text":"CuTe \u652f\u6301\u591a\u79cd NVIDIA GPU \u67b6\u6784\u7684 MMA \u6307\u4ee4\uff1a","title":"\u4e0d\u540c\u67b6\u6784\u7684\u652f\u6301"},{"location":"cute_mma/#volta-sm70","text":"\u4f7f\u7528 HMMA \u6307\u4ee4 8\u4e2a\u7ebf\u7a0b\u7684 quadpair \u534f\u4f5c\u5b8c\u6210 8x8x4 \u7684\u77e9\u9635\u4e58\u6cd5","title":"Volta (SM70)"},{"location":"cute_mma/#turing-sm75","text":"\u589e\u5f3a\u7684 HMMA \u6307\u4ee4\u652f\u6301","title":"Turing (SM75)"},{"location":"cute_mma/#ampere-sm80","text":"\u66f4\u591a\u7684 MMA \u6307\u4ee4\u53d8\u4f53 \u5bf9\u7a00\u758f\u77e9\u9635\u4e58\u6cd5\u7684\u652f\u6301","title":"Ampere (SM80)"},{"location":"cute_mma/#hopper-sm90","text":"\u5f15\u5165\u4e86\u65b0\u4e00\u4ee3\u7684 GMMA (Group MMA) \u6307\u4ee4 \u652f\u6301\u66f4\u5927\u7684\u77e9\u9635\u64cd\u4f5c (\u5982 64x128x16) warpgroup \u7ea7\u522b\u7684\u534f\u4f5c (128\u4e2a\u7ebf\u7a0b)","title":"Hopper (SM90)"},{"location":"cute_mma/#_3","text":"CuTe \u7684 MMA \u64cd\u4f5c\u5177\u6709\u4ee5\u4e0b\u9ad8\u7ea7\u7279\u6027\uff1a","title":"\u9ad8\u7ea7\u7279\u6027"},{"location":"cute_mma/#_4","text":"\u901a\u8fc7 TiledMMA\uff0c\u53ef\u4ee5\u8f7b\u677e\u5730\u6269\u5c55\u57fa\u672c\u7684 MMA \u64cd\u4f5c\u4ee5\u9002\u5e94\u66f4\u5927\u7684\u77e9\u9635\u8ba1\u7b97\u9700\u6c42\u3002","title":"\u53ef\u6269\u5c55\u6027"},{"location":"cute_mma/#_5","text":"CuTe \u7684 Layout \u7cfb\u7edf\u4f7f\u5f97\u53ef\u4ee5\u7075\u6d3b\u5730\u5904\u7406\u4e0d\u540c\u7684\u6570\u636e\u5e03\u5c40\uff0c\u5305\u62ec\u884c\u4e3b\u5e8f\u3001\u5217\u4e3b\u5e8f\u4ee5\u53ca\u81ea\u5b9a\u4e49\u5e03\u5c40\u3002","title":"\u7075\u6d3b\u7684\u5e03\u5c40\u652f\u6301"},{"location":"cute_mma/#_6","text":"\u901a\u8fc7\u6a21\u677f\u548c\u7c7b\u578b\u7cfb\u7edf\uff0c\u786e\u4fdd\u5728\u7f16\u8bd1\u65f6\u5c31\u80fd\u53d1\u73b0\u7c7b\u578b\u4e0d\u5339\u914d\u7684\u9519\u8bef\u3002 \u8fd9\u4e9b\u62bd\u8c61\u4f7f\u5f97\u5f00\u53d1\u8005\u53ef\u4ee5\u7f16\u5199\u9ad8\u6548\u4e14\u53ef\u7ef4\u62a4\u7684 CUDA \u4ee3\u7801\uff0c\u540c\u65f6\u5145\u5206\u5229\u7528\u73b0\u4ee3 GPU \u7684\u8ba1\u7b97\u80fd\u529b\u3002","title":"\u7c7b\u578b\u5b89\u5168"},{"location":"cute_tensor/","text":"CuTe Tensor \u5f20\u91cf\u64cd\u4f5c Tensor \u662f CuTe \u4e2d\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u7ed3\u5408\u4e86\u6570\u636e\u6307\u9488\u548c Layout\uff0c\u63d0\u4f9b\u4e86\u5bf9\u591a\u7ef4\u6570\u636e\u7684\u9ad8\u6548\u8bbf\u95ee\u548c\u64cd\u4f5c\u3002 Tensor \u57fa\u672c\u6982\u5ff5 Tensor \u7531\u4e24\u4e2a\u4e3b\u8981\u7ec4\u4ef6\u6784\u6210\uff1a Engine \uff1a\u7ba1\u7406\u6570\u636e\u7684\u5b58\u50a8\u548c\u8bbf\u95ee Layout \uff1a\u5b9a\u4e49\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04 Tensor \u7684\u6570\u5b66\u8868\u793a Tensor \u53ef\u4ee5\u8868\u793a\u4e3a\uff1a T(c) = E(L(c)) \u5176\u4e2d\uff1a - T(c) \u662f Tensor \u5728\u5750\u6807 c \u5904\u7684\u503c - E \u662f Engine\uff0c\u8d1f\u8d23\u6570\u636e\u8bbf\u95ee - L(c) \u662f Layout\uff0c\u5c06\u903b\u8f91\u5750\u6807 c \u6620\u5c04\u5230\u7ebf\u6027\u4f4d\u7f6e Tensor \u7684\u521b\u5efa Tensor \u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u521b\u5efa\uff0c\u9002\u5e94\u4e0d\u540c\u7684\u5185\u5b58\u7a7a\u95f4\u548c\u4f7f\u7528\u573a\u666f\u3002 \u57fa\u672c Tensor \u521b\u5efa // \u521b\u5efa\u5168\u5c40\u5185\u5b58 Tensor auto gmem_ptr = make_gmem_ptr<float>(ptr); auto gmem_tensor = make_tensor(gmem_ptr, make_layout(make_shape(128, 64), GenRowMajor{})); // \u521b\u5efa\u5171\u4eab\u5185\u5b58 Tensor extern __shared__ float smem[]; auto smem_ptr = make_smem_ptr<float>(smem); auto smem_tensor = make_tensor(smem_ptr, make_layout(make_shape(32, 32), GenRowMajor{})); // \u521b\u5efa\u5bc4\u5b58\u5668 Tensor float reg_data[8]; auto reg_tensor = make_tensor(reg_data, make_layout(make_shape(2, 4), GenRowMajor{})); \u4e0d\u540c\u5185\u5b58\u7a7a\u95f4\u7684 Tensor \u5168\u5c40\u5185\u5b58 Tensor \uff1a\u4f7f\u7528 make_gmem_ptr \u521b\u5efa \u5171\u4eab\u5185\u5b58 Tensor \uff1a\u4f7f\u7528 make_smem_ptr \u521b\u5efa \u5bc4\u5b58\u5668 Tensor \uff1a\u76f4\u63a5\u4f7f\u7528\u6570\u7ec4\u521b\u5efa Tensor \u64cd\u4f5c CuTe \u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684 Tensor \u64cd\u4f5c\u51fd\u6570\u3002 \u57fa\u672c\u8bbf\u95ee\u64cd\u4f5c // \u901a\u8fc7\u5750\u6807\u8bbf\u95ee\u5143\u7d20 auto value = tensor(0, 1); // \u8bbf\u95ee (0,1) \u4f4d\u7f6e\u7684\u5143\u7d20 // \u901a\u8fc7\u7ebf\u6027\u7d22\u5f15\u8bbf\u95ee\u5143\u7d20 auto value = tensor(5); // \u8bbf\u95ee\u7ebf\u6027\u7d22\u5f15\u4e3a 5 \u7684\u5143\u7d20 // \u83b7\u53d6\u5b50\u5f20\u91cf auto sub_tensor = tensor(_, 2); // \u83b7\u53d6\u7b2c\u4e8c\u5217\u7684\u6240\u6709\u5143\u7d20 Tensor \u53d8\u6362\u64cd\u4f5c \u5207\u7247\u64cd\u4f5c \uff1a\u63d0\u53d6 Tensor \u7684\u4e00\u90e8\u5206 \u91cd\u5851\u64cd\u4f5c \uff1a\u6539\u53d8 Tensor \u7684\u5f62\u72b6 \u8f6c\u7f6e\u64cd\u4f5c \uff1a\u4ea4\u6362 Tensor \u7684\u7ef4\u5ea6 Tensor \u53d8\u6362\u793a\u4f8b // \u521b\u5efa\u4e00\u4e2a 4x4 Tensor auto tensor_4x4 = make_tensor(ptr, make_layout(make_shape(4, 4), GenRowMajor{})); // \u5207\u7247\u64cd\u4f5c\uff1a\u83b7\u53d6\u524d\u4e24\u884c auto top_half = tensor_4x4(make_range(0, 2), _); // \u91cd\u5851\u64cd\u4f5c\uff1a\u5c06 4x4 \u91cd\u5851\u4e3a 2x8 auto tensor_2x8 = reshape(tensor_4x4, make_layout(make_shape(2, 8))); // \u8f6c\u7f6e\u64cd\u4f5c auto tensor_4x4_t = transpose(tensor_4x4); Tensor \u4e0e Layout \u7684\u5173\u7cfb Tensor \u7684\u884c\u4e3a\u5f88\u5927\u7a0b\u5ea6\u4e0a\u7531\u5176 Layout \u51b3\u5b9a\u3002 Layout \u5bf9 Tensor \u7684\u5f71\u54cd \u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \uff1aLayout \u51b3\u5b9a\u4e86\u5982\u4f55\u5c06\u903b\u8f91\u5750\u6807\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u5730\u5740 \u6570\u636e\u91cd\u6392 \uff1a\u901a\u8fc7\u4e0d\u540c\u7684 Layout \u5b9e\u73b0\u6570\u636e\u7684\u91cd\u6392 \u6027\u80fd\u4f18\u5316 \uff1a\u5408\u7406\u7684 Layout \u8bbe\u8ba1\u53ef\u4ee5\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u6027\u80fd Layout \u5f71\u54cd\u793a\u4f8b // \u884c\u4e3b\u5e8f Layout auto row_major_tensor = make_tensor(ptr, make_layout(make_shape(4, 4), GenRowMajor{})); // \u8bbf\u95ee\u6a21\u5f0f\uff1a(0,0), (0,1), (0,2), (0,3), (1,0), (1,1)... // \u5217\u4e3b\u5e8f Layout auto col_major_tensor = make_tensor(ptr, make_layout(make_shape(4, 4), GenColMajor{})); // \u8bbf\u95ee\u6a21\u5f0f\uff1a(0,0), (1,0), (2,0), (3,0), (0,1), (1,1)... Tensor \u5728 Copy \u64cd\u4f5c\u4e2d\u7684\u5e94\u7528 Tensor \u5728 Copy \u64cd\u4f5c\u4e2d\u8d77\u7740\u6838\u5fc3\u4f5c\u7528\uff0c\u5b9a\u4e49\u4e86\u6e90\u548c\u76ee\u6807\u6570\u636e\u7684\u7ed3\u6784\u3002 Copy \u64cd\u4f5c\u793a\u4f8b // \u5b9a\u4e49\u6e90\u548c\u76ee\u6807 Tensor auto src_tensor = make_tensor(src_ptr, make_layout(make_shape(16, 16), GenRowMajor{})); auto dst_tensor = make_tensor(dst_ptr, make_layout(make_shape(16, 16), GenColMajor{})); // \u6267\u884c Copy \u64cd\u4f5c\uff08\u5305\u542b\u8f6c\u7f6e\uff09 copy(src_tensor, dst_tensor); Tensor \u5728 MMA \u64cd\u4f5c\u4e2d\u7684\u5e94\u7528 \u5728 MMA (Matrix Multiply-Accumulate) \u64cd\u4f5c\u4e2d\uff0cTensor \u7528\u4e8e\u8868\u793a\u77e9\u9635\u7684\u8f93\u5165\u548c\u8f93\u51fa\u3002 MMA \u64cd\u4f5c\u793a\u4f8b // \u5b9a\u4e49 MMA \u64cd\u4f5c\u7684\u8f93\u5165 Tensor auto A_tensor = make_tensor(A_ptr, make_layout(make_shape(8, 4), GenRowMajor{})); auto B_tensor = make_tensor(B_ptr, make_layout(make_shape(8, 4), GenColMajor{})); auto C_tensor = make_tensor(C_ptr, make_layout(make_shape(8, 8), GenRowMajor{})); // \u6267\u884c MMA \u64cd\u4f5c mma(A_tensor, B_tensor, C_tensor); \u9ad8\u7ea7 Tensor \u64cd\u4f5c CuTe \u63d0\u4f9b\u4e86\u4e00\u4e9b\u9ad8\u7ea7 Tensor \u64cd\u4f5c\uff0c\u7528\u4e8e\u590d\u6742\u573a\u666f\u3002 \u5f20\u91cf\u5206\u5757 // \u521b\u5efa\u5927\u5f20\u91cf auto big_tensor = make_tensor(ptr, make_layout(make_shape(128, 128), GenRowMajor{})); // \u5206\u5757\u64cd\u4f5c auto tile = local_tile(big_tensor, make_shape(32, 32), make_coord(1, 2)); // \u83b7\u53d6\u5750\u6807 (1,2) \u5904\u7684 32x32 \u5b50\u5757 \u5f20\u91cf\u7ec4\u5408 // \u7ec4\u5408\u591a\u4e2a\u5f20\u91cf auto combined_tensor = make_tensor(ptr, make_layout( make_shape(Shape<_2,_3>{}, Shape<_4,_5>{}), make_stride(Stride<_1,_6>{}, Stride<_2,_7>{}))); Tensor \u7684\u6027\u80fd\u8003\u8651 \u5728\u4f7f\u7528 Tensor \u65f6\uff0c\u9700\u8981\u8003\u8651\u4ee5\u4e0b\u6027\u80fd\u56e0\u7d20\uff1a 1. \u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \u5408\u7406\u7684 Layout \u8bbe\u8ba1\u53ef\u4ee5\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u63d0\u9ad8\u7f13\u5b58\u547d\u4e2d\u7387\u3002 2. \u6570\u636e\u5bf9\u9f50 \u786e\u4fdd Tensor \u6570\u636e\u5728\u5185\u5b58\u4e2d\u6b63\u786e\u5bf9\u9f50\uff0c\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 3. \u5411\u91cf\u5316\u8bbf\u95ee \u901a\u8fc7\u5408\u9002\u7684 Layout \u5b9e\u73b0\u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\u3002 \u6027\u80fd\u4f18\u5316\u793a\u4f8b // \u4f18\u5316\u524d\uff1a\u975e\u5bf9\u9f50\u8bbf\u95ee auto slow_tensor = make_tensor(ptr+1, make_layout(make_shape(16, 16), GenRowMajor{})); // \u4f18\u5316\u540e\uff1a\u5bf9\u9f50\u8bbf\u95ee auto fast_tensor = make_tensor(ptr, make_layout(make_shape(16, 16), GenRowMajor{})); Tensor \u4e0e\u7ebf\u7a0b\u534f\u4f5c \u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e2d\uff0cTensor \u53ef\u4ee5\u4e0e\u7ebf\u7a0b\u534f\u4f5c\u5b9e\u73b0\u5e76\u884c\u8ba1\u7b97\u3002 \u7ebf\u7a0b\u5207\u7247 // \u521b\u5efa TiledCopy auto tiled_copy = make_tiled_copy(CopyAtom{}, make_shape(32, 32), make_shape(4, 8)); // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto thread_slice = tiled_copy.get_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto src_frag = thread_slice.partition_S(src_tensor); auto dst_frag = thread_slice.partition_D(dst_tensor); Tensor \u662f CuTe \u7cfb\u7edf\u4e2d\u7684\u6838\u5fc3\u62bd\u8c61\uff0c\u901a\u8fc7\u4e0e Layout \u548c Engine \u7684\u7ed3\u5408\uff0c\u63d0\u4f9b\u4e86\u5bf9\u591a\u7ef4\u6570\u636e\u7684\u5f3a\u5927\u64cd\u4f5c\u80fd\u529b\u3002\u7406\u89e3 Tensor \u7684\u5de5\u4f5c\u673a\u5236\u5bf9\u4e8e\u9ad8\u6548\u4f7f\u7528 CuTe \u81f3\u5173\u91cd\u8981\u3002","title":"Tensor \u5f20\u91cf\u64cd\u4f5c"},{"location":"cute_tensor/#cute-tensor","text":"Tensor \u662f CuTe \u4e2d\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u7ed3\u5408\u4e86\u6570\u636e\u6307\u9488\u548c Layout\uff0c\u63d0\u4f9b\u4e86\u5bf9\u591a\u7ef4\u6570\u636e\u7684\u9ad8\u6548\u8bbf\u95ee\u548c\u64cd\u4f5c\u3002","title":"CuTe Tensor \u5f20\u91cf\u64cd\u4f5c"},{"location":"cute_tensor/#tensor","text":"Tensor \u7531\u4e24\u4e2a\u4e3b\u8981\u7ec4\u4ef6\u6784\u6210\uff1a Engine \uff1a\u7ba1\u7406\u6570\u636e\u7684\u5b58\u50a8\u548c\u8bbf\u95ee Layout \uff1a\u5b9a\u4e49\u903b\u8f91\u5750\u6807\u5230\u7ebf\u6027\u5185\u5b58\u4f4d\u7f6e\u7684\u6620\u5c04","title":"Tensor \u57fa\u672c\u6982\u5ff5"},{"location":"cute_tensor/#tensor_1","text":"Tensor \u53ef\u4ee5\u8868\u793a\u4e3a\uff1a T(c) = E(L(c)) \u5176\u4e2d\uff1a - T(c) \u662f Tensor \u5728\u5750\u6807 c \u5904\u7684\u503c - E \u662f Engine\uff0c\u8d1f\u8d23\u6570\u636e\u8bbf\u95ee - L(c) \u662f Layout\uff0c\u5c06\u903b\u8f91\u5750\u6807 c \u6620\u5c04\u5230\u7ebf\u6027\u4f4d\u7f6e","title":"Tensor \u7684\u6570\u5b66\u8868\u793a"},{"location":"cute_tensor/#tensor_2","text":"Tensor \u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u521b\u5efa\uff0c\u9002\u5e94\u4e0d\u540c\u7684\u5185\u5b58\u7a7a\u95f4\u548c\u4f7f\u7528\u573a\u666f\u3002","title":"Tensor \u7684\u521b\u5efa"},{"location":"cute_tensor/#tensor_3","text":"// \u521b\u5efa\u5168\u5c40\u5185\u5b58 Tensor auto gmem_ptr = make_gmem_ptr<float>(ptr); auto gmem_tensor = make_tensor(gmem_ptr, make_layout(make_shape(128, 64), GenRowMajor{})); // \u521b\u5efa\u5171\u4eab\u5185\u5b58 Tensor extern __shared__ float smem[]; auto smem_ptr = make_smem_ptr<float>(smem); auto smem_tensor = make_tensor(smem_ptr, make_layout(make_shape(32, 32), GenRowMajor{})); // \u521b\u5efa\u5bc4\u5b58\u5668 Tensor float reg_data[8]; auto reg_tensor = make_tensor(reg_data, make_layout(make_shape(2, 4), GenRowMajor{}));","title":"\u57fa\u672c Tensor \u521b\u5efa"},{"location":"cute_tensor/#tensor_4","text":"\u5168\u5c40\u5185\u5b58 Tensor \uff1a\u4f7f\u7528 make_gmem_ptr \u521b\u5efa \u5171\u4eab\u5185\u5b58 Tensor \uff1a\u4f7f\u7528 make_smem_ptr \u521b\u5efa \u5bc4\u5b58\u5668 Tensor \uff1a\u76f4\u63a5\u4f7f\u7528\u6570\u7ec4\u521b\u5efa","title":"\u4e0d\u540c\u5185\u5b58\u7a7a\u95f4\u7684 Tensor"},{"location":"cute_tensor/#tensor_5","text":"CuTe \u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684 Tensor \u64cd\u4f5c\u51fd\u6570\u3002","title":"Tensor \u64cd\u4f5c"},{"location":"cute_tensor/#_1","text":"// \u901a\u8fc7\u5750\u6807\u8bbf\u95ee\u5143\u7d20 auto value = tensor(0, 1); // \u8bbf\u95ee (0,1) \u4f4d\u7f6e\u7684\u5143\u7d20 // \u901a\u8fc7\u7ebf\u6027\u7d22\u5f15\u8bbf\u95ee\u5143\u7d20 auto value = tensor(5); // \u8bbf\u95ee\u7ebf\u6027\u7d22\u5f15\u4e3a 5 \u7684\u5143\u7d20 // \u83b7\u53d6\u5b50\u5f20\u91cf auto sub_tensor = tensor(_, 2); // \u83b7\u53d6\u7b2c\u4e8c\u5217\u7684\u6240\u6709\u5143\u7d20","title":"\u57fa\u672c\u8bbf\u95ee\u64cd\u4f5c"},{"location":"cute_tensor/#tensor_6","text":"\u5207\u7247\u64cd\u4f5c \uff1a\u63d0\u53d6 Tensor \u7684\u4e00\u90e8\u5206 \u91cd\u5851\u64cd\u4f5c \uff1a\u6539\u53d8 Tensor \u7684\u5f62\u72b6 \u8f6c\u7f6e\u64cd\u4f5c \uff1a\u4ea4\u6362 Tensor \u7684\u7ef4\u5ea6","title":"Tensor \u53d8\u6362\u64cd\u4f5c"},{"location":"cute_tensor/#tensor_7","text":"// \u521b\u5efa\u4e00\u4e2a 4x4 Tensor auto tensor_4x4 = make_tensor(ptr, make_layout(make_shape(4, 4), GenRowMajor{})); // \u5207\u7247\u64cd\u4f5c\uff1a\u83b7\u53d6\u524d\u4e24\u884c auto top_half = tensor_4x4(make_range(0, 2), _); // \u91cd\u5851\u64cd\u4f5c\uff1a\u5c06 4x4 \u91cd\u5851\u4e3a 2x8 auto tensor_2x8 = reshape(tensor_4x4, make_layout(make_shape(2, 8))); // \u8f6c\u7f6e\u64cd\u4f5c auto tensor_4x4_t = transpose(tensor_4x4);","title":"Tensor \u53d8\u6362\u793a\u4f8b"},{"location":"cute_tensor/#tensor-layout","text":"Tensor \u7684\u884c\u4e3a\u5f88\u5927\u7a0b\u5ea6\u4e0a\u7531\u5176 Layout \u51b3\u5b9a\u3002","title":"Tensor \u4e0e Layout \u7684\u5173\u7cfb"},{"location":"cute_tensor/#layout-tensor","text":"\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \uff1aLayout \u51b3\u5b9a\u4e86\u5982\u4f55\u5c06\u903b\u8f91\u5750\u6807\u6620\u5c04\u5230\u7269\u7406\u5185\u5b58\u5730\u5740 \u6570\u636e\u91cd\u6392 \uff1a\u901a\u8fc7\u4e0d\u540c\u7684 Layout \u5b9e\u73b0\u6570\u636e\u7684\u91cd\u6392 \u6027\u80fd\u4f18\u5316 \uff1a\u5408\u7406\u7684 Layout \u8bbe\u8ba1\u53ef\u4ee5\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u6027\u80fd","title":"Layout \u5bf9 Tensor \u7684\u5f71\u54cd"},{"location":"cute_tensor/#layout","text":"// \u884c\u4e3b\u5e8f Layout auto row_major_tensor = make_tensor(ptr, make_layout(make_shape(4, 4), GenRowMajor{})); // \u8bbf\u95ee\u6a21\u5f0f\uff1a(0,0), (0,1), (0,2), (0,3), (1,0), (1,1)... // \u5217\u4e3b\u5e8f Layout auto col_major_tensor = make_tensor(ptr, make_layout(make_shape(4, 4), GenColMajor{})); // \u8bbf\u95ee\u6a21\u5f0f\uff1a(0,0), (1,0), (2,0), (3,0), (0,1), (1,1)...","title":"Layout \u5f71\u54cd\u793a\u4f8b"},{"location":"cute_tensor/#tensor-copy","text":"Tensor \u5728 Copy \u64cd\u4f5c\u4e2d\u8d77\u7740\u6838\u5fc3\u4f5c\u7528\uff0c\u5b9a\u4e49\u4e86\u6e90\u548c\u76ee\u6807\u6570\u636e\u7684\u7ed3\u6784\u3002","title":"Tensor \u5728 Copy \u64cd\u4f5c\u4e2d\u7684\u5e94\u7528"},{"location":"cute_tensor/#copy","text":"// \u5b9a\u4e49\u6e90\u548c\u76ee\u6807 Tensor auto src_tensor = make_tensor(src_ptr, make_layout(make_shape(16, 16), GenRowMajor{})); auto dst_tensor = make_tensor(dst_ptr, make_layout(make_shape(16, 16), GenColMajor{})); // \u6267\u884c Copy \u64cd\u4f5c\uff08\u5305\u542b\u8f6c\u7f6e\uff09 copy(src_tensor, dst_tensor);","title":"Copy \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_tensor/#tensor-mma","text":"\u5728 MMA (Matrix Multiply-Accumulate) \u64cd\u4f5c\u4e2d\uff0cTensor \u7528\u4e8e\u8868\u793a\u77e9\u9635\u7684\u8f93\u5165\u548c\u8f93\u51fa\u3002","title":"Tensor \u5728 MMA \u64cd\u4f5c\u4e2d\u7684\u5e94\u7528"},{"location":"cute_tensor/#mma","text":"// \u5b9a\u4e49 MMA \u64cd\u4f5c\u7684\u8f93\u5165 Tensor auto A_tensor = make_tensor(A_ptr, make_layout(make_shape(8, 4), GenRowMajor{})); auto B_tensor = make_tensor(B_ptr, make_layout(make_shape(8, 4), GenColMajor{})); auto C_tensor = make_tensor(C_ptr, make_layout(make_shape(8, 8), GenRowMajor{})); // \u6267\u884c MMA \u64cd\u4f5c mma(A_tensor, B_tensor, C_tensor);","title":"MMA \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_tensor/#tensor_8","text":"CuTe \u63d0\u4f9b\u4e86\u4e00\u4e9b\u9ad8\u7ea7 Tensor \u64cd\u4f5c\uff0c\u7528\u4e8e\u590d\u6742\u573a\u666f\u3002","title":"\u9ad8\u7ea7 Tensor \u64cd\u4f5c"},{"location":"cute_tensor/#_2","text":"// \u521b\u5efa\u5927\u5f20\u91cf auto big_tensor = make_tensor(ptr, make_layout(make_shape(128, 128), GenRowMajor{})); // \u5206\u5757\u64cd\u4f5c auto tile = local_tile(big_tensor, make_shape(32, 32), make_coord(1, 2)); // \u83b7\u53d6\u5750\u6807 (1,2) \u5904\u7684 32x32 \u5b50\u5757","title":"\u5f20\u91cf\u5206\u5757"},{"location":"cute_tensor/#_3","text":"// \u7ec4\u5408\u591a\u4e2a\u5f20\u91cf auto combined_tensor = make_tensor(ptr, make_layout( make_shape(Shape<_2,_3>{}, Shape<_4,_5>{}), make_stride(Stride<_1,_6>{}, Stride<_2,_7>{})));","title":"\u5f20\u91cf\u7ec4\u5408"},{"location":"cute_tensor/#tensor_9","text":"\u5728\u4f7f\u7528 Tensor \u65f6\uff0c\u9700\u8981\u8003\u8651\u4ee5\u4e0b\u6027\u80fd\u56e0\u7d20\uff1a","title":"Tensor \u7684\u6027\u80fd\u8003\u8651"},{"location":"cute_tensor/#1","text":"\u5408\u7406\u7684 Layout \u8bbe\u8ba1\u53ef\u4ee5\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u63d0\u9ad8\u7f13\u5b58\u547d\u4e2d\u7387\u3002","title":"1. \u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f"},{"location":"cute_tensor/#2","text":"\u786e\u4fdd Tensor \u6570\u636e\u5728\u5185\u5b58\u4e2d\u6b63\u786e\u5bf9\u9f50\uff0c\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002","title":"2. \u6570\u636e\u5bf9\u9f50"},{"location":"cute_tensor/#3","text":"\u901a\u8fc7\u5408\u9002\u7684 Layout \u5b9e\u73b0\u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\u3002","title":"3. \u5411\u91cf\u5316\u8bbf\u95ee"},{"location":"cute_tensor/#_4","text":"// \u4f18\u5316\u524d\uff1a\u975e\u5bf9\u9f50\u8bbf\u95ee auto slow_tensor = make_tensor(ptr+1, make_layout(make_shape(16, 16), GenRowMajor{})); // \u4f18\u5316\u540e\uff1a\u5bf9\u9f50\u8bbf\u95ee auto fast_tensor = make_tensor(ptr, make_layout(make_shape(16, 16), GenRowMajor{}));","title":"\u6027\u80fd\u4f18\u5316\u793a\u4f8b"},{"location":"cute_tensor/#tensor_10","text":"\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e2d\uff0cTensor \u53ef\u4ee5\u4e0e\u7ebf\u7a0b\u534f\u4f5c\u5b9e\u73b0\u5e76\u884c\u8ba1\u7b97\u3002","title":"Tensor \u4e0e\u7ebf\u7a0b\u534f\u4f5c"},{"location":"cute_tensor/#_5","text":"// \u521b\u5efa TiledCopy auto tiled_copy = make_tiled_copy(CopyAtom{}, make_shape(32, 32), make_shape(4, 8)); // \u83b7\u53d6\u7ebf\u7a0b\u5207\u7247 auto thread_slice = tiled_copy.get_slice(threadIdx.x); // \u5206\u533a\u5f20\u91cf auto src_frag = thread_slice.partition_S(src_tensor); auto dst_frag = thread_slice.partition_D(dst_tensor); Tensor \u662f CuTe \u7cfb\u7edf\u4e2d\u7684\u6838\u5fc3\u62bd\u8c61\uff0c\u901a\u8fc7\u4e0e Layout \u548c Engine \u7684\u7ed3\u5408\uff0c\u63d0\u4f9b\u4e86\u5bf9\u591a\u7ef4\u6570\u636e\u7684\u5f3a\u5927\u64cd\u4f5c\u80fd\u529b\u3002\u7406\u89e3 Tensor \u7684\u5de5\u4f5c\u673a\u5236\u5bf9\u4e8e\u9ad8\u6548\u4f7f\u7528 CuTe \u81f3\u5173\u91cd\u8981\u3002","title":"\u7ebf\u7a0b\u5207\u7247"},{"location":"cute_tma_copy/","text":"CuTe TMA Copy \u64cd\u4f5c\u8be6\u89e3 TMA (Tensor Memory Access) \u662f NVIDIA Hopper \u67b6\u6784\u5f15\u5165\u7684\u4e00\u79cd\u65b0\u7684\u5185\u5b58\u8bbf\u95ee\u6280\u672f\u3002\u5b83\u5141\u8bb8\u7ebf\u7a0b\u5757(cluster)\u76f4\u63a5\u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58\uff0c\u6216\u8005\u4ece\u5171\u4eab\u5185\u5b58\u5b58\u50a8\u6570\u636e\u5230\u5168\u5c40\u5185\u5b58\uff0c\u800c\u65e0\u9700\u663e\u5f0f\u5730\u901a\u8fc7\u6bcf\u4e2a\u7ebf\u7a0b\u8fdb\u884c\u590d\u5236\u3002 TMA \u57fa\u672c\u6982\u5ff5 TMA \u64cd\u4f5c\u901a\u8fc7\u4e13\u7528\u786c\u4ef6\u5355\u5143\u6267\u884c\uff0c\u53ef\u4ee5\u76f4\u63a5\u5728\u5168\u5c40\u5185\u5b58\u548c\u5171\u4eab\u5185\u5b58\u4e4b\u95f4\u4f20\u8f93\u6570\u636e\u3002\u8fd9\u4e0e\u4f20\u7edf\u7684\u7531 CUDA \u7ebf\u7a0b\u6267\u884c\u7684\u5185\u5b58\u590d\u5236\u64cd\u4f5c\u4e0d\u540c\uff0cTMA \u64cd\u4f5c\u7531\u786c\u4ef6\u7ba1\u7406\uff0c\u53ef\u4ee5\u5b9e\u73b0\u66f4\u9ad8\u7684\u5e26\u5bbd\u5229\u7528\u7387\u548c\u66f4\u4f4e\u7684\u5bc4\u5b58\u5668\u538b\u529b\u3002 TMA \u7684\u4f18\u52bf TMA \u64cd\u4f5c\u5177\u6709\u4ee5\u4e0b\u4f18\u52bf\uff1a \u66f4\u9ad8\u7684\u5e26\u5bbd\u5229\u7528\u7387 \uff1aTMA \u64cd\u4f5c\u53ef\u4ee5\u5229\u7528\u66f4\u9ad8\u7684\u5185\u5b58\u5e26\u5bbd\uff0c\u6bd4\u4f20\u7edf\u7684\u7ebf\u7a0b\u590d\u5236\u66f4\u9ad8\u6548\u3002 \u51cf\u5c11\u5bc4\u5b58\u5668\u538b\u529b \uff1a\u6570\u636e\u76f4\u63a5\u4ece\u5168\u5c40\u5185\u5b58\u4f20\u8f93\u5230\u5171\u4eab\u5185\u5b58\uff0c\u907f\u514d\u4e86\u4e2d\u95f4\u7684\u5bc4\u5b58\u5668\u5b58\u50a8\u3002 \u786c\u4ef6\u52a0\u901f \uff1aTMA \u64cd\u4f5c\u7531\u4e13\u7528\u786c\u4ef6\u6267\u884c\uff0c\u51cf\u8f7b\u4e86 CUDA \u6838\u5fc3\u7684\u8d1f\u62c5\u3002 \u81ea\u52a8\u5411\u91cf\u5316 \uff1aTMA \u53ef\u4ee5\u81ea\u52a8\u8fdb\u884c\u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\uff0c\u63d0\u9ad8\u6548\u7387\u3002 \u591a\u64ad\u652f\u6301 \uff1aTMA \u652f\u6301\u5c06\u6570\u636e\u540c\u65f6\u4f20\u8f93\u5230\u591a\u4e2a\u7ebf\u7a0b\u5757\uff0c\u8fdb\u4e00\u6b65\u63d0\u9ad8\u6548\u7387\u3002 TMA \u64cd\u4f5c\u7c7b\u578b CuTe \u63d0\u4f9b\u4e86\u51e0\u79cd TMA \u64cd\u4f5c\uff1a SM90_TMA_LOAD \u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58\u3002\u8fd9\u662f\u6700\u57fa\u672c\u7684 TMA \u52a0\u8f7d\u64cd\u4f5c\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_LOAD { CUTE_HOST_DEVICE static void copy(void const* desc_ptr, uint64_t* mbar_ptr, uint64_t cache_hint, void * smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); }; SM90_TMA_LOAD_MULTICAST \u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58\uff0c\u5e76\u5e7f\u64ad\u5230\u591a\u4e2a\u7ebf\u7a0b\u5757\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_LOAD_MULTICAST { CUTE_HOST_DEVICE static void copy(void const* desc_ptr, uint64_t* mbar_ptr, uint16_t multicast_mask, uint64_t cache_hint, void * smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); }; SM90_TMA_STORE \u4ece\u5171\u4eab\u5185\u5b58\u5b58\u50a8\u6570\u636e\u5230\u5168\u5c40\u5185\u5b58\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_STORE { CUTE_HOST_DEVICE static void copy(void const* desc_ptr, void const* smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); }; SM90_TMA_REDUCE_ADD \u4ece\u5171\u4eab\u5185\u5b58\u5f52\u7ea6\u52a0\u6cd5\u6570\u636e\u5230\u5168\u5c40\u5185\u5b58\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_REDUCE_ADD { CUTE_HOST_DEVICE static void copy(void const* const desc_ptr, void const* const smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); }; TMA \u76f8\u5173\u6570\u636e\u7ed3\u6784 TmaDescriptor TMA \u64cd\u4f5c\u9700\u8981\u4e00\u4e2a TMA Descriptor \u6765\u63cf\u8ff0\u5185\u5b58\u8bbf\u95ee\u7684\u5c5e\u6027\u3002\u8fd9\u4e2a\u63cf\u8ff0\u7b26\u5305\u542b\u4e86\u6570\u636e\u7684\u5f62\u72b6\u3001\u6b65\u5e45\u3001\u5185\u5b58\u5e03\u5c40\u7b49\u4fe1\u606f\u3002 TmaDescriptor \u662f\u4e00\u4e2a\u4e0d\u900f\u660e\u7684\u7ed3\u6784\u4f53\uff0c\u5176\u5177\u4f53\u5b9e\u73b0\u672a\u516c\u5f00\uff0c\u4f46\u5305\u542b\u4ee5\u4e0b\u5173\u952e\u4fe1\u606f\uff1a // TMA Descriptor \u7ed3\u6784\u4f53\uff08\u6982\u5ff5\u6027\u8868\u793a\uff09 struct TmaDescriptor { // \u5168\u5c40\u5185\u5b58\u5730\u5740 // void* gmem_address; // TMA \u5f20\u91cf\u7684\u7ef4\u5ea6\uff08\u6700\u591a5\u7ef4\uff09 // uint64_t global_dim[5]; // \u5168\u5c40\u5185\u5b58\u6b65\u5e45\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09 // uint64_t global_stride[4]; // \u7b2c\u4e00\u4e2a\u6b65\u5e45\u9690\u5f0f\u4e3a\u5143\u7d20\u5927\u5c0f // \u5171\u4eab\u5185\u5b58 box \u5c3a\u5bf8 // uint32_t smem_box_dim[5]; // \u5171\u4eab\u5185\u5b58\u5143\u7d20\u6b65\u5e45 // uint32_t smem_elem_stride[5]; // \u6570\u636e\u7c7b\u578b\u4fe1\u606f // CUtensorMapDataType data_type; // TMA \u4ea4\u6362\u6a21\u5f0f // CUtensorMapSwizzle smem_swizzle; // \u5176\u4ed6 TMA \u914d\u7f6e\u53c2\u6570 // ... }; TMA Descriptor \u5305\u542b\u7684\u5173\u952e\u4fe1\u606f\u6709\uff1a \u5168\u5c40\u5185\u5b58\u5730\u5740 \uff1a\u6307\u5411\u8981\u8bbf\u95ee\u7684\u5168\u5c40\u5185\u5b58\u8d77\u59cb\u5730\u5740 \u5f20\u91cf\u7ef4\u5ea6\u4fe1\u606f \uff1a\u63cf\u8ff0\u8981\u8bbf\u95ee\u7684\u5f20\u91cf\u5728\u5404\u4e2a\u7ef4\u5ea6\u4e0a\u7684\u5927\u5c0f\uff08\u6700\u591a\u652f\u63015\u7ef4\uff09 \u5168\u5c40\u5185\u5b58\u6b65\u5e45 \uff1a\u63cf\u8ff0\u5728\u5168\u5c40\u5185\u5b58\u4e2d\u5404\u4e2a\u7ef4\u5ea6\u4e4b\u95f4\u7684\u5b57\u8282\u6b65\u5e45 \u5171\u4eab\u5185\u5b58 box \u5c3a\u5bf8 \uff1a\u63cf\u8ff0\u6bcf\u6b21 TMA \u64cd\u4f5c\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u8bbf\u95ee\u7684\u6570\u636e\u5757\u5927\u5c0f \u5171\u4eab\u5185\u5b58\u5143\u7d20\u6b65\u5e45 \uff1a\u63cf\u8ff0\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u5143\u7d20\u7684\u5e03\u5c40\u65b9\u5f0f \u6570\u636e\u7c7b\u578b\u4fe1\u606f \uff1a\u63cf\u8ff0\u5f20\u91cf\u5143\u7d20\u7684\u6570\u636e\u7c7b\u578b\uff08\u5982 float\u3001half \u7b49\uff09 \u5185\u5b58\u4ea4\u6362\u6a21\u5f0f \uff1a\u63cf\u8ff0\u5171\u4eab\u5185\u5b58\u7684\u4ea4\u6362\uff08swizzle\uff09\u6a21\u5f0f\uff0c\u7528\u4e8e\u4f18\u5316\u5185\u5b58\u8bbf\u95ee \u5176\u4ed6\u914d\u7f6e\u53c2\u6570 \uff1a\u5305\u62ec\u7f13\u5b58\u63d0\u793a\u3001\u4ea4\u9519\u6a21\u5f0f\u7b49 TMA Descriptor \u901a\u8fc7 CUDA \u9a71\u52a8 API \u51fd\u6570 cuTensorMapEncodeTiled \u521b\u5efa\uff0c\u8be5\u51fd\u6570\u4f1a\u6839\u636e\u63d0\u4f9b\u7684\u53c2\u6570\u586b\u5145\u63cf\u8ff0\u7b26\u7ed3\u6784\u3002 AuxTmaParams \u8f85\u52a9 TMA \u53c2\u6570\u7ed3\u6784\uff0c\u5305\u542b\u6784\u5efa TMA Descriptor \u6240\u9700\u7684\u4e00\u4e9b\u4e2d\u95f4\u53c2\u6570\u4fe1\u606f\u3002\u8fd9\u4e9b\u53c2\u6570\u5728\u521b\u5efa TMA Descriptor \u65f6\u4f1a\u88ab\u4f7f\u7528\uff0c\u4f46\u5728\u6700\u7ec8\u7684 TMA Descriptor \u4e2d\u53ef\u80fd\u4e0d\u4f1a\u76f4\u63a5\u53ef\u89c1\u3002 \u5b9a\u4e49\u5728 cute/atom/copy_traits_sm90_tma.hpp \u4e2d\uff1a template <class GmemTmaBasisStrides_, class TmaGmemBasis_, class TmaSwizzle_> struct AuxTmaParams { using GmemStrides = GmemTmaBasisStrides_; // Strides for Gmem mode -> Tma coord mode, may be dynamic GmemStrides g_stride_; using TmaGmemBasis = TmaGmemBasis_; // Layout for Tma box shape -> Gmem mode(s), always static static_assert(is_static<TmaGmemBasis>::value); using TmaSwizzle = TmaSwizzle_; // Tma swizzle, always Swizzle<B,M,S> static_assert(is_static<TmaSwizzle>::value); }; AuxTmaParams \u4e2d\u7684\u53c2\u6570\u542b\u4e49\uff1a GmemStrides (g_stride_) \uff1a \u7c7b\u578b\uff1aGmemTmaBasisStrides_ \u542b\u4e49\uff1a\u5168\u5c40\u5185\u5b58\u6a21\u5f0f\u5230 TMA \u5750\u6807\u6a21\u5f0f\u7684\u6b65\u5e45\u6620\u5c04 \u4f5c\u7528\uff1a\u63cf\u8ff0\u5168\u5c40\u5185\u5b58\u5f20\u91cf\u7684\u5404\u4e2a\u7ef4\u5ea6\u5982\u4f55\u6620\u5c04\u5230 TMA \u64cd\u4f5c\u7684\u5750\u6807\u7cfb\u7edf \u53ef\u80fd\u662f\u52a8\u6001\u7684\uff0c\u56e0\u4e3a\u5168\u5c40\u5185\u5b58\u5f20\u91cf\u7684\u6b65\u5e45\u53ef\u80fd\u662f\u8fd0\u884c\u65f6\u786e\u5b9a\u7684 TmaGmemBasis \uff1a \u7c7b\u578b\uff1aTmaGmemBasis_ \u542b\u4e49\uff1aTMA box \u5f62\u72b6\u5230\u5168\u5c40\u5185\u5b58\u6a21\u5f0f\u7684\u5e03\u5c40\u6620\u5c04 \u4f5c\u7528\uff1a\u63cf\u8ff0 TMA \u64cd\u4f5c\u7684 box \u5c3a\u5bf8\u5982\u4f55\u6620\u5c04\u5230\u5168\u5c40\u5185\u5b58\u7684\u5404\u4e2a\u7ef4\u5ea6 \u59cb\u7ec8\u662f\u9759\u6001\u7684\uff0c\u56e0\u4e3a TMA box \u7684\u5f62\u72b6\u5728\u7f16\u8bd1\u65f6\u5c31\u786e\u5b9a\u4e86 TmaSwizzle \uff1a \u7c7b\u578b\uff1aTmaSwizzle_ \u542b\u4e49\uff1aTMA \u4ea4\u6362\u6a21\u5f0f \u4f5c\u7528\uff1a\u63cf\u8ff0\u5171\u4eab\u5185\u5b58\u7684\u4ea4\u6362\u6a21\u5f0f\uff0c\u7528\u4e8e\u4f18\u5316\u5185\u5b58\u8bbf\u95ee \u59cb\u7ec8\u662f\u9759\u6001\u7684\uff0c\u56e0\u4e3a\u4ea4\u6362\u6a21\u5f0f\u5728\u7f16\u8bd1\u65f6\u5c31\u786e\u5b9a\u4e86 AuxTmaParams \u4e0e TMA Descriptor \u7684\u5173\u7cfb\uff1a AuxTmaParams \u5305\u542b\u7684\u662f\u6784\u5efa TMA Descriptor \u6240\u9700\u7684\u4e2d\u95f4\u53c2\u6570 TMA Descriptor \u662f\u6700\u7ec8\u4f20\u9012\u7ed9\u786c\u4ef6\u7684\u4e0d\u900f\u660e\u7ed3\u6784\u4f53 \u5728 make_tma_copy \u51fd\u6570\u4e2d\uff0cAuxTmaParams \u7684\u4fe1\u606f\u4f1a\u88ab\u7528\u6765\u521b\u5efa TMA Descriptor \u867d\u7136\u4e24\u8005\u5305\u542b\u7684\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u4f46 AuxTmaParams \u66f4\u591a\u662f CuTe \u5185\u90e8\u4f7f\u7528\u7684\u4e2d\u95f4\u8868\u793a\uff0c\u800c TMA Descriptor \u662f\u4f20\u9012\u7ed9 CUDA \u9a71\u52a8 API \u7684\u6700\u7ec8\u8868\u793a \u4f7f\u7528 TMA \u7684\u57fa\u672c\u6d41\u7a0b \u4f7f\u7528 TMA \u64cd\u4f5c\u7684\u57fa\u672c\u6d41\u7a0b\u5982\u4e0b\uff1a \u521b\u5efa TMA Descriptor \uff1a\u4f7f\u7528 make_tma_copy \u6216\u76f8\u5173\u51fd\u6570\u521b\u5efa TMA Copy \u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u5185\u90e8\u4f1a\u521b\u5efa TMA Descriptor\u3002 \u521d\u59cb\u5316 mbarrier \uff1a\u4f7f\u7528 mbarrier \u540c\u6b65 TMA \u64cd\u4f5c\uff0c\u786e\u4fdd\u64cd\u4f5c\u5b8c\u6210\u540e\u518d\u8bbf\u95ee\u6570\u636e\u3002 \u6267\u884c TMA \u64cd\u4f5c \uff1a\u8c03\u7528 copy \u51fd\u6570\u6267\u884c TMA \u52a0\u8f7d\u6216\u5b58\u50a8\u3002 \u540c\u6b65 \uff1a\u4f7f\u7528\u9002\u5f53\u7684\u540c\u6b65\u673a\u5236\u7b49\u5f85 TMA \u64cd\u4f5c\u5b8c\u6210\u3002 TMA Copy \u793a\u4f8b \u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528 TMA \u52a0\u8f7d\u6570\u636e\u7684\u5b8c\u6574\u793a\u4f8b\uff1a // \u5b9a\u4e49\u5168\u5c40\u5185\u5b58\u5f20\u91cf Tensor gmem_tensor = make_tensor(make_gmem_ptr<float>(gmem_ptr), make_shape(M, N), GenRowMajor{}); // \u5b9a\u4e49\u5171\u4eab\u5185\u5b58\u5e03\u5c40 auto smem_layout = tile_to_shape(GMMA::Layout_MN_SW128_Atom<float>{}, make_shape(BLK_M, BLK_N)); // \u521b\u5efa TMA Copy \u5bf9\u8c61 auto tma_load = make_tma_copy(SM90_TMA_LOAD{}, gmem_tensor, smem_layout); // \u83b7\u53d6 TMA tensor auto tma_tensor = tma_load.get_tma_tensor(make_shape(M, N)); // \u5206\u5272\u6570\u636e\u5757 auto tma_gmem = local_tile(tma_tensor, make_shape(BLK_M, BLK_N), blk_coord); // \u83b7\u53d6\u7ebf\u7a0b\u7247 auto thr_x = tma_load.get_slice(thread_idx); // \u5206\u533a\u6e90\u548c\u76ee\u6807\u5f20\u91cf auto tma_gmem_x = thr_x.partition_S(tma_gmem); // \u5206\u533a\u5168\u5c40\u5185\u5b58\u5f20\u91cf auto tma_smem_x = thr_x.partition_D(smem_tensor); // \u5206\u533a\u5171\u4eab\u5185\u5b58\u5f20\u91cf // \u6267\u884c TMA \u52a0\u8f7d copy(tma_load.with(barrier, mcast_mask), tma_gmem_x, tma_smem_x); TMA \u76f8\u5173\u51fd\u6570\u548c\u7c7b make_tma_copy \u521b\u5efa TMA Copy \u5bf9\u8c61\u7684\u4e3b\u8981\u51fd\u6570\u3002 \u5b9a\u4e49\u5728 cute/atom/copy_traits_sm90_tma.hpp \u4e2d\uff1a template <class TmaInternalType = void, class CopyOp, class GEngine, class GLayout, class SLayout, class CTA_Tiler, class Cluster_Size> CUTE_HOST_RTC auto make_tma_copy(CopyOp const& copy_op, Tensor<GEngine,GLayout> const& gtensor, SLayout const& slayout, CTA_Tiler const& cta_tiler, Cluster_Size const& cluster_size); Copy_Traits \u7279\u5316 \u9488\u5bf9\u4e0d\u540c TMA \u64cd\u4f5c\u7684 Copy_Traits \u7279\u5316\uff0c\u5b9a\u4e49\u4e86\u64cd\u4f5c\u7684\u5c5e\u6027\u3002 \u4f8b\u5982\uff0cSM90_TMA_LOAD \u7684\u7279\u5316\uff1a template <class NumBitsPerTMA, class AuxParams_> struct Copy_Traits<SM90_TMA_LOAD, NumBitsPerTMA, AuxParams_> { using ThrID = Layout<_1>; using SrcLayout = Layout<Shape<_1,NumBitsPerTMA>>; using DstLayout = Layout<Shape<_1,NumBitsPerTMA>>; using RefLayout = SrcLayout; TmaDescriptor tma_desc_; using AuxParams = AuxParams_; AuxParams aux_params_; // ... \u5176\u4ed6\u6210\u5458\u51fd\u6570 }; TMA \u591a\u64ad\u64cd\u4f5c TMA \u652f\u6301\u591a\u64ad\u64cd\u4f5c\uff0c\u53ef\u4ee5\u5c06\u6570\u636e\u540c\u65f6\u4f20\u8f93\u5230\u591a\u4e2a\u7ebf\u7a0b\u5757\u3002 create_tma_multicast_mask \u521b\u5efa TMA \u591a\u64ad\u63a9\u7801\u7684\u51fd\u6570\uff1a template <class CtaLayout, class CtaCoord> CUTE_HOST_DEVICE constexpr uint16_t create_tma_multicast_mask(CtaLayout const& cta_layout_vmnk, CtaCoord const& cta_coord_vmnk); TMA \u540c\u6b65\u673a\u5236 TMA \u64cd\u4f5c\u662f\u5f02\u6b65\u7684\uff0c\u9700\u8981\u9002\u5f53\u7684\u540c\u6b65\u673a\u5236\uff1a tma_store_fence \u4e3a\u540e\u7eed\u7684 TMA_STORE \u64cd\u4f5c\u8bbe\u7f6e\u5171\u4eab\u5185\u5b58\u5b58\u50a8\u7684 fence\uff1a CUTE_HOST_DEVICE static void tma_store_fence(); tma_store_wait \u7b49\u5f85 TMA \u64cd\u4f5c\u5b8c\u6210\uff1a template <int Count> CUTE_HOST_DEVICE static void tma_store_wait(); \u6ce8\u610f\u4e8b\u9879 \u4f7f\u7528 TMA \u64cd\u4f5c\u65f6\u9700\u8981\u6ce8\u610f\u4ee5\u4e0b\u4e8b\u9879\uff1a \u786c\u4ef6\u8981\u6c42 \uff1aTMA \u64cd\u4f5c\u4ec5\u5728 NVIDIA Hopper \u67b6\u6784 (SM90) \u53ca\u4ee5\u4e0a\u7248\u672c\u4e2d\u53ef\u7528\u3002 \u5185\u5b58\u5bf9\u9f50 \uff1aTMA \u64cd\u4f5c\u5bf9\u5185\u5b58\u5bf9\u9f50\u6709\u4e25\u683c\u8981\u6c42\uff0c\u9700\u8981\u786e\u4fdd\u6570\u636e\u6309\u8981\u6c42\u5bf9\u9f50\u3002 \u5171\u4eab\u5185\u5b58\u5e03\u5c40 \uff1a\u9700\u8981\u4f7f\u7528\u7279\u5b9a\u7684\u5171\u4eab\u5185\u5b58\u5e03\u5c40\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 \u540c\u6b65 \uff1a\u5fc5\u987b\u6b63\u786e\u4f7f\u7528\u540c\u6b65\u673a\u5236\uff0c\u786e\u4fdd TMA \u64cd\u4f5c\u5b8c\u6210\u540e\u518d\u8bbf\u95ee\u76f8\u5173\u6570\u636e\u3002","title":"TMA Copy \u64cd\u4f5c"},{"location":"cute_tma_copy/#cute-tma-copy","text":"TMA (Tensor Memory Access) \u662f NVIDIA Hopper \u67b6\u6784\u5f15\u5165\u7684\u4e00\u79cd\u65b0\u7684\u5185\u5b58\u8bbf\u95ee\u6280\u672f\u3002\u5b83\u5141\u8bb8\u7ebf\u7a0b\u5757(cluster)\u76f4\u63a5\u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58\uff0c\u6216\u8005\u4ece\u5171\u4eab\u5185\u5b58\u5b58\u50a8\u6570\u636e\u5230\u5168\u5c40\u5185\u5b58\uff0c\u800c\u65e0\u9700\u663e\u5f0f\u5730\u901a\u8fc7\u6bcf\u4e2a\u7ebf\u7a0b\u8fdb\u884c\u590d\u5236\u3002","title":"CuTe TMA Copy \u64cd\u4f5c\u8be6\u89e3"},{"location":"cute_tma_copy/#tma","text":"TMA \u64cd\u4f5c\u901a\u8fc7\u4e13\u7528\u786c\u4ef6\u5355\u5143\u6267\u884c\uff0c\u53ef\u4ee5\u76f4\u63a5\u5728\u5168\u5c40\u5185\u5b58\u548c\u5171\u4eab\u5185\u5b58\u4e4b\u95f4\u4f20\u8f93\u6570\u636e\u3002\u8fd9\u4e0e\u4f20\u7edf\u7684\u7531 CUDA \u7ebf\u7a0b\u6267\u884c\u7684\u5185\u5b58\u590d\u5236\u64cd\u4f5c\u4e0d\u540c\uff0cTMA \u64cd\u4f5c\u7531\u786c\u4ef6\u7ba1\u7406\uff0c\u53ef\u4ee5\u5b9e\u73b0\u66f4\u9ad8\u7684\u5e26\u5bbd\u5229\u7528\u7387\u548c\u66f4\u4f4e\u7684\u5bc4\u5b58\u5668\u538b\u529b\u3002","title":"TMA \u57fa\u672c\u6982\u5ff5"},{"location":"cute_tma_copy/#tma_1","text":"TMA \u64cd\u4f5c\u5177\u6709\u4ee5\u4e0b\u4f18\u52bf\uff1a \u66f4\u9ad8\u7684\u5e26\u5bbd\u5229\u7528\u7387 \uff1aTMA \u64cd\u4f5c\u53ef\u4ee5\u5229\u7528\u66f4\u9ad8\u7684\u5185\u5b58\u5e26\u5bbd\uff0c\u6bd4\u4f20\u7edf\u7684\u7ebf\u7a0b\u590d\u5236\u66f4\u9ad8\u6548\u3002 \u51cf\u5c11\u5bc4\u5b58\u5668\u538b\u529b \uff1a\u6570\u636e\u76f4\u63a5\u4ece\u5168\u5c40\u5185\u5b58\u4f20\u8f93\u5230\u5171\u4eab\u5185\u5b58\uff0c\u907f\u514d\u4e86\u4e2d\u95f4\u7684\u5bc4\u5b58\u5668\u5b58\u50a8\u3002 \u786c\u4ef6\u52a0\u901f \uff1aTMA \u64cd\u4f5c\u7531\u4e13\u7528\u786c\u4ef6\u6267\u884c\uff0c\u51cf\u8f7b\u4e86 CUDA \u6838\u5fc3\u7684\u8d1f\u62c5\u3002 \u81ea\u52a8\u5411\u91cf\u5316 \uff1aTMA \u53ef\u4ee5\u81ea\u52a8\u8fdb\u884c\u5411\u91cf\u5316\u5185\u5b58\u8bbf\u95ee\uff0c\u63d0\u9ad8\u6548\u7387\u3002 \u591a\u64ad\u652f\u6301 \uff1aTMA \u652f\u6301\u5c06\u6570\u636e\u540c\u65f6\u4f20\u8f93\u5230\u591a\u4e2a\u7ebf\u7a0b\u5757\uff0c\u8fdb\u4e00\u6b65\u63d0\u9ad8\u6548\u7387\u3002","title":"TMA \u7684\u4f18\u52bf"},{"location":"cute_tma_copy/#tma_2","text":"CuTe \u63d0\u4f9b\u4e86\u51e0\u79cd TMA \u64cd\u4f5c\uff1a","title":"TMA \u64cd\u4f5c\u7c7b\u578b"},{"location":"cute_tma_copy/#sm90_tma_load","text":"\u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58\u3002\u8fd9\u662f\u6700\u57fa\u672c\u7684 TMA \u52a0\u8f7d\u64cd\u4f5c\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_LOAD { CUTE_HOST_DEVICE static void copy(void const* desc_ptr, uint64_t* mbar_ptr, uint64_t cache_hint, void * smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); };","title":"SM90_TMA_LOAD"},{"location":"cute_tma_copy/#sm90_tma_load_multicast","text":"\u4ece\u5168\u5c40\u5185\u5b58\u52a0\u8f7d\u6570\u636e\u5230\u5171\u4eab\u5185\u5b58\uff0c\u5e76\u5e7f\u64ad\u5230\u591a\u4e2a\u7ebf\u7a0b\u5757\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_LOAD_MULTICAST { CUTE_HOST_DEVICE static void copy(void const* desc_ptr, uint64_t* mbar_ptr, uint16_t multicast_mask, uint64_t cache_hint, void * smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); };","title":"SM90_TMA_LOAD_MULTICAST"},{"location":"cute_tma_copy/#sm90_tma_store","text":"\u4ece\u5171\u4eab\u5185\u5b58\u5b58\u50a8\u6570\u636e\u5230\u5168\u5c40\u5185\u5b58\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_STORE { CUTE_HOST_DEVICE static void copy(void const* desc_ptr, void const* smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); };","title":"SM90_TMA_STORE"},{"location":"cute_tma_copy/#sm90_tma_reduce_add","text":"\u4ece\u5171\u4eab\u5185\u5b58\u5f52\u7ea6\u52a0\u6cd5\u6570\u636e\u5230\u5168\u5c40\u5185\u5b58\u3002 \u5b9a\u4e49\u5728 cute/arch/copy_sm90_tma.hpp \u4e2d\uff1a struct SM90_TMA_REDUCE_ADD { CUTE_HOST_DEVICE static void copy(void const* const desc_ptr, void const* const smem_ptr, int32_t const& crd0, int32_t const& crd1, ...); };","title":"SM90_TMA_REDUCE_ADD"},{"location":"cute_tma_copy/#tma_3","text":"","title":"TMA \u76f8\u5173\u6570\u636e\u7ed3\u6784"},{"location":"cute_tma_copy/#tmadescriptor","text":"TMA \u64cd\u4f5c\u9700\u8981\u4e00\u4e2a TMA Descriptor \u6765\u63cf\u8ff0\u5185\u5b58\u8bbf\u95ee\u7684\u5c5e\u6027\u3002\u8fd9\u4e2a\u63cf\u8ff0\u7b26\u5305\u542b\u4e86\u6570\u636e\u7684\u5f62\u72b6\u3001\u6b65\u5e45\u3001\u5185\u5b58\u5e03\u5c40\u7b49\u4fe1\u606f\u3002 TmaDescriptor \u662f\u4e00\u4e2a\u4e0d\u900f\u660e\u7684\u7ed3\u6784\u4f53\uff0c\u5176\u5177\u4f53\u5b9e\u73b0\u672a\u516c\u5f00\uff0c\u4f46\u5305\u542b\u4ee5\u4e0b\u5173\u952e\u4fe1\u606f\uff1a // TMA Descriptor \u7ed3\u6784\u4f53\uff08\u6982\u5ff5\u6027\u8868\u793a\uff09 struct TmaDescriptor { // \u5168\u5c40\u5185\u5b58\u5730\u5740 // void* gmem_address; // TMA \u5f20\u91cf\u7684\u7ef4\u5ea6\uff08\u6700\u591a5\u7ef4\uff09 // uint64_t global_dim[5]; // \u5168\u5c40\u5185\u5b58\u6b65\u5e45\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09 // uint64_t global_stride[4]; // \u7b2c\u4e00\u4e2a\u6b65\u5e45\u9690\u5f0f\u4e3a\u5143\u7d20\u5927\u5c0f // \u5171\u4eab\u5185\u5b58 box \u5c3a\u5bf8 // uint32_t smem_box_dim[5]; // \u5171\u4eab\u5185\u5b58\u5143\u7d20\u6b65\u5e45 // uint32_t smem_elem_stride[5]; // \u6570\u636e\u7c7b\u578b\u4fe1\u606f // CUtensorMapDataType data_type; // TMA \u4ea4\u6362\u6a21\u5f0f // CUtensorMapSwizzle smem_swizzle; // \u5176\u4ed6 TMA \u914d\u7f6e\u53c2\u6570 // ... }; TMA Descriptor \u5305\u542b\u7684\u5173\u952e\u4fe1\u606f\u6709\uff1a \u5168\u5c40\u5185\u5b58\u5730\u5740 \uff1a\u6307\u5411\u8981\u8bbf\u95ee\u7684\u5168\u5c40\u5185\u5b58\u8d77\u59cb\u5730\u5740 \u5f20\u91cf\u7ef4\u5ea6\u4fe1\u606f \uff1a\u63cf\u8ff0\u8981\u8bbf\u95ee\u7684\u5f20\u91cf\u5728\u5404\u4e2a\u7ef4\u5ea6\u4e0a\u7684\u5927\u5c0f\uff08\u6700\u591a\u652f\u63015\u7ef4\uff09 \u5168\u5c40\u5185\u5b58\u6b65\u5e45 \uff1a\u63cf\u8ff0\u5728\u5168\u5c40\u5185\u5b58\u4e2d\u5404\u4e2a\u7ef4\u5ea6\u4e4b\u95f4\u7684\u5b57\u8282\u6b65\u5e45 \u5171\u4eab\u5185\u5b58 box \u5c3a\u5bf8 \uff1a\u63cf\u8ff0\u6bcf\u6b21 TMA \u64cd\u4f5c\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u8bbf\u95ee\u7684\u6570\u636e\u5757\u5927\u5c0f \u5171\u4eab\u5185\u5b58\u5143\u7d20\u6b65\u5e45 \uff1a\u63cf\u8ff0\u5728\u5171\u4eab\u5185\u5b58\u4e2d\u5143\u7d20\u7684\u5e03\u5c40\u65b9\u5f0f \u6570\u636e\u7c7b\u578b\u4fe1\u606f \uff1a\u63cf\u8ff0\u5f20\u91cf\u5143\u7d20\u7684\u6570\u636e\u7c7b\u578b\uff08\u5982 float\u3001half \u7b49\uff09 \u5185\u5b58\u4ea4\u6362\u6a21\u5f0f \uff1a\u63cf\u8ff0\u5171\u4eab\u5185\u5b58\u7684\u4ea4\u6362\uff08swizzle\uff09\u6a21\u5f0f\uff0c\u7528\u4e8e\u4f18\u5316\u5185\u5b58\u8bbf\u95ee \u5176\u4ed6\u914d\u7f6e\u53c2\u6570 \uff1a\u5305\u62ec\u7f13\u5b58\u63d0\u793a\u3001\u4ea4\u9519\u6a21\u5f0f\u7b49 TMA Descriptor \u901a\u8fc7 CUDA \u9a71\u52a8 API \u51fd\u6570 cuTensorMapEncodeTiled \u521b\u5efa\uff0c\u8be5\u51fd\u6570\u4f1a\u6839\u636e\u63d0\u4f9b\u7684\u53c2\u6570\u586b\u5145\u63cf\u8ff0\u7b26\u7ed3\u6784\u3002","title":"TmaDescriptor"},{"location":"cute_tma_copy/#auxtmaparams","text":"\u8f85\u52a9 TMA \u53c2\u6570\u7ed3\u6784\uff0c\u5305\u542b\u6784\u5efa TMA Descriptor \u6240\u9700\u7684\u4e00\u4e9b\u4e2d\u95f4\u53c2\u6570\u4fe1\u606f\u3002\u8fd9\u4e9b\u53c2\u6570\u5728\u521b\u5efa TMA Descriptor \u65f6\u4f1a\u88ab\u4f7f\u7528\uff0c\u4f46\u5728\u6700\u7ec8\u7684 TMA Descriptor \u4e2d\u53ef\u80fd\u4e0d\u4f1a\u76f4\u63a5\u53ef\u89c1\u3002 \u5b9a\u4e49\u5728 cute/atom/copy_traits_sm90_tma.hpp \u4e2d\uff1a template <class GmemTmaBasisStrides_, class TmaGmemBasis_, class TmaSwizzle_> struct AuxTmaParams { using GmemStrides = GmemTmaBasisStrides_; // Strides for Gmem mode -> Tma coord mode, may be dynamic GmemStrides g_stride_; using TmaGmemBasis = TmaGmemBasis_; // Layout for Tma box shape -> Gmem mode(s), always static static_assert(is_static<TmaGmemBasis>::value); using TmaSwizzle = TmaSwizzle_; // Tma swizzle, always Swizzle<B,M,S> static_assert(is_static<TmaSwizzle>::value); }; AuxTmaParams \u4e2d\u7684\u53c2\u6570\u542b\u4e49\uff1a GmemStrides (g_stride_) \uff1a \u7c7b\u578b\uff1aGmemTmaBasisStrides_ \u542b\u4e49\uff1a\u5168\u5c40\u5185\u5b58\u6a21\u5f0f\u5230 TMA \u5750\u6807\u6a21\u5f0f\u7684\u6b65\u5e45\u6620\u5c04 \u4f5c\u7528\uff1a\u63cf\u8ff0\u5168\u5c40\u5185\u5b58\u5f20\u91cf\u7684\u5404\u4e2a\u7ef4\u5ea6\u5982\u4f55\u6620\u5c04\u5230 TMA \u64cd\u4f5c\u7684\u5750\u6807\u7cfb\u7edf \u53ef\u80fd\u662f\u52a8\u6001\u7684\uff0c\u56e0\u4e3a\u5168\u5c40\u5185\u5b58\u5f20\u91cf\u7684\u6b65\u5e45\u53ef\u80fd\u662f\u8fd0\u884c\u65f6\u786e\u5b9a\u7684 TmaGmemBasis \uff1a \u7c7b\u578b\uff1aTmaGmemBasis_ \u542b\u4e49\uff1aTMA box \u5f62\u72b6\u5230\u5168\u5c40\u5185\u5b58\u6a21\u5f0f\u7684\u5e03\u5c40\u6620\u5c04 \u4f5c\u7528\uff1a\u63cf\u8ff0 TMA \u64cd\u4f5c\u7684 box \u5c3a\u5bf8\u5982\u4f55\u6620\u5c04\u5230\u5168\u5c40\u5185\u5b58\u7684\u5404\u4e2a\u7ef4\u5ea6 \u59cb\u7ec8\u662f\u9759\u6001\u7684\uff0c\u56e0\u4e3a TMA box \u7684\u5f62\u72b6\u5728\u7f16\u8bd1\u65f6\u5c31\u786e\u5b9a\u4e86 TmaSwizzle \uff1a \u7c7b\u578b\uff1aTmaSwizzle_ \u542b\u4e49\uff1aTMA \u4ea4\u6362\u6a21\u5f0f \u4f5c\u7528\uff1a\u63cf\u8ff0\u5171\u4eab\u5185\u5b58\u7684\u4ea4\u6362\u6a21\u5f0f\uff0c\u7528\u4e8e\u4f18\u5316\u5185\u5b58\u8bbf\u95ee \u59cb\u7ec8\u662f\u9759\u6001\u7684\uff0c\u56e0\u4e3a\u4ea4\u6362\u6a21\u5f0f\u5728\u7f16\u8bd1\u65f6\u5c31\u786e\u5b9a\u4e86 AuxTmaParams \u4e0e TMA Descriptor \u7684\u5173\u7cfb\uff1a AuxTmaParams \u5305\u542b\u7684\u662f\u6784\u5efa TMA Descriptor \u6240\u9700\u7684\u4e2d\u95f4\u53c2\u6570 TMA Descriptor \u662f\u6700\u7ec8\u4f20\u9012\u7ed9\u786c\u4ef6\u7684\u4e0d\u900f\u660e\u7ed3\u6784\u4f53 \u5728 make_tma_copy \u51fd\u6570\u4e2d\uff0cAuxTmaParams \u7684\u4fe1\u606f\u4f1a\u88ab\u7528\u6765\u521b\u5efa TMA Descriptor \u867d\u7136\u4e24\u8005\u5305\u542b\u7684\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u4f46 AuxTmaParams \u66f4\u591a\u662f CuTe \u5185\u90e8\u4f7f\u7528\u7684\u4e2d\u95f4\u8868\u793a\uff0c\u800c TMA Descriptor \u662f\u4f20\u9012\u7ed9 CUDA \u9a71\u52a8 API \u7684\u6700\u7ec8\u8868\u793a","title":"AuxTmaParams"},{"location":"cute_tma_copy/#tma_4","text":"\u4f7f\u7528 TMA \u64cd\u4f5c\u7684\u57fa\u672c\u6d41\u7a0b\u5982\u4e0b\uff1a \u521b\u5efa TMA Descriptor \uff1a\u4f7f\u7528 make_tma_copy \u6216\u76f8\u5173\u51fd\u6570\u521b\u5efa TMA Copy \u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u5185\u90e8\u4f1a\u521b\u5efa TMA Descriptor\u3002 \u521d\u59cb\u5316 mbarrier \uff1a\u4f7f\u7528 mbarrier \u540c\u6b65 TMA \u64cd\u4f5c\uff0c\u786e\u4fdd\u64cd\u4f5c\u5b8c\u6210\u540e\u518d\u8bbf\u95ee\u6570\u636e\u3002 \u6267\u884c TMA \u64cd\u4f5c \uff1a\u8c03\u7528 copy \u51fd\u6570\u6267\u884c TMA \u52a0\u8f7d\u6216\u5b58\u50a8\u3002 \u540c\u6b65 \uff1a\u4f7f\u7528\u9002\u5f53\u7684\u540c\u6b65\u673a\u5236\u7b49\u5f85 TMA \u64cd\u4f5c\u5b8c\u6210\u3002","title":"\u4f7f\u7528 TMA \u7684\u57fa\u672c\u6d41\u7a0b"},{"location":"cute_tma_copy/#tma-copy","text":"\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528 TMA \u52a0\u8f7d\u6570\u636e\u7684\u5b8c\u6574\u793a\u4f8b\uff1a // \u5b9a\u4e49\u5168\u5c40\u5185\u5b58\u5f20\u91cf Tensor gmem_tensor = make_tensor(make_gmem_ptr<float>(gmem_ptr), make_shape(M, N), GenRowMajor{}); // \u5b9a\u4e49\u5171\u4eab\u5185\u5b58\u5e03\u5c40 auto smem_layout = tile_to_shape(GMMA::Layout_MN_SW128_Atom<float>{}, make_shape(BLK_M, BLK_N)); // \u521b\u5efa TMA Copy \u5bf9\u8c61 auto tma_load = make_tma_copy(SM90_TMA_LOAD{}, gmem_tensor, smem_layout); // \u83b7\u53d6 TMA tensor auto tma_tensor = tma_load.get_tma_tensor(make_shape(M, N)); // \u5206\u5272\u6570\u636e\u5757 auto tma_gmem = local_tile(tma_tensor, make_shape(BLK_M, BLK_N), blk_coord); // \u83b7\u53d6\u7ebf\u7a0b\u7247 auto thr_x = tma_load.get_slice(thread_idx); // \u5206\u533a\u6e90\u548c\u76ee\u6807\u5f20\u91cf auto tma_gmem_x = thr_x.partition_S(tma_gmem); // \u5206\u533a\u5168\u5c40\u5185\u5b58\u5f20\u91cf auto tma_smem_x = thr_x.partition_D(smem_tensor); // \u5206\u533a\u5171\u4eab\u5185\u5b58\u5f20\u91cf // \u6267\u884c TMA \u52a0\u8f7d copy(tma_load.with(barrier, mcast_mask), tma_gmem_x, tma_smem_x);","title":"TMA Copy \u793a\u4f8b"},{"location":"cute_tma_copy/#tma_5","text":"","title":"TMA \u76f8\u5173\u51fd\u6570\u548c\u7c7b"},{"location":"cute_tma_copy/#make_tma_copy","text":"\u521b\u5efa TMA Copy \u5bf9\u8c61\u7684\u4e3b\u8981\u51fd\u6570\u3002 \u5b9a\u4e49\u5728 cute/atom/copy_traits_sm90_tma.hpp \u4e2d\uff1a template <class TmaInternalType = void, class CopyOp, class GEngine, class GLayout, class SLayout, class CTA_Tiler, class Cluster_Size> CUTE_HOST_RTC auto make_tma_copy(CopyOp const& copy_op, Tensor<GEngine,GLayout> const& gtensor, SLayout const& slayout, CTA_Tiler const& cta_tiler, Cluster_Size const& cluster_size);","title":"make_tma_copy"},{"location":"cute_tma_copy/#copy_traits","text":"\u9488\u5bf9\u4e0d\u540c TMA \u64cd\u4f5c\u7684 Copy_Traits \u7279\u5316\uff0c\u5b9a\u4e49\u4e86\u64cd\u4f5c\u7684\u5c5e\u6027\u3002 \u4f8b\u5982\uff0cSM90_TMA_LOAD \u7684\u7279\u5316\uff1a template <class NumBitsPerTMA, class AuxParams_> struct Copy_Traits<SM90_TMA_LOAD, NumBitsPerTMA, AuxParams_> { using ThrID = Layout<_1>; using SrcLayout = Layout<Shape<_1,NumBitsPerTMA>>; using DstLayout = Layout<Shape<_1,NumBitsPerTMA>>; using RefLayout = SrcLayout; TmaDescriptor tma_desc_; using AuxParams = AuxParams_; AuxParams aux_params_; // ... \u5176\u4ed6\u6210\u5458\u51fd\u6570 };","title":"Copy_Traits \u7279\u5316"},{"location":"cute_tma_copy/#tma_6","text":"TMA \u652f\u6301\u591a\u64ad\u64cd\u4f5c\uff0c\u53ef\u4ee5\u5c06\u6570\u636e\u540c\u65f6\u4f20\u8f93\u5230\u591a\u4e2a\u7ebf\u7a0b\u5757\u3002","title":"TMA \u591a\u64ad\u64cd\u4f5c"},{"location":"cute_tma_copy/#create_tma_multicast_mask","text":"\u521b\u5efa TMA \u591a\u64ad\u63a9\u7801\u7684\u51fd\u6570\uff1a template <class CtaLayout, class CtaCoord> CUTE_HOST_DEVICE constexpr uint16_t create_tma_multicast_mask(CtaLayout const& cta_layout_vmnk, CtaCoord const& cta_coord_vmnk);","title":"create_tma_multicast_mask"},{"location":"cute_tma_copy/#tma_7","text":"TMA \u64cd\u4f5c\u662f\u5f02\u6b65\u7684\uff0c\u9700\u8981\u9002\u5f53\u7684\u540c\u6b65\u673a\u5236\uff1a","title":"TMA \u540c\u6b65\u673a\u5236"},{"location":"cute_tma_copy/#tma_store_fence","text":"\u4e3a\u540e\u7eed\u7684 TMA_STORE \u64cd\u4f5c\u8bbe\u7f6e\u5171\u4eab\u5185\u5b58\u5b58\u50a8\u7684 fence\uff1a CUTE_HOST_DEVICE static void tma_store_fence();","title":"tma_store_fence"},{"location":"cute_tma_copy/#tma_store_wait","text":"\u7b49\u5f85 TMA \u64cd\u4f5c\u5b8c\u6210\uff1a template <int Count> CUTE_HOST_DEVICE static void tma_store_wait();","title":"tma_store_wait"},{"location":"cute_tma_copy/#_1","text":"\u4f7f\u7528 TMA \u64cd\u4f5c\u65f6\u9700\u8981\u6ce8\u610f\u4ee5\u4e0b\u4e8b\u9879\uff1a \u786c\u4ef6\u8981\u6c42 \uff1aTMA \u64cd\u4f5c\u4ec5\u5728 NVIDIA Hopper \u67b6\u6784 (SM90) \u53ca\u4ee5\u4e0a\u7248\u672c\u4e2d\u53ef\u7528\u3002 \u5185\u5b58\u5bf9\u9f50 \uff1aTMA \u64cd\u4f5c\u5bf9\u5185\u5b58\u5bf9\u9f50\u6709\u4e25\u683c\u8981\u6c42\uff0c\u9700\u8981\u786e\u4fdd\u6570\u636e\u6309\u8981\u6c42\u5bf9\u9f50\u3002 \u5171\u4eab\u5185\u5b58\u5e03\u5c40 \uff1a\u9700\u8981\u4f7f\u7528\u7279\u5b9a\u7684\u5171\u4eab\u5185\u5b58\u5e03\u5c40\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u3002 \u540c\u6b65 \uff1a\u5fc5\u987b\u6b63\u786e\u4f7f\u7528\u540c\u6b65\u673a\u5236\uff0c\u786e\u4fdd TMA \u64cd\u4f5c\u5b8c\u6210\u540e\u518d\u8bbf\u95ee\u76f8\u5173\u6570\u636e\u3002","title":"\u6ce8\u610f\u4e8b\u9879"},{"location":"cute_wgmma_sm90/","text":"CuTe WGmma SM90 (Hopper) \u8be6\u89e3 \u5728 NVIDIA Hopper (SM90) \u67b6\u6784\u4e2d\uff0c\u5f15\u5165\u4e86\u65b0\u4e00\u4ee3\u7684 GMMA (Group Matrix Multiply-Accumulate) \u6307\u4ee4\uff0c\u8fd9\u4e9b\u6307\u4ee4\u63d0\u4f9b\u4e86\u66f4\u9ad8\u7684\u6027\u80fd\u548c\u66f4\u7075\u6d3b\u7684\u5185\u5b58\u5e03\u5c40\u652f\u6301\u3002\u672c\u6587\u6863\u5c06\u8be6\u7ec6\u4ecb\u7ecd SM90 \u67b6\u6784\u4e0b\u7684 GMMA \u76f8\u5173\u6982\u5ff5\u3001\u6570\u636e\u7ed3\u6784\u548c\u4f7f\u7528\u65b9\u6cd5\u3002 GMMA \u6982\u8ff0 GMMA \u662f Hopper \u67b6\u6784\u4e2d\u5f15\u5165\u7684\u65b0\u4e00\u4ee3\u77e9\u9635\u4e58\u6cd5\u7d2f\u52a0\u6307\u4ee4\uff0c\u4e0e\u4e4b\u524d\u67b6\u6784\u4e2d\u7684 MMA \u6307\u4ee4\u76f8\u6bd4\uff0cGMMA \u63d0\u4f9b\u4e86\u4ee5\u4e0b\u6539\u8fdb\uff1a \u652f\u6301\u66f4\u5927\u7684\u77e9\u9635\u64cd\u4f5c\uff08\u5982 64x128x16\uff09 warpgroup \u7ea7\u522b\u7684\u534f\u4f5c\uff08128\u4e2a\u7ebf\u7a0b\uff09 \u66f4\u7075\u6d3b\u7684\u5171\u4eab\u5185\u5b58\u5e03\u5c40\u652f\u6301 \u652f\u6301\u591a\u79cd\u6570\u636e\u7c7b\u578b\u7ec4\u5408 GmmaDescriptor \u7ed3\u6784 \u5728\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u7684 GMMA \u64cd\u4f5c\u4e2d\uff0c fma \u51fd\u6570\u7684 desc_a \u548c desc_b \u53c2\u6570\u4f7f\u7528 GmmaDescriptor \u7c7b\u578b\uff0c\u8be5\u7ed3\u6784\u5305\u542b\u4e86 swizzle \u4fe1\u606f\u548c\u5176\u4ed6\u5185\u5b58\u5e03\u5c40\u53c2\u6570\uff1a union GmmaDescriptor { // ... \u5176\u4ed6\u6210\u5458 ... // Bitfield implementation avoids the need for shifts in assignment struct { // start_address, bit [0,14), 4LSB not included uint16_t start_address_ : 14, : 2; // 14 bits [0,14), 2 bits unused // leading dimension byte offset, bit [16,30), 4LSB not included // For N: This is the stride from the first col to the second col of the 8x2 brick in INTERLEAVED // Unused for all SWIZZLE_* layouts (and assumed to be 1) // For T: This is the stride from the first 8 rows to the next 8 rows. uint16_t leading_byte_offset_ : 14, : 2; // 14 bits [0,14), 2 bits unused // stride dimension byte offset, bit [32,46), 4LSB not included // For N: This is the stride from the first 8 rows to the next 8 rows. // For T: This is the stride fro mthe first 8 cols to the next 8 cols. uint16_t stride_byte_offset_ : 14, : 2; // 14 bits [0,14), 2 bits unused // base_offset, bit [49,52) // Valid only for SWIZZLE_128B and SWIZZLE_64B uint8_t : 1, base_offset_ : 3, : 4; // 1 bit unused, 3 bits [1,4), 4 bits unused // layout type, bit [62,64) // SWIZZLE_NONE = 0, SWIZZLE_32B = 3, SWIZZLE_64B = 2, SWIZZLE_128B = 1 uint8_t : 6, layout_type_ : 2; // 6 bits unused, 2 bits [6,8) } bitfield; // ... \u5176\u4ed6\u6210\u5458 ... }; \u5176\u4e2d layout_type_ \u5b57\u6bb5\u76f4\u63a5\u63cf\u8ff0\u4e86 swizzle \u7c7b\u578b\uff1a LayoutType::INTERLEAVE (0): \u65e0 swizzle LayoutType::B128 (1): 128\u5b57\u8282 swizzle LayoutType::B64 (2): 64\u5b57\u8282 swizzle LayoutType::B32 (3): 32\u5b57\u8282 swizzle LayoutType \u679a\u4e3e LayoutType \u5b9a\u4e49\u4e86\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40\u7c7b\u578b\uff1a INTERLEAVE : \u65e0 swizzle \u64cd\u4f5c B32 : 32 \u5b57\u8282 swizzle B64 : 64 \u5b57\u8282 swizzle B128 : 128 \u5b57\u8282 swizzle Swizzle \u673a\u5236\u8be6\u89e3 Swizzle \u53c2\u6570 (B, M, S) \u5728 CuTe \u4e2d\uff0cSwizzle \u662f\u4e00\u4e2a\u6a21\u677f\u7c7b\uff0c\u5b9a\u4e49\u5982\u4e0b\uff1a template <int BBits, int MBase, int SShift = BBits> struct Swizzle \u4e09\u4e2a\u6a21\u677f\u53c2\u6570\u7684\u542b\u4e49\uff1a BBits (B) : \u8868\u793a\u53c2\u4e0e swizzle \u64cd\u4f5c\u7684\u4f4d\u6570\uff0c\u5373\u63a9\u7801\u4e2d\u7684\u4f4d\u6570 MBase (M) : \u8868\u793a\u4fdd\u6301\u4e0d\u53d8\u7684\u6700\u4f4e\u6709\u6548\u4f4d\u6570 SShift (S) : \u8868\u793a YYY \u63a9\u7801\u7684\u79fb\u4f4d\u8ddd\u79bb\uff08\u6b63\u6570\u8868\u793a\u5411\u53f3\u79fb\u4f4d\uff0c\u8d1f\u6570\u8868\u793a\u5411\u5de6\u79fb\u4f4d\uff09 Swizzle \u5de5\u4f5c\u539f\u7406 Swizzle \u64cd\u4f5c\u7684\u4f4d\u5e03\u5c40\u5982\u4e0b\uff1a 0bxxxxxxxxxxxxxxxYYYxxxxxxxZZZxxxx ^--^ MBase \u662f\u4fdd\u6301\u4e0d\u53d8\u7684\u6700\u4f4e\u6709\u6548\u4f4d\u6570 ^-^ ^-^ BBits \u662f\u63a9\u7801\u4e2d\u7684\u4f4d\u6570 ^---------^ SShift \u662f YYY \u63a9\u7801\u7684\u79fb\u4f4d\u8ddd\u79bb \u4f8b\u5982\uff1a 0bxxxxxxxxxxxxxxxxYYxxxxxxxxxZZxxx \u7ed3\u679c\u662f\uff1a 0bxxxxxxxxxxxxxxxxYYxxxxxxxxxAAxxx \u5176\u4e2d AA = ZZ xor YY B32, B64, B128 \u6570\u503c\u542b\u4e49 B32\u3001B64 \u548c B128 \u8fd9\u4e09\u4e2a swizzle \u6a21\u5f0f\u7684\u6570\u503c\u4ee3\u8868\u4e86\u4e0d\u540c\u7684 swizzle \u7c92\u5ea6\u548c\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff1a B32 (\u6570\u503c1) : 32\u5b57\u8282 swizzle \u6a21\u5f0f \u4f7f\u7528 Swizzle<1,4,3> \u6a21\u677f\u53c2\u6570 \u5bf9 32 \u5b57\u8282 (256 \u4f4d) \u7684\u6570\u636e\u5757\u8fdb\u884c swizzle \u64cd\u4f5c \u9002\u7528\u4e8e\u8f83\u5c0f\u7684\u6570\u636e\u5757\u6216\u7279\u5b9a\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f B64 (\u6570\u503c2) : 64\u5b57\u8282 swizzle \u6a21\u5f0f \u4f7f\u7528 Swizzle<2,4,3> \u6a21\u677f\u53c2\u6570 \u5bf9 64 \u5b57\u8282 (512 \u4f4d) \u7684\u6570\u636e\u5757\u8fdb\u884c swizzle \u64cd\u4f5c \u63d0\u4f9b\u4e2d\u7b49\u7c92\u5ea6\u7684\u5185\u5b58\u8bbf\u95ee\u4f18\u5316 B128 (\u6570\u503c3) : 128\u5b57\u8282 swizzle \u6a21\u5f0f \u4f7f\u7528 Swizzle<3,4,3> \u6a21\u677f\u53c2\u6570 \u5bf9 128 \u5b57\u8282 (1024 \u4f4d) \u7684\u6570\u636e\u5757\u8fdb\u884c swizzle \u64cd\u4f5c \u63d0\u4f9b\u6700\u5927\u7c92\u5ea6\u7684\u5185\u5b58\u8bbf\u95ee\u4f18\u5316\uff0c\u9002\u7528\u4e8e\u5927\u89c4\u6a21\u6570\u636e\u5904\u7406 \u8fd9\u4e9b\u6570\u503c\u5728 layout_type \u51fd\u6570\u4e2d\u88ab\u6620\u5c04\u4e3a\u5bf9\u5e94\u7684 LayoutType \u679a\u4e3e\u503c\uff1a num_bits = 1 \u5bf9\u5e94 LayoutType::B32 (32\u5b57\u8282 swizzle) num_bits = 2 \u5bf9\u5e94 LayoutType::B64 (64\u5b57\u8282 swizzle) num_bits = 3 \u5bf9\u5e94 LayoutType::B128 (128\u5b57\u8282 swizzle) \u6570\u503c\u8d8a\u5927\u8868\u793a swizzle \u64cd\u4f5c\u7684\u7c92\u5ea6\u8d8a\u5927\uff0c\u53ef\u4ee5\u66f4\u597d\u5730\u4f18\u5316\u5927\u89c4\u6a21\u6570\u636e\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u4f46\u4e5f\u53ef\u80fd\u589e\u52a0\u5b9e\u73b0\u7684\u590d\u6742\u6027\u3002 Layout \u5982\u4f55\u63cf\u8ff0 Swizzle \u5728 CuTe \u4e2d\uff0cLayout \u53ef\u4ee5\u901a\u8fc7 ComposedLayout \u6765\u63cf\u8ff0 swizzle\u3002 ComposedLayout \u662f\u4e00\u79cd\u7ec4\u5408\u5e03\u5c40\uff0c\u5b83\u5c06\u591a\u4e2a\u5e03\u5c40\u6216\u53d8\u6362\u7ec4\u5408\u5728\u4e00\u8d77\uff0c\u5176\u4e2d\u5c31\u5305\u62ec Swizzle \u53d8\u6362\u3002 \u4e00\u4e2a\u5178\u578b\u7684 swizzle layout \u5b9a\u4e49\u5982\u4e0b\uff1a using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape< _1024,_8>,Stride<_1,_1024>>>; \u8fd9\u4e2a\u5b9a\u4e49\u5305\u542b\u4e09\u4e2a\u90e8\u5206\uff1a Swizzle<3,4,3> : Swizzle \u53d8\u6362\u51fd\u6570\uff0c\u63cf\u8ff0\u4e86\u5982\u4f55\u8fdb\u884c\u5185\u5b58\u5730\u5740\u7684 swizzle \u64cd\u4f5c smem_ptr_flag : \u504f\u79fb\u91cf\uff0c\u901a\u5e38\u4e3a 0\uff0c\u7528\u4e8e\u8c03\u6574\u5730\u5740\u504f\u79fb Layout<Shape< _1024,_8>,Stride<_1,_1024>> : \u57fa\u7840\u5e03\u5c40\uff0c\u63cf\u8ff0\u4e86\u6570\u636e\u7684\u57fa\u672c\u6392\u5217\u65b9\u5f0f \u901a\u8fc7\u8fd9\u79cd\u7ec4\u5408\u65b9\u5f0f\uff0cLayout \u80fd\u591f\u5b8c\u6574\u5730\u63cf\u8ff0\u5305\u542b swizzle \u53d8\u6362\u7684\u590d\u6742\u5185\u5b58\u5e03\u5c40\u3002\u5f53\u9700\u8981\u521b\u5efa\u5b9e\u9645\u7684\u5f20\u91cf\u65f6\uff0cCuTe \u4f1a\u5c06\u8fd9\u4e9b\u4fe1\u606f\u7efc\u5408\u8d77\u6765\uff0c\u751f\u6210\u80fd\u591f\u6b63\u786e\u8bbf\u95ee swizzled \u5185\u5b58\u7684\u4ee3\u7801\u3002 \u4f8b\u5982\uff0c\u5728 GMMA \u64cd\u4f5c\u4e2d\uff0c\u5e38\u89c1\u7684 swizzle layouts \u5b9a\u4e49\u5982\u4e0b\uff1a // M|N-major GMMA layouts in units of bits using Layout_MN_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape< _128,_8>,Stride<_1, _128>>>; using Layout_MN_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape< _256,_8>,Stride<_1, _256>>>; using Layout_MN_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape< _512,_8>,Stride<_1, _512>>>; using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_1024,_8>,Stride<_1,_1024>>>; // K-major GMMA layouts in units of bits using Layout_K_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape<_8, _128>,Stride< _128,_1>>>; using Layout_K_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape<_8, _256>,Stride< _256,_1>>>; using Layout_K_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape<_8, _512>,Stride< _512,_1>>>; using Layout_K_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_8,_1024>,Stride<_1024,_1>>>; \u8fd9\u4e9b\u5b9a\u4e49\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ComposedLayout \u5c06 Swizzle \u53d8\u6362\u4e0e\u57fa\u7840\u5185\u5b58\u5e03\u5c40\u7ec4\u5408\u8d77\u6765\uff0c\u5f62\u6210\u5b8c\u6574\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u63cf\u8ff0\u3002 Swizzle \u673a\u5236\u5b9e\u73b0\u539f\u7406 Swizzle \u673a\u5236\u901a\u8fc7\u4f4d\u64cd\u4f5c\u6765\u91cd\u65b0\u6392\u5217\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u4ee5\u63d0\u9ad8\u5185\u5b58\u5e26\u5bbd\u5229\u7528\u7387\u548c\u7f13\u5b58\u5c40\u90e8\u6027\u3002\u5728 CuTe \u4e2d\uff0cSwizzle \u7684\u5b9e\u73b0\u57fa\u4e8e\u4f4d\u63a9\u7801\u64cd\u4f5c\uff1a template <int BBits, int MBase, int SShift = BBits> struct Swizzle { static constexpr int num_bits = BBits; static constexpr int num_base = MBase; static constexpr int num_shft = SShift; // \u4f7f\u7528 'int' \u7c7b\u578b\u4ee5\u907f\u514d\u65e0\u610f\u4e2d\u8f6c\u6362\u4e3a\u65e0\u7b26\u53f7\u6570 using bit_msk = cute::constant<int, (1 << num_bits) - 1>; using yyy_msk = cute::constant<int, bit_msk{} << (num_base + max(0,num_shft))>; using zzz_msk = cute::constant<int, bit_msk{} << (num_base - min(0,num_shft))>; using msk_sft = cute::constant<int, num_shft>; static constexpr uint32_t swizzle_code = uint32_t(yyy_msk::value | zzz_msk::value); template <class Offset> CUTE_HOST_DEVICE constexpr static auto apply(Offset const& offset) { return offset ^ shiftr(offset & yyy_msk{}, msk_sft{}); // ZZZ ^= YYY } template <class Offset> CUTE_HOST_DEVICE constexpr auto operator()(Offset const& offset) const { return apply(offset); } }; Swizzle \u7684\u6838\u5fc3\u5b9e\u73b0\u539f\u7406\u662f\u901a\u8fc7\u4f4d\u64cd\u4f5c\u6765\u4ea4\u6362\u7279\u5b9a\u4f4d\u7f6e\u7684\u4f4d\uff1a \u4f4d\u63a9\u7801\u521b\u5efa \uff1a bit_msk \u521b\u5efa\u4e00\u4e2a\u5305\u542b num_bits \u4e2a1\u7684\u63a9\u7801 yyy_msk \u521b\u5efa YYY \u4f4d\u7684\u63a9\u7801\uff0c\u4f4d\u7f6e\u6839\u636e num_base \u548c num_shft \u786e\u5b9a zzz_msk \u521b\u5efa ZZZ \u4f4d\u7684\u63a9\u7801\uff0c\u4f4d\u7f6e\u540c\u6837\u6839\u636e num_base \u548c num_shft \u786e\u5b9a \u4f4d\u64cd\u4f5c\u5e94\u7528 \uff1a \u901a\u8fc7 offset & yyy_msk{} \u63d0\u53d6 YYY \u4f4d \u4f7f\u7528 shiftr \u51fd\u6570\u6839\u636e msk_sft \u79fb\u4f4d \u6700\u540e\u901a\u8fc7\u5f02\u6216\u64cd\u4f5c ( ^ ) \u5c06\u79fb\u4f4d\u540e\u7684 YYY \u4f4d\u4e0e ZZZ \u4f4d\u4ea4\u6362 \u8fd9\u79cd\u4f4d\u64cd\u4f5c\u673a\u5236\u5141\u8bb8\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u4ece\u800c\u4f18\u5316 GPU \u5185\u5b58\u5b50\u7cfb\u7edf\u7684\u4f7f\u7528\u3002 \u5982\u4f55\u4ece Tensor Engine \u4e2d\u63d0\u53d6 BMS \u53c2\u6570 layout_type \u51fd\u6570\u901a\u8fc7 get_swizzle_t \u4ece Tensor \u7684 Engine \u4e2d\u63d0\u53d6 Swizzle \u4fe1\u606f\uff1a template <class Engine, class Shape, class Stride> CUTE_HOST_DEVICE constexpr LayoutType layout_type(Tensor<Engine, Layout<Shape,Stride>> const&) { static_assert(is_same<uint128_t, typename Engine::value_type>::value, \"Expected uint128_t type in LayoutType conversion.\"); using Swizzle = get_swizzle_t<Engine>; constexpr int B = Swizzle::num_bits; constexpr int M = Swizzle::num_base; constexpr int S = Swizzle::num_shft; static_assert(M == 4, \"Unsupported layout swizzle\"); static_assert(0 <= B && B <= 3, \"Unsupported layout swizzle\"); static_assert(S == 3, \"Unsupported layout swizzle\"); switch (B) { case 0: return LayoutType::INTERLEAVE; case 1: return LayoutType::B32; case 2: return LayoutType::B64; case 3: return LayoutType::B128; } return LayoutType::INTERLEAVE; // ERROR } \u5bf9\u5e94\u5173\u7cfb\uff1a num_bits = 0 \u5bf9\u5e94 LayoutType::INTERLEAVE (\u65e0 swizzle) num_bits = 1 \u5bf9\u5e94 LayoutType::B32 (32\u5b57\u8282 swizzle) num_bits = 2 \u5bf9\u5e94 LayoutType::B64 (64\u5b57\u8282 swizzle) num_bits = 3 \u5bf9\u5e94 LayoutType::B128 (128\u5b57\u8282 swizzle) Swizzle \u4fe1\u606f\u7684\u83b7\u53d6 make_gmma_desc \u51fd\u6570\u901a\u8fc7\u5206\u6790\u5f20\u91cf\u7684\u5e03\u5c40\u4fe1\u606f\u6765\u786e\u5b9a swizzle \u7c7b\u578b\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5b83\u4f7f\u7528 layout_type \u51fd\u6570\u6765\u63d0\u53d6 swizzle \u4fe1\u606f\uff1a template <class Engine, class Shape, class Stride> CUTE_HOST_DEVICE constexpr LayoutType layout_type(Tensor<Engine, Layout<Shape,Stride>> const&) { static_assert(is_same<uint128_t, typename Engine::value_type>::value, \"Expected uint128_t type in LayoutType conversion.\"); using Swizzle = get_swizzle_t<Engine>; constexpr int B = Swizzle::num_bits; constexpr int M = Swizzle::num_base; constexpr int S = Swizzle::num_shft; static_assert(M == 4, \"Unsupported layout swizzle\"); static_assert(0 <= B && B <= 3, \"Unsupported layout swizzle\"); static_assert(S == 3, \"Unsupported layout swizzle\"); switch (B) { case 0: return LayoutType::INTERLEAVE; case 1: return LayoutType::B32; case 2: return LayoutType::B64; case 3: return LayoutType::B128; } return LayoutType::INTERLEAVE; // ERROR } \u8fd9\u4e2a\u51fd\u6570\u4ece\u5f20\u91cf\u7684 Engine \u7c7b\u578b\u4e2d\u63d0\u53d6 Swizzle \u4fe1\u606f\uff0c\u7136\u540e\u6839\u636e Swizzle \u7684 num_bits \u5b57\u6bb5\u786e\u5b9a swizzle \u7c7b\u578b\uff1a \u5f53 num_bits = 0 \u65f6\uff0c\u5bf9\u5e94 LayoutType::INTERLEAVE (\u65e0 swizzle) \u5f53 num_bits = 1 \u65f6\uff0c\u5bf9\u5e94 LayoutType::B32 (32\u5b57\u8282 swizzle) \u5f53 num_bits = 2 \u65f6\uff0c\u5bf9\u5e94 LayoutType::B64 (64\u5b57\u8282 swizzle) \u5f53 num_bits = 3 \u65f6\uff0c\u5bf9\u5e94 LayoutType::B128 (128\u5b57\u8282 swizzle) GMMA Descriptor \u7684\u6784\u5efa\u8fc7\u7a0b GMMA Descriptor \u662f\u901a\u8fc7 make_gmma_desc \u51fd\u6570\u6784\u5efa\u7684\u3002\u8fd9\u4e2a\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u5171\u4eab\u5185\u5b58\u5f20\u91cf\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u6839\u636e\u5f20\u91cf\u7684\u5e03\u5c40\u4fe1\u606f\u521b\u5efa\u76f8\u5e94\u7684\u63cf\u8ff0\u7b26\uff1a template <Major MajorMode, class TEngine, class TLayout> CUTE_HOST_DEVICE constexpr GmmaDescriptor make_gmma_desc(Tensor<TEngine,TLayout> const& tensor) { static_assert(is_smem<TEngine>::value, \"GMMA Descriptors can only be constructed on smem.\"); static_assert(TLayout::rank == 2, \"GMMA Descriptors can only be constructed on rank-2 tensors.\"); using value_type = typename TEngine::value_type; // ... \u5b9e\u73b0\u7ec6\u8282 ... } \u8fd9\u4e2a\u51fd\u6570\u4f1a\u5206\u6790\u5f20\u91cf\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u63d0\u53d6\u8d77\u59cb\u5730\u5740\u3001\u6b65\u5e45\u7b49\u4fe1\u606f\uff0c\u5e76\u6839\u636e\u5e03\u5c40\u7c7b\u578b\u8bbe\u7f6e\u76f8\u5e94\u7684 swizzle \u6a21\u5f0f\u3002 DescriptorIterator \u548c smem_desc \u5728 CuTe \u4e2d\uff0c DescriptorIterator \u662f\u4e00\u4e2a\u5305\u88c5 GmmaDescriptor \u7684\u8fed\u4ee3\u5668\uff0c\u7528\u4e8e\u5728 GMMA \u64cd\u4f5c\u4e2d\u4f20\u9012\u63cf\u8ff0\u7b26\u4fe1\u606f\u3002 smem_desc \u662f\u4e00\u4e2a\u6a21\u677f\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u521b\u5efa\u5171\u4eab\u5185\u5b58\u63cf\u8ff0\u7b26\u5f20\u91cf\uff1a template <Major> struct smem_desc : DescriptorIterator {}; \u901a\u8fc7 MakeTensor \u5b9a\u5236\u70b9\u521b\u5efa smem_desc \u5f20\u91cf\uff1a // Customization point for creating a GMMA::smem_desc Tensor template <SM90::GMMA::Major MajorMode> struct MakeTensor<SMMA::GMMA::smem_desc<MajorMode>> { template <class TEngine, class TLayout> CUTE_HOST_DEVICE constexpr auto operator()(Tensor<TEngine,TLayout> const& smem_tensor) { static_assert(is_smem<TEngine>::value, \"Expected SMEM Tensor to construct a GMMA Desc Tensor\"); return make_tensor(SM90::GMMA::DescriptorIterator{SM90::GMMA::make_gmma_desc<MajorMode>(tensor<0>(smem_tensor))}, replace<0>(recast<uint128_t const>(smem_tensor).layout(), Layout<_1,_0>{})); } }; GMMA \u5185\u5b58\u5e03\u5c40 GMMA \u652f\u6301\u591a\u79cd\u5171\u4eab\u5185\u5b58\u5e03\u5c40\uff0c\u5305\u62ec M|N-major \u548c K-major \u5e03\u5c40\uff1a M|N-major \u5e03\u5c40 // M|N-major GMMA layouts in units of bits using Layout_MN_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape< _128,_8>,Stride<_1, _128>>>; using Layout_MN_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape< _256,_8>,Stride<_1, _256>>>; using Layout_MN_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape< _512,_8>,Stride<_1, _512>>>; using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_1024,_8>,Stride<_1,_1024>>>; K-major \u5e03\u5c40 // K-major GMMA layouts in units of bits using Layout_K_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape<_8, _128>,Stride< _128,_1>>>; using Layout_K_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape<_8, _256>,Stride< _256,_1>>>; using Layout_K_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape<_8, _512>,Stride< _512,_1>>>; using Layout_K_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_8,_1024>,Stride<_1024,_1>>>; GMMA \u64cd\u4f5c\u793a\u4f8b \u5178\u578b\u7684 GMMA \u64cd\u4f5c\u4f7f\u7528\u793a\u4f8b\uff1a // \u5b9a\u4e49\u8f93\u5165\u5f20\u91cf A\u3001B \u548c\u7d2f\u52a0\u5f20\u91cf C auto A_tensor = make_tensor(A_ptr, A_layout); auto B_tensor = make_tensor(B_ptr, B_layout); auto C_tensor = make_tensor(C_ptr, C_layout); // \u521b\u5efa GMMA \u64cd\u4f5c\u5bf9\u8c61 auto mma_atom = MMA_Atom<SM90_64x64x16_F32F16F16F32_NT>{}; // \u83b7\u53d6 MMA \u64cd\u4f5c\u7684\u53c2\u4e0e\u8005 auto mma_thr = mma_atom.get_thread_slice(thread_idx); // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto accum_fragment = make_fragment_like(C_tensor); clear(accum_fragment); // \u6267\u884c MMA \u64cd\u4f5c mma_thr.call(A_tensor, B_tensor, accum_fragment); \u603b\u7ed3 SM90 \u67b6\u6784\u4e2d\u7684 GMMA \u6307\u4ee4\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u77e9\u9635\u8fd0\u7b97\u80fd\u529b\uff0c\u901a\u8fc7 GmmaDescriptor \u548c\u76f8\u5173\u7684\u5e03\u5c40\u5de5\u5177\uff0c\u5f00\u53d1\u8005\u53ef\u4ee5\u9ad8\u6548\u5730\u5229\u7528\u5171\u4eab\u5185\u5b58\u8fdb\u884c\u5927\u89c4\u6a21\u77e9\u9635\u8fd0\u7b97\u3002\u7406\u89e3\u8fd9\u4e9b\u6982\u5ff5\u548c\u5de5\u5177\u5bf9\u4e8e\u5145\u5206\u5229\u7528 Hopper \u67b6\u6784\u7684\u8ba1\u7b97\u80fd\u529b\u81f3\u5173\u91cd\u8981\u3002","title":"GMMA(SM90)"},{"location":"cute_wgmma_sm90/#cute-wgmma-sm90-hopper","text":"\u5728 NVIDIA Hopper (SM90) \u67b6\u6784\u4e2d\uff0c\u5f15\u5165\u4e86\u65b0\u4e00\u4ee3\u7684 GMMA (Group Matrix Multiply-Accumulate) \u6307\u4ee4\uff0c\u8fd9\u4e9b\u6307\u4ee4\u63d0\u4f9b\u4e86\u66f4\u9ad8\u7684\u6027\u80fd\u548c\u66f4\u7075\u6d3b\u7684\u5185\u5b58\u5e03\u5c40\u652f\u6301\u3002\u672c\u6587\u6863\u5c06\u8be6\u7ec6\u4ecb\u7ecd SM90 \u67b6\u6784\u4e0b\u7684 GMMA \u76f8\u5173\u6982\u5ff5\u3001\u6570\u636e\u7ed3\u6784\u548c\u4f7f\u7528\u65b9\u6cd5\u3002","title":"CuTe WGmma SM90 (Hopper) \u8be6\u89e3"},{"location":"cute_wgmma_sm90/#gmma","text":"GMMA \u662f Hopper \u67b6\u6784\u4e2d\u5f15\u5165\u7684\u65b0\u4e00\u4ee3\u77e9\u9635\u4e58\u6cd5\u7d2f\u52a0\u6307\u4ee4\uff0c\u4e0e\u4e4b\u524d\u67b6\u6784\u4e2d\u7684 MMA \u6307\u4ee4\u76f8\u6bd4\uff0cGMMA \u63d0\u4f9b\u4e86\u4ee5\u4e0b\u6539\u8fdb\uff1a \u652f\u6301\u66f4\u5927\u7684\u77e9\u9635\u64cd\u4f5c\uff08\u5982 64x128x16\uff09 warpgroup \u7ea7\u522b\u7684\u534f\u4f5c\uff08128\u4e2a\u7ebf\u7a0b\uff09 \u66f4\u7075\u6d3b\u7684\u5171\u4eab\u5185\u5b58\u5e03\u5c40\u652f\u6301 \u652f\u6301\u591a\u79cd\u6570\u636e\u7c7b\u578b\u7ec4\u5408","title":"GMMA \u6982\u8ff0"},{"location":"cute_wgmma_sm90/#gmmadescriptor","text":"\u5728\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u7684 GMMA \u64cd\u4f5c\u4e2d\uff0c fma \u51fd\u6570\u7684 desc_a \u548c desc_b \u53c2\u6570\u4f7f\u7528 GmmaDescriptor \u7c7b\u578b\uff0c\u8be5\u7ed3\u6784\u5305\u542b\u4e86 swizzle \u4fe1\u606f\u548c\u5176\u4ed6\u5185\u5b58\u5e03\u5c40\u53c2\u6570\uff1a union GmmaDescriptor { // ... \u5176\u4ed6\u6210\u5458 ... // Bitfield implementation avoids the need for shifts in assignment struct { // start_address, bit [0,14), 4LSB not included uint16_t start_address_ : 14, : 2; // 14 bits [0,14), 2 bits unused // leading dimension byte offset, bit [16,30), 4LSB not included // For N: This is the stride from the first col to the second col of the 8x2 brick in INTERLEAVED // Unused for all SWIZZLE_* layouts (and assumed to be 1) // For T: This is the stride from the first 8 rows to the next 8 rows. uint16_t leading_byte_offset_ : 14, : 2; // 14 bits [0,14), 2 bits unused // stride dimension byte offset, bit [32,46), 4LSB not included // For N: This is the stride from the first 8 rows to the next 8 rows. // For T: This is the stride fro mthe first 8 cols to the next 8 cols. uint16_t stride_byte_offset_ : 14, : 2; // 14 bits [0,14), 2 bits unused // base_offset, bit [49,52) // Valid only for SWIZZLE_128B and SWIZZLE_64B uint8_t : 1, base_offset_ : 3, : 4; // 1 bit unused, 3 bits [1,4), 4 bits unused // layout type, bit [62,64) // SWIZZLE_NONE = 0, SWIZZLE_32B = 3, SWIZZLE_64B = 2, SWIZZLE_128B = 1 uint8_t : 6, layout_type_ : 2; // 6 bits unused, 2 bits [6,8) } bitfield; // ... \u5176\u4ed6\u6210\u5458 ... }; \u5176\u4e2d layout_type_ \u5b57\u6bb5\u76f4\u63a5\u63cf\u8ff0\u4e86 swizzle \u7c7b\u578b\uff1a LayoutType::INTERLEAVE (0): \u65e0 swizzle LayoutType::B128 (1): 128\u5b57\u8282 swizzle LayoutType::B64 (2): 64\u5b57\u8282 swizzle LayoutType::B32 (3): 32\u5b57\u8282 swizzle","title":"GmmaDescriptor \u7ed3\u6784"},{"location":"cute_wgmma_sm90/#layouttype","text":"LayoutType \u5b9a\u4e49\u4e86\u4e0d\u540c\u7684\u5185\u5b58\u5e03\u5c40\u7c7b\u578b\uff1a INTERLEAVE : \u65e0 swizzle \u64cd\u4f5c B32 : 32 \u5b57\u8282 swizzle B64 : 64 \u5b57\u8282 swizzle B128 : 128 \u5b57\u8282 swizzle","title":"LayoutType \u679a\u4e3e"},{"location":"cute_wgmma_sm90/#swizzle","text":"","title":"Swizzle \u673a\u5236\u8be6\u89e3"},{"location":"cute_wgmma_sm90/#swizzle-b-m-s","text":"\u5728 CuTe \u4e2d\uff0cSwizzle \u662f\u4e00\u4e2a\u6a21\u677f\u7c7b\uff0c\u5b9a\u4e49\u5982\u4e0b\uff1a template <int BBits, int MBase, int SShift = BBits> struct Swizzle \u4e09\u4e2a\u6a21\u677f\u53c2\u6570\u7684\u542b\u4e49\uff1a BBits (B) : \u8868\u793a\u53c2\u4e0e swizzle \u64cd\u4f5c\u7684\u4f4d\u6570\uff0c\u5373\u63a9\u7801\u4e2d\u7684\u4f4d\u6570 MBase (M) : \u8868\u793a\u4fdd\u6301\u4e0d\u53d8\u7684\u6700\u4f4e\u6709\u6548\u4f4d\u6570 SShift (S) : \u8868\u793a YYY \u63a9\u7801\u7684\u79fb\u4f4d\u8ddd\u79bb\uff08\u6b63\u6570\u8868\u793a\u5411\u53f3\u79fb\u4f4d\uff0c\u8d1f\u6570\u8868\u793a\u5411\u5de6\u79fb\u4f4d\uff09","title":"Swizzle \u53c2\u6570 (B, M, S)"},{"location":"cute_wgmma_sm90/#swizzle_1","text":"Swizzle \u64cd\u4f5c\u7684\u4f4d\u5e03\u5c40\u5982\u4e0b\uff1a 0bxxxxxxxxxxxxxxxYYYxxxxxxxZZZxxxx ^--^ MBase \u662f\u4fdd\u6301\u4e0d\u53d8\u7684\u6700\u4f4e\u6709\u6548\u4f4d\u6570 ^-^ ^-^ BBits \u662f\u63a9\u7801\u4e2d\u7684\u4f4d\u6570 ^---------^ SShift \u662f YYY \u63a9\u7801\u7684\u79fb\u4f4d\u8ddd\u79bb \u4f8b\u5982\uff1a 0bxxxxxxxxxxxxxxxxYYxxxxxxxxxZZxxx \u7ed3\u679c\u662f\uff1a 0bxxxxxxxxxxxxxxxxYYxxxxxxxxxAAxxx \u5176\u4e2d AA = ZZ xor YY","title":"Swizzle \u5de5\u4f5c\u539f\u7406"},{"location":"cute_wgmma_sm90/#b32-b64-b128","text":"B32\u3001B64 \u548c B128 \u8fd9\u4e09\u4e2a swizzle \u6a21\u5f0f\u7684\u6570\u503c\u4ee3\u8868\u4e86\u4e0d\u540c\u7684 swizzle \u7c92\u5ea6\u548c\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff1a B32 (\u6570\u503c1) : 32\u5b57\u8282 swizzle \u6a21\u5f0f \u4f7f\u7528 Swizzle<1,4,3> \u6a21\u677f\u53c2\u6570 \u5bf9 32 \u5b57\u8282 (256 \u4f4d) \u7684\u6570\u636e\u5757\u8fdb\u884c swizzle \u64cd\u4f5c \u9002\u7528\u4e8e\u8f83\u5c0f\u7684\u6570\u636e\u5757\u6216\u7279\u5b9a\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f B64 (\u6570\u503c2) : 64\u5b57\u8282 swizzle \u6a21\u5f0f \u4f7f\u7528 Swizzle<2,4,3> \u6a21\u677f\u53c2\u6570 \u5bf9 64 \u5b57\u8282 (512 \u4f4d) \u7684\u6570\u636e\u5757\u8fdb\u884c swizzle \u64cd\u4f5c \u63d0\u4f9b\u4e2d\u7b49\u7c92\u5ea6\u7684\u5185\u5b58\u8bbf\u95ee\u4f18\u5316 B128 (\u6570\u503c3) : 128\u5b57\u8282 swizzle \u6a21\u5f0f \u4f7f\u7528 Swizzle<3,4,3> \u6a21\u677f\u53c2\u6570 \u5bf9 128 \u5b57\u8282 (1024 \u4f4d) \u7684\u6570\u636e\u5757\u8fdb\u884c swizzle \u64cd\u4f5c \u63d0\u4f9b\u6700\u5927\u7c92\u5ea6\u7684\u5185\u5b58\u8bbf\u95ee\u4f18\u5316\uff0c\u9002\u7528\u4e8e\u5927\u89c4\u6a21\u6570\u636e\u5904\u7406 \u8fd9\u4e9b\u6570\u503c\u5728 layout_type \u51fd\u6570\u4e2d\u88ab\u6620\u5c04\u4e3a\u5bf9\u5e94\u7684 LayoutType \u679a\u4e3e\u503c\uff1a num_bits = 1 \u5bf9\u5e94 LayoutType::B32 (32\u5b57\u8282 swizzle) num_bits = 2 \u5bf9\u5e94 LayoutType::B64 (64\u5b57\u8282 swizzle) num_bits = 3 \u5bf9\u5e94 LayoutType::B128 (128\u5b57\u8282 swizzle) \u6570\u503c\u8d8a\u5927\u8868\u793a swizzle \u64cd\u4f5c\u7684\u7c92\u5ea6\u8d8a\u5927\uff0c\u53ef\u4ee5\u66f4\u597d\u5730\u4f18\u5316\u5927\u89c4\u6a21\u6570\u636e\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u4f46\u4e5f\u53ef\u80fd\u589e\u52a0\u5b9e\u73b0\u7684\u590d\u6742\u6027\u3002","title":"B32, B64, B128 \u6570\u503c\u542b\u4e49"},{"location":"cute_wgmma_sm90/#layout-swizzle","text":"\u5728 CuTe \u4e2d\uff0cLayout \u53ef\u4ee5\u901a\u8fc7 ComposedLayout \u6765\u63cf\u8ff0 swizzle\u3002 ComposedLayout \u662f\u4e00\u79cd\u7ec4\u5408\u5e03\u5c40\uff0c\u5b83\u5c06\u591a\u4e2a\u5e03\u5c40\u6216\u53d8\u6362\u7ec4\u5408\u5728\u4e00\u8d77\uff0c\u5176\u4e2d\u5c31\u5305\u62ec Swizzle \u53d8\u6362\u3002 \u4e00\u4e2a\u5178\u578b\u7684 swizzle layout \u5b9a\u4e49\u5982\u4e0b\uff1a using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape< _1024,_8>,Stride<_1,_1024>>>; \u8fd9\u4e2a\u5b9a\u4e49\u5305\u542b\u4e09\u4e2a\u90e8\u5206\uff1a Swizzle<3,4,3> : Swizzle \u53d8\u6362\u51fd\u6570\uff0c\u63cf\u8ff0\u4e86\u5982\u4f55\u8fdb\u884c\u5185\u5b58\u5730\u5740\u7684 swizzle \u64cd\u4f5c smem_ptr_flag : \u504f\u79fb\u91cf\uff0c\u901a\u5e38\u4e3a 0\uff0c\u7528\u4e8e\u8c03\u6574\u5730\u5740\u504f\u79fb Layout<Shape< _1024,_8>,Stride<_1,_1024>> : \u57fa\u7840\u5e03\u5c40\uff0c\u63cf\u8ff0\u4e86\u6570\u636e\u7684\u57fa\u672c\u6392\u5217\u65b9\u5f0f \u901a\u8fc7\u8fd9\u79cd\u7ec4\u5408\u65b9\u5f0f\uff0cLayout \u80fd\u591f\u5b8c\u6574\u5730\u63cf\u8ff0\u5305\u542b swizzle \u53d8\u6362\u7684\u590d\u6742\u5185\u5b58\u5e03\u5c40\u3002\u5f53\u9700\u8981\u521b\u5efa\u5b9e\u9645\u7684\u5f20\u91cf\u65f6\uff0cCuTe \u4f1a\u5c06\u8fd9\u4e9b\u4fe1\u606f\u7efc\u5408\u8d77\u6765\uff0c\u751f\u6210\u80fd\u591f\u6b63\u786e\u8bbf\u95ee swizzled \u5185\u5b58\u7684\u4ee3\u7801\u3002 \u4f8b\u5982\uff0c\u5728 GMMA \u64cd\u4f5c\u4e2d\uff0c\u5e38\u89c1\u7684 swizzle layouts \u5b9a\u4e49\u5982\u4e0b\uff1a // M|N-major GMMA layouts in units of bits using Layout_MN_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape< _128,_8>,Stride<_1, _128>>>; using Layout_MN_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape< _256,_8>,Stride<_1, _256>>>; using Layout_MN_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape< _512,_8>,Stride<_1, _512>>>; using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_1024,_8>,Stride<_1,_1024>>>; // K-major GMMA layouts in units of bits using Layout_K_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape<_8, _128>,Stride< _128,_1>>>; using Layout_K_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape<_8, _256>,Stride< _256,_1>>>; using Layout_K_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape<_8, _512>,Stride< _512,_1>>>; using Layout_K_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_8,_1024>,Stride<_1024,_1>>>; \u8fd9\u4e9b\u5b9a\u4e49\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 ComposedLayout \u5c06 Swizzle \u53d8\u6362\u4e0e\u57fa\u7840\u5185\u5b58\u5e03\u5c40\u7ec4\u5408\u8d77\u6765\uff0c\u5f62\u6210\u5b8c\u6574\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u63cf\u8ff0\u3002","title":"Layout \u5982\u4f55\u63cf\u8ff0 Swizzle"},{"location":"cute_wgmma_sm90/#swizzle_2","text":"Swizzle \u673a\u5236\u901a\u8fc7\u4f4d\u64cd\u4f5c\u6765\u91cd\u65b0\u6392\u5217\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u4ee5\u63d0\u9ad8\u5185\u5b58\u5e26\u5bbd\u5229\u7528\u7387\u548c\u7f13\u5b58\u5c40\u90e8\u6027\u3002\u5728 CuTe \u4e2d\uff0cSwizzle \u7684\u5b9e\u73b0\u57fa\u4e8e\u4f4d\u63a9\u7801\u64cd\u4f5c\uff1a template <int BBits, int MBase, int SShift = BBits> struct Swizzle { static constexpr int num_bits = BBits; static constexpr int num_base = MBase; static constexpr int num_shft = SShift; // \u4f7f\u7528 'int' \u7c7b\u578b\u4ee5\u907f\u514d\u65e0\u610f\u4e2d\u8f6c\u6362\u4e3a\u65e0\u7b26\u53f7\u6570 using bit_msk = cute::constant<int, (1 << num_bits) - 1>; using yyy_msk = cute::constant<int, bit_msk{} << (num_base + max(0,num_shft))>; using zzz_msk = cute::constant<int, bit_msk{} << (num_base - min(0,num_shft))>; using msk_sft = cute::constant<int, num_shft>; static constexpr uint32_t swizzle_code = uint32_t(yyy_msk::value | zzz_msk::value); template <class Offset> CUTE_HOST_DEVICE constexpr static auto apply(Offset const& offset) { return offset ^ shiftr(offset & yyy_msk{}, msk_sft{}); // ZZZ ^= YYY } template <class Offset> CUTE_HOST_DEVICE constexpr auto operator()(Offset const& offset) const { return apply(offset); } }; Swizzle \u7684\u6838\u5fc3\u5b9e\u73b0\u539f\u7406\u662f\u901a\u8fc7\u4f4d\u64cd\u4f5c\u6765\u4ea4\u6362\u7279\u5b9a\u4f4d\u7f6e\u7684\u4f4d\uff1a \u4f4d\u63a9\u7801\u521b\u5efa \uff1a bit_msk \u521b\u5efa\u4e00\u4e2a\u5305\u542b num_bits \u4e2a1\u7684\u63a9\u7801 yyy_msk \u521b\u5efa YYY \u4f4d\u7684\u63a9\u7801\uff0c\u4f4d\u7f6e\u6839\u636e num_base \u548c num_shft \u786e\u5b9a zzz_msk \u521b\u5efa ZZZ \u4f4d\u7684\u63a9\u7801\uff0c\u4f4d\u7f6e\u540c\u6837\u6839\u636e num_base \u548c num_shft \u786e\u5b9a \u4f4d\u64cd\u4f5c\u5e94\u7528 \uff1a \u901a\u8fc7 offset & yyy_msk{} \u63d0\u53d6 YYY \u4f4d \u4f7f\u7528 shiftr \u51fd\u6570\u6839\u636e msk_sft \u79fb\u4f4d \u6700\u540e\u901a\u8fc7\u5f02\u6216\u64cd\u4f5c ( ^ ) \u5c06\u79fb\u4f4d\u540e\u7684 YYY \u4f4d\u4e0e ZZZ \u4f4d\u4ea4\u6362 \u8fd9\u79cd\u4f4d\u64cd\u4f5c\u673a\u5236\u5141\u8bb8\u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u4ece\u800c\u4f18\u5316 GPU \u5185\u5b58\u5b50\u7cfb\u7edf\u7684\u4f7f\u7528\u3002","title":"Swizzle \u673a\u5236\u5b9e\u73b0\u539f\u7406"},{"location":"cute_wgmma_sm90/#tensor-engine-bms","text":"layout_type \u51fd\u6570\u901a\u8fc7 get_swizzle_t \u4ece Tensor \u7684 Engine \u4e2d\u63d0\u53d6 Swizzle \u4fe1\u606f\uff1a template <class Engine, class Shape, class Stride> CUTE_HOST_DEVICE constexpr LayoutType layout_type(Tensor<Engine, Layout<Shape,Stride>> const&) { static_assert(is_same<uint128_t, typename Engine::value_type>::value, \"Expected uint128_t type in LayoutType conversion.\"); using Swizzle = get_swizzle_t<Engine>; constexpr int B = Swizzle::num_bits; constexpr int M = Swizzle::num_base; constexpr int S = Swizzle::num_shft; static_assert(M == 4, \"Unsupported layout swizzle\"); static_assert(0 <= B && B <= 3, \"Unsupported layout swizzle\"); static_assert(S == 3, \"Unsupported layout swizzle\"); switch (B) { case 0: return LayoutType::INTERLEAVE; case 1: return LayoutType::B32; case 2: return LayoutType::B64; case 3: return LayoutType::B128; } return LayoutType::INTERLEAVE; // ERROR } \u5bf9\u5e94\u5173\u7cfb\uff1a num_bits = 0 \u5bf9\u5e94 LayoutType::INTERLEAVE (\u65e0 swizzle) num_bits = 1 \u5bf9\u5e94 LayoutType::B32 (32\u5b57\u8282 swizzle) num_bits = 2 \u5bf9\u5e94 LayoutType::B64 (64\u5b57\u8282 swizzle) num_bits = 3 \u5bf9\u5e94 LayoutType::B128 (128\u5b57\u8282 swizzle)","title":"\u5982\u4f55\u4ece Tensor Engine \u4e2d\u63d0\u53d6 BMS \u53c2\u6570"},{"location":"cute_wgmma_sm90/#swizzle_3","text":"make_gmma_desc \u51fd\u6570\u901a\u8fc7\u5206\u6790\u5f20\u91cf\u7684\u5e03\u5c40\u4fe1\u606f\u6765\u786e\u5b9a swizzle \u7c7b\u578b\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5b83\u4f7f\u7528 layout_type \u51fd\u6570\u6765\u63d0\u53d6 swizzle \u4fe1\u606f\uff1a template <class Engine, class Shape, class Stride> CUTE_HOST_DEVICE constexpr LayoutType layout_type(Tensor<Engine, Layout<Shape,Stride>> const&) { static_assert(is_same<uint128_t, typename Engine::value_type>::value, \"Expected uint128_t type in LayoutType conversion.\"); using Swizzle = get_swizzle_t<Engine>; constexpr int B = Swizzle::num_bits; constexpr int M = Swizzle::num_base; constexpr int S = Swizzle::num_shft; static_assert(M == 4, \"Unsupported layout swizzle\"); static_assert(0 <= B && B <= 3, \"Unsupported layout swizzle\"); static_assert(S == 3, \"Unsupported layout swizzle\"); switch (B) { case 0: return LayoutType::INTERLEAVE; case 1: return LayoutType::B32; case 2: return LayoutType::B64; case 3: return LayoutType::B128; } return LayoutType::INTERLEAVE; // ERROR } \u8fd9\u4e2a\u51fd\u6570\u4ece\u5f20\u91cf\u7684 Engine \u7c7b\u578b\u4e2d\u63d0\u53d6 Swizzle \u4fe1\u606f\uff0c\u7136\u540e\u6839\u636e Swizzle \u7684 num_bits \u5b57\u6bb5\u786e\u5b9a swizzle \u7c7b\u578b\uff1a \u5f53 num_bits = 0 \u65f6\uff0c\u5bf9\u5e94 LayoutType::INTERLEAVE (\u65e0 swizzle) \u5f53 num_bits = 1 \u65f6\uff0c\u5bf9\u5e94 LayoutType::B32 (32\u5b57\u8282 swizzle) \u5f53 num_bits = 2 \u65f6\uff0c\u5bf9\u5e94 LayoutType::B64 (64\u5b57\u8282 swizzle) \u5f53 num_bits = 3 \u65f6\uff0c\u5bf9\u5e94 LayoutType::B128 (128\u5b57\u8282 swizzle)","title":"Swizzle \u4fe1\u606f\u7684\u83b7\u53d6"},{"location":"cute_wgmma_sm90/#gmma-descriptor","text":"GMMA Descriptor \u662f\u901a\u8fc7 make_gmma_desc \u51fd\u6570\u6784\u5efa\u7684\u3002\u8fd9\u4e2a\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u5171\u4eab\u5185\u5b58\u5f20\u91cf\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u6839\u636e\u5f20\u91cf\u7684\u5e03\u5c40\u4fe1\u606f\u521b\u5efa\u76f8\u5e94\u7684\u63cf\u8ff0\u7b26\uff1a template <Major MajorMode, class TEngine, class TLayout> CUTE_HOST_DEVICE constexpr GmmaDescriptor make_gmma_desc(Tensor<TEngine,TLayout> const& tensor) { static_assert(is_smem<TEngine>::value, \"GMMA Descriptors can only be constructed on smem.\"); static_assert(TLayout::rank == 2, \"GMMA Descriptors can only be constructed on rank-2 tensors.\"); using value_type = typename TEngine::value_type; // ... \u5b9e\u73b0\u7ec6\u8282 ... } \u8fd9\u4e2a\u51fd\u6570\u4f1a\u5206\u6790\u5f20\u91cf\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u63d0\u53d6\u8d77\u59cb\u5730\u5740\u3001\u6b65\u5e45\u7b49\u4fe1\u606f\uff0c\u5e76\u6839\u636e\u5e03\u5c40\u7c7b\u578b\u8bbe\u7f6e\u76f8\u5e94\u7684 swizzle \u6a21\u5f0f\u3002","title":"GMMA Descriptor \u7684\u6784\u5efa\u8fc7\u7a0b"},{"location":"cute_wgmma_sm90/#descriptoriterator-smem_desc","text":"\u5728 CuTe \u4e2d\uff0c DescriptorIterator \u662f\u4e00\u4e2a\u5305\u88c5 GmmaDescriptor \u7684\u8fed\u4ee3\u5668\uff0c\u7528\u4e8e\u5728 GMMA \u64cd\u4f5c\u4e2d\u4f20\u9012\u63cf\u8ff0\u7b26\u4fe1\u606f\u3002 smem_desc \u662f\u4e00\u4e2a\u6a21\u677f\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u521b\u5efa\u5171\u4eab\u5185\u5b58\u63cf\u8ff0\u7b26\u5f20\u91cf\uff1a template <Major> struct smem_desc : DescriptorIterator {}; \u901a\u8fc7 MakeTensor \u5b9a\u5236\u70b9\u521b\u5efa smem_desc \u5f20\u91cf\uff1a // Customization point for creating a GMMA::smem_desc Tensor template <SM90::GMMA::Major MajorMode> struct MakeTensor<SMMA::GMMA::smem_desc<MajorMode>> { template <class TEngine, class TLayout> CUTE_HOST_DEVICE constexpr auto operator()(Tensor<TEngine,TLayout> const& smem_tensor) { static_assert(is_smem<TEngine>::value, \"Expected SMEM Tensor to construct a GMMA Desc Tensor\"); return make_tensor(SM90::GMMA::DescriptorIterator{SM90::GMMA::make_gmma_desc<MajorMode>(tensor<0>(smem_tensor))}, replace<0>(recast<uint128_t const>(smem_tensor).layout(), Layout<_1,_0>{})); } };","title":"DescriptorIterator \u548c smem_desc"},{"location":"cute_wgmma_sm90/#gmma_1","text":"GMMA \u652f\u6301\u591a\u79cd\u5171\u4eab\u5185\u5b58\u5e03\u5c40\uff0c\u5305\u62ec M|N-major \u548c K-major \u5e03\u5c40\uff1a","title":"GMMA \u5185\u5b58\u5e03\u5c40"},{"location":"cute_wgmma_sm90/#mn-major","text":"// M|N-major GMMA layouts in units of bits using Layout_MN_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape< _128,_8>,Stride<_1, _128>>>; using Layout_MN_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape< _256,_8>,Stride<_1, _256>>>; using Layout_MN_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape< _512,_8>,Stride<_1, _512>>>; using Layout_MN_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_1024,_8>,Stride<_1,_1024>>>;","title":"M|N-major \u5e03\u5c40"},{"location":"cute_wgmma_sm90/#k-major","text":"// K-major GMMA layouts in units of bits using Layout_K_INTER_Atom_Bits = ComposedLayout<Swizzle<0,4,3>, smem_ptr_flag, Layout<Shape<_8, _128>,Stride< _128,_1>>>; using Layout_K_SW32_Atom_Bits = ComposedLayout<Swizzle<1,4,3>, smem_ptr_flag, Layout<Shape<_8, _256>,Stride< _256,_1>>>; using Layout_K_SW64_Atom_Bits = ComposedLayout<Swizzle<2,4,3>, smem_ptr_flag, Layout<Shape<_8, _512>,Stride< _512,_1>>>; using Layout_K_SW128_Atom_Bits = ComposedLayout<Swizzle<3,4,3>, smem_ptr_flag, Layout<Shape<_8,_1024>,Stride<_1024,_1>>>;","title":"K-major \u5e03\u5c40"},{"location":"cute_wgmma_sm90/#gmma_2","text":"\u5178\u578b\u7684 GMMA \u64cd\u4f5c\u4f7f\u7528\u793a\u4f8b\uff1a // \u5b9a\u4e49\u8f93\u5165\u5f20\u91cf A\u3001B \u548c\u7d2f\u52a0\u5f20\u91cf C auto A_tensor = make_tensor(A_ptr, A_layout); auto B_tensor = make_tensor(B_ptr, B_layout); auto C_tensor = make_tensor(C_ptr, C_layout); // \u521b\u5efa GMMA \u64cd\u4f5c\u5bf9\u8c61 auto mma_atom = MMA_Atom<SM90_64x64x16_F32F16F16F32_NT>{}; // \u83b7\u53d6 MMA \u64cd\u4f5c\u7684\u53c2\u4e0e\u8005 auto mma_thr = mma_atom.get_thread_slice(thread_idx); // \u521b\u5efa\u7d2f\u52a0\u7247\u6bb5 auto accum_fragment = make_fragment_like(C_tensor); clear(accum_fragment); // \u6267\u884c MMA \u64cd\u4f5c mma_thr.call(A_tensor, B_tensor, accum_fragment);","title":"GMMA \u64cd\u4f5c\u793a\u4f8b"},{"location":"cute_wgmma_sm90/#_1","text":"SM90 \u67b6\u6784\u4e2d\u7684 GMMA \u6307\u4ee4\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u77e9\u9635\u8fd0\u7b97\u80fd\u529b\uff0c\u901a\u8fc7 GmmaDescriptor \u548c\u76f8\u5173\u7684\u5e03\u5c40\u5de5\u5177\uff0c\u5f00\u53d1\u8005\u53ef\u4ee5\u9ad8\u6548\u5730\u5229\u7528\u5171\u4eab\u5185\u5b58\u8fdb\u884c\u5927\u89c4\u6a21\u77e9\u9635\u8fd0\u7b97\u3002\u7406\u89e3\u8fd9\u4e9b\u6982\u5ff5\u548c\u5de5\u5177\u5bf9\u4e8e\u5145\u5206\u5229\u7528 Hopper \u67b6\u6784\u7684\u8ba1\u7b97\u80fd\u529b\u81f3\u5173\u91cd\u8981\u3002","title":"\u603b\u7ed3"}]}